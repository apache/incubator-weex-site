{"meta":{"title":"Weex","subtitle":null,"description":"A framework for building Mobile cross-platform UIs. Different from a \"web app\", \"HTML5 app\", or \"hybrid app\", you can use Weex to build a real mobile app. The code that you write is relatively simple, because you can build native applications just using HTML, CSS, Javascript. But underneath, the core of the application is Objective-C or Java. At the same time, Weex will provide a lot of native components or modules for developers to use.","author":"Jinjiang","url":"https://weex.apache.org"},"pages":[{"title":"How to Contribute","path":"guide/contributing.html","permalink":"https://weex.apache.org/guide/contributing.html","text":"How to ContributeWelcome to create pull requests or join in our mailing list for bugfix, doc, example, suggestion and anything. Join in Weex Mailing ListIn Weex community all discussion will happen on mailing list. Just send an email to dev-subscribe@weex.incubator.apache.org and follow the instructions to subscribe Weex dev mailing list. And then you will receive all discussions and community messages by your personal email. In the same time you can freely send your own emails to join in us. At the same time you can see the archives of all the mails through the web: http://mail-archives.apache.org/mod_mbox/incubator-weex-dev/ If you won’t follow the mailing list any more. There is another way to unsubscribe it: send an email to dev-unsubscribe@weex.incubator.apache.org and follow the instructions. Besides Weex dev mailing list, we also have some other mailing lists for you. You can check them out here: http://mail-archives.apache.org/mod_mbox/#weex.incubator Branch Managementmaster ↑dev &lt;--- PR(hotfix/typo/3rd-PR) ↑ PR&#123;domain&#125;-feature-&#123;date&#125; master branch master is the latest (pre-)release branch. dev branch dev is the stable developing branch. It’s RECOMMENDED to commit hotfix (like typo) or feature PR to dev. {domain}-feature-{date} branch The branch for a developing iteration, e.g. android-feature-20160607 is an android developing iteration which is done at 2016.06.07. {domain} consists of android, ios, jsfm and html5. DO NOT commit any PR to such a branch. Branch Name&#123;module&#125;-&#123;action&#125;-&#123;shortName&#125; {module}, see commit log module {action} feature: checkout from {module} and merge to {module} later. If {module} not exists, merge to dev bugfix: like feature, for bugfix only hotfix: checkout from master or release tag, merge to master and {module} later. If {module} not exists, merge to dev for example: android-bugfix-memory jsfm-feature-communication android-hotfix-compute-layout Commit Log&#123;action&#125; [&#123;module&#125;] &#123;description&#125; {action} + add * update or bugfix - remove {module} Including: android, ios, jsfm, html5, component, doc, website, example, test, all {description} Just make it as clear and simple as possible. for example: + [android] close #123, add refreshing for WebView * [doc] fix #123, update video auto-play property - [example] remove abc Pull RequestYou can create pull requests in GitHub. First we suggest you have some discussion with the community (commonly in our mailing list) before you code. Fork repo from https://github.com/apache/incubator-weex/ Finish the job you want to do. Create a pull request. Code Style GuideObjective-C Tabs for indentation(not spaces) * operator goes with the variable name (e.g. Type *variable;) Function definitions: place each brace on its own line. Other braces: place the open brace on the line preceding the code block; place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style.","type":"guide"},{"title":"Integrate to Your App","path":"guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/guide/integrate-to-your-app.html","text":"Integrate to Your AppIntegrate to AndroidTip：The following documents assume that you already have a certain Android development experience. Android has two ways to integrate weex1.using source code: Can quickly use the latest features of WEEX, according to your own characteristics of the project. So, you can do some related improvements. 2.using SDK: WEEX will regularly release a stable version at jcenter.jcenter PrerequisitesMake sure the following configuration is complete: JDK version &gt;= 1.7 , and configure the environment variable Android SDK installed and configure the environment variable Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) Quick to useIf you are the first time to try or have a higher demand for stability, you can use the way to dependence on the SDK.The steps are as follows: Create an Android project. There is nothing to be specified, according to your habits to. Update build.gradle by adding the following dependencies: compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' Note: the version can be high can not be low. Start writing codeNote: There is a complete code address in the appendix Implement the picture download interface, set the initialization. package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/*** Created by lixinke on 16/6/1.*/public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //To implement picture download interface, otherwise the picture can not be displayed. &#125;&#125; initialization package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/*** Note: add android:name=\".WXApplication\" into Manifest file* To implement ImageAdapter, otherwise the picture can not be downloaded* Gradle must add some dependencies, otherwise the initialization will fail.* compile 'com.android.support:recyclerview-v7:23.1.1'* compile 'com.android.support:support-v4:23.1.1'* compile 'com.android.support:appcompat-v7:23.1.1'* compile 'com.alibaba:fastjson:1.1.45'*/public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; Start rendering package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample can be replaced by any string * Template is js file that .we converted * Option can be empty, or through the option passed js required parameters. Such as the address of the bundle js. * JsonInitData can be empty. * width is -1 , default full screen, you can customize it. * height is -1 , default full screen, you can customize it. */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Dependence on source code (IDE Android Studio)1.Download source code. git clone https://github.com/alibaba/weex.2.Create an android project.3.Import the SDK Module through the following path:File-&gt;New-Import Module-&gt; chose WEEX SDK Module(weex/android/sdk) -&gt; Finish4.Add the following dependencies: compile project (‘: weex_sdk’) to build.gradle file.5.Other settings please refer to the above “Quick to use”. Appendix: WXSample address https://github.com/xkli/WXSample.git Integrated to iOSThrough the cocoaPods integrated Weex iOS SDK to the project.First assume that you have finished installing the iOS development environment and CocoaPods. Step 1: Add DependenciesImport Weex iOS SDK to your existing project, if not, you can create a new project.Before proceeding, make sure that the Podfile file is under the project file. If not, create one and open with text editor. Integration framework WeexSDK The latest version on cocoaPods can be obtained here .Add the following to the Podfile file: source &apos;git@github.com:CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.9.5&apos; ## Suggest using latest Weex SDKend Integrate with source code First copy the ios / sdk directory to your existing project directory (here to copy the root directory of your existing project as an example), and then add the Podfile file. source &apos;git@github.com:CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos; end Step 2: Install DependenciesOpen the command line, switch to the directory of the Podfile file, and run the pod install command. If there are no errors, it means that the environment has been configured. Step 3: Initialize the Weex environmentIn the AppDelegate.m file to do the initialization operation, usually in the didFinishLaunchingWithOptions method as follows to add. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel: WXLogLevelAll]; Step 4: Render weex InstanceWeex supports both full page rendering and partial rendering. What you need to do is render Weex’s view with the specified URL and add it to its parent container. The parent container is generally a viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;] [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very important class that provides a basic method and some callbacks, such as renderWithURL, onCreate, onFailed, etc., can be found in WXSDKInstance.h. Step 5: Destroy Weex InstanceIn the dealloc phase of the viewController destroyed Weex instance, can play a role in avoiding memory leaks. - (void)dealloc&#123; [_instance destroyInstance];&#125; Import the Weex SDK framework to the project.The Weex SDK can be compiled from the source code. You can try the latest feature in the new feature or bugfix branch.Refer to here for direct import of weexSDK.","type":"guide"},{"title":"Event Bubble","path":"references/bubble.html","permalink":"https://weex.apache.org/references/bubble.html","text":"Event Bubble v0.13+Weex 2.0 implements the W3C standard event bubbling mechanism. Usage&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the elements, you can see the event spread up, followed by the trigger. NoticeOne thing should be noticed: For compatibility with previous versions, Weex does not turn on event bubbling by default. You need to add bubble = &quot;true&quot; on the root element’s properties to turn on the bubbling mechanism. Otherwise, the event will not be propagated upwards, keeping the same effect as the previous version. stopPropagationIn the event handler function, you can use the e.stopPropagation() method to prevent the event from escalating. Note that e.stopPropagation() differs from bubble = &quot;true&quot;, which affects only the current elements and the propagation of parent elements, without affecting the propagation of child elements; the latter is a switching mechanism that is added for compatibility, Will be a global shutdown or open the bubble mechanism, the two can co-exist, as follows: &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the element, you can see the event up to the parent element is terminated, no longer continue to spread to the root element.","type":"references"},{"title":"Android APIs","path":"references/android-apis.html","permalink":"https://weex.apache.org/references/android-apis.html","text":"Android APIsWXSDKEngine Set up various adapters WXSDKEngine.initialize(this, new InitConfig.Builder().setImgAdapter(new ImageAdapter()).setDebugAdapter(new PlayDebugAdapter()).build()); Register the module and component WXSDKEngine.registerComponent(\"richtext\", RichText.class);WXSDKEngine.registerModule(\"event\", WXEventModule.class); Overloading framework WXSDKEngine.reload(this,framework,false); Adapter IWXImgLoaderAdapter Weex need to implement this interface to download the pictureThe interface is defined as follows: public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality that the quality of the picture variables, take the following values LOW, NORMAL, HIGH, ORIGINAL picture quality in turn higher. The default is LOW. WXImageStrategy is an extension class that indicates whether the image can be cut (isClipping) sharpening (isSharpen) placeholder (placeHolder) and so on. IWXHttpAdapter Weex custom WXRequest and OnHttpListener, Native reload interface can be obtained from the Request URL, Header and other parameters, the network request can be completed through OnHttpListener callback notification. Weex provides the default network request: DefaultWXHttpAdapter, using HttpURLConnection for network requests. The interface is defined as follows: public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest defines the parameters related to the network request, the request method, the request body, and the timeout time. Weex default timeout is 3000. OnHttpListener defines the corresponding method after the network request ends. Defined as follows: interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response); &#125; IWXUserTrackAdapter Weex related performance data (first screen loading time, JS-Native communication time, dom update time, etc.) and other general information (JSLib file size, Weex SDK version number, etc.).Interface definition: public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native implementation interface can be obtained through WXPerformance and params corresponding information. Native interacts with JavaScriptCustom eventsUsed for a custom control for event notifications, such as custom click events, response drop events, and so on. WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：The event occurred for the control ID。 type: Custom events, Weex defaults to a custom event starting with onXxxxx. OnPullDown (drop-down event) data: Need to reveal the parameters, such as the current control of the size, coordinates and other information。 domChanges：Update ref for the control’s Attribute and Style Event callbackUsed for Module callback, for example, after the completion of positioning Module need to notify JS. Use as follows: public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //Get the code for the location information ..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //notify once callback.invoke(data); //Continuous connection callback.invokeAndKeepAlive(data); //Invoke method and invokeAndKeepAlive two methods of choice &#125;&#125; OnWXScrollListenerWeex gets the scroll event You can register registerOnWXScrollListener via WXSDKInstanceThe interface is defined as follows: public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; IActivityNavBarSetterWeex provides WXNavigatorModule for navigation control, and the corresponding method can be customized by setting the IActivityNavBarSetter interface. Instructions: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); Other IntroductionsetSizeYou can use the mWXSDKInstance.setSize() method to change the size of the Weex container. DowngradeWeex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onException method in interface IWXRenderListener, and if it is an active demoulding errCode is a character that is divided by “|”. “|” The preceding character is 1 for active demotion, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"Color name","path":"references/color-names.html","permalink":"https://weex.apache.org/references/color-names.html","text":"List of the names of colorsBasic color keywords: Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords: Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"Common Events","path":"references/common-event.html","permalink":"https://weex.apache.org/references/common-event.html","text":"Common EventsWeex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Bellow are the common event attributes that can be added to weex components to define event actions. Click eventThe onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Longpress eventIf a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Appear eventIf a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Disappear eventIf a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Page eventWeex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"references"},{"title":"Common Style","path":"references/common-style.html","permalink":"https://weex.apache.org/references/common-style.html","text":"Common StyleAll of weex tags share some common style rules Box Model Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0 border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 NotesWeex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt;in iOS. This only happens to iOS, it works fine on Android. Although overflow:hidden is default on android, a view will not clip its children according to border-radius unless all the following condtions met. This only happens on Android, it works fine on iOS. The view type is div, a, cell, refresh or loading. OS version is Android 4.3 or higher. OS version is not Andorid 7.0 A view does not have background-image property nor OS version is Android 5.0 or higher. Example&lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex containerFlexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examplesa list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Positionwe can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; transformThe CSS transform property lets you modify the coordinate space of the CSS visual formatting model. Using it, elements can be translated, rotated and scaled. Currently supported format: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) transform-origin: number/percentage/keyword(top/left/right/bottom) Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; Pseudo class v0.9.5+Weex support four pseudo-classes: active, focus, disabled, enabled All components support active, but only the input component and the textarea component support focus, enabled, diabled. Rule the high priority override low priority when rules take effect at the same time such as: “input:active:enabled” will override “input:active” the interconnection rule as follow Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; Try it linear-gradient v0.10+Weex support linear-gradient background, You can see W3C description of the gradient. Supported componentsAll components in Weex support gradients UsageYou can use linear gradient by background-image property. background-image: linear-gradient(to top,#a80077,#66ff00); radial-gradient is not currently supported, do not use it. Weex currently supports two color gradients. The direction of the gradient is as follows: to rightFrom left to right to leftFrom right to left to bottomFrom top to bottom to topFrom bottom to top to bottom rightFrom the upper left corner to the lower right corner to top leftFrom the lower right corner to the upper left corner Note background-image and background-color are set at the same time, background-image precedes background-color. Do not use shorthand property such as background. Example&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; box-shadow v0.11+Weex supports box-shadow in iOS： inset,offset-x,offset-y, blur-radius,color Note box-shadow takes effect in iOS Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; Other Common Style opacity background-color Type of Style Value length type number type color type (The list of color keywords.) enumerated type Simple StepThese up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"references"},{"title":"downgrade","path":"references/downgrade.html","permalink":"https://weex.apache.org/references/downgrade.html","text":"downgradeWeex 2.0 downgrade change to module，please refer to downgrade","type":"references"},{"title":"Gesture","path":"references/gesture.html","permalink":"https://weex.apache.org/references/gesture.html","text":"Gesture Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Just set on attributes on a node to listen to gesture. TypeFor now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Horizontal/Vertical Pan v0.10+ . Mainly used for cell swipe gestures before conflict resolving system is completed. start/move/end state of the gesture will be passed by state property. Note: These gestures are in conflict with click event on Android currently. horizontalpan verticalpan Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. LongPress is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. PropertiesThe following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedToucheschangedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. ConstrainCurrently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting.","type":"references"},{"title":"HTML5 APIs","path":"references/html5-apis.html","permalink":"https://weex.apache.org/references/html5-apis.html","text":"HTML5 APIsVue APIs","type":"references"},{"title":"iOS APIs","path":"references/ios-apis.html","permalink":"https://weex.apache.org/references/ios-apis.html","text":"iOS APIsHandler(like Android Adapter) WXImgLoaderDefaultImpl Image load handler. Weex need to implement this interface to download the picture. The interface is defined as follows: @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native interacts with JavaScript Custom events Used for a custom control for event notifications, such as custom click events, response drop events, and so on. This is a method in the component base class that can be used directly. /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName * @param params * @param domChanges **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges Event callback Used for Module callback. There are two types of callback: WXModuleCallback: For performance reasons, the callback can only callback js once, and then will be released. WXModuleKeepAliveCallback: This callback can be set to multiple callbacks, multiple callbacks of the scene such as continually listen scrolls event and return to js. @implementation WXEchoModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);&#125; Set size of the Weex containerYou can use the setFrame(CGRect) method to change the size of the Weex container. DowngradeWeex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onFailed method in interface WXSDKInstance, and if it is an active demoulding error domain is TemplateErrorType, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"JS Framework APIs","path":"references/jsfm-apis.html","permalink":"https://weex.apache.org/references/jsfm-apis.html","text":"JS Framework APIsBroadcastChannel v0.9+BroadcastChannel API is the solution for inter-instance communication. Reference BroadcastChannel specification. MessageEvent specification API postMessage(message): Sends the given message to other BroadcastChannel objects set up for this channel. close: Closes the BroadcastChannel object, opening it up to garbage collection. onmessage: Event handler, the event will be triggered when the instance receive a message. Usageconst Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // in this case, it's \"Hulk Smash !!!\"&#125;// in another instanceconst Hulk = new BroadcastChannel('Avengers')Hulk.postMessage(\"Hulk Smash !!!\") Run the code above, Stack can receive the message from Hulk. NoticeOne thing should be noticed: The message object is not deep cloned. See the demo below: const a = new BroadcastChannel('app')const b = new BroadcastChannel('app')const message = &#123; lists: ['A', 'B']&#125;a.onmessage = function (event) &#123; // in this case, event.data is a reference of message console.assert(event.data === message)&#125;b.postMessage(message) In this case, event.data is strict equal to message. Compared to the deep clone, this behavior improves efficiency and reduces memory cost. However, developers are not recommended to cache or modify the event object when they are using it (All type of event handlers should have this restriction).","type":"references"},{"title":"Native DOM APIs","path":"references/native-dom-api.html","permalink":"https://weex.apache.org/references/native-dom-api.html","text":"Native DOM APIsWeex in the JS engine, for each page provides a set of Native DOM APIs. This interface is very close to the HTML DOM APIs. Using this interface we can control native rendering logic via JavaScript. And Weex upper layer of Vue 2.0 is based on this interface to adapt. In most cases, the JS framework will encapsulate native DOM APIs. That way, the developer does not need to work directly on the Native DOM. Document class: full page document. Node class: the base class of nodes. Element class: element node, inherited from Node, single view unit. Comment class: comment node, inherited from Node, no practical meaning, usually used as placeholders. Each Weex page has a weex.document object, which is an instance of the Document class and is the starting point for all the following interface calls. Let’s take a look at their usage in detail: Document classEach Document instance will automatically have a documentElement property when it is created. This attribute represents the document node. The document node can have a body, which is the main node of the document. Note: The document node body only accepts &lt;div&gt;, &lt;list&gt;, or &lt;scroller&gt; three types of element nodes. Constructornew Document(id: string, url: string?) Member methodcreateElement(tagName: string, props: Object?): Element Creates an Element instance of a specific type tagName, which is an element node. Props can contain attr objects and style objects. Such as createBody (&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}}). createComment(text: string): Comment Create an instance of ·Comment, which is a comment node and set a text description. createBody(tagName: string, props: Object?): Element Create a document body node and automatically mount it under documentElement. fireEvent(el: Element, type: string, e: Object?, domChanges: Object?)Triggers a particular type of event. When the event modifies the DOM’s properties or styles during the generation process, the fourth argument is used to describe the changes, and the parameter format is the same as the format of the createElement method above. destroy() Destroy the current document. Once the document is destroyed, it will no longer work. Read-only member variablesid: string Each Document instance has a unique id. This is also the only id that each Weex page has. URL: string? If the current Weex page has a JS bundle URL, the URL will be returned here. body: Element The main body of the document, the concept similar to the HTML DOM document.body. documentElement: Element Document node, the concept similar to the HTML DOM document.documentElement. The relationship between body and documentElement is: documentElement is the parent of the body. getRef(id): Node Get the node based on the node id. Node ClassConstructornew Node() Member methoddestroy() Read-only member variables or methodsref: string Each Node instance has its own unique ref value in the entire `Document instance. nextSibling: Node? previousSibling: Node? parentNode: Node? The three interfaces are consistent with the definition of HTML DOM. children: Node[] The node has an array of all child nodes. pureChildren: Node[] The node has an array of all the child elements. The difference between it and children is that pureChildren contains only the Element instance and not the Comment instance. Element class, inherited from NodeConstructornew Element(type: string, props: Object?) Creates an element node of a particular type type, and the props parameter can contain an attr object or a style object. DOM tree operationappendChild(node: Node)insertBefore(node: Node, before: Node?) The two interfaces are similar to HTML DOM. insertAfter(node: Node, after: Node?) Insert a new node before a child node. removeChild(node: Node, preserved: boolean?) Delete the child node node. Parameters preserved whether it is immediately removed from memory or temporarily retained. clear() Clear all child nodes. The DOM property itself operatessetAttr(key: string, value: string, silent: boolean?) setStyle(key: string, value: string, silent: boolean?) In the above two interfaces, when silent is true, the node only updates itself, does not pass the command to the client render layer. This parameter is used to handle user events that have changed the node-related properties at the time of occurrence, and will not send commands repeatedly to the client after the Native DOM has changed. addEvent(type: string, handler: Function) removeEvent(type: string) fireEvent(type: string, e: any) Bind events, unbind events, trigger events. Component method for a specific component typeSpecial: Different component types can have their own unique methods, such as &lt;web&gt; components support refresh method. You can see the description of each component. In this case, we will generate a specific component type of class, such as WebElement, which inherited from Element. Such as: WebElement inherited from ElementIndicates that a webview is embedded in the Wex page Refresh (): Refreshes the current webview Read-only member variables or methodsref, nextSibling, previousSibling, parentNode Inherited from Node. nodeType: number The number is always 1. type: string Consistent with the type in the constructor. attr: Object The key pair of all the characteristics of the current node. It is recommended to use the setAttr () method to modify, rather than directly modify the object here. style: Object The value of all the keys of the current node. It is recommended to modify the setStyle () method, rather than directly modify the object here. event: Object All events of the current node are bound. Each event type corresponds to an event handler method. It is recommended to use the addEvent () / removeEvent () method to modify, rather than directly modify the object here. toJSON(): Object Returns a JSON object that describes the element’s node, such as: {ref: string, type: string, attr: Object, style: Object, event: Array (string), children: Array}. Comment class, inherited from NodeConstructornew Comment(value: string) Read-only member variables or methodsref, nextSibling, previousSibling, parentNode Inherited from Node. nodeType: number The number is always 8. type: string The type is always &#39;comment&#39; value: string Consistent with the value in the constructor. toJSON(): Object Returns a JSON object describing the annotation node. For example: &lt;! - value -&gt;.","type":"references"},{"title":"Path","path":"references/path.html","permalink":"https://weex.apache.org/references/path.html","text":"Path0.9 This article will cover uri (url) usage in Weex. Including using image/typeface resources, deal with relative uri and how to access local and packaged asset files. Schemes LocalWeex SDK provide local scheme to access resources packaged with application, and of cource, it’s not working in the HTML5 runtime.Currently, developers can use this scheme with image and text’s font file location. In iOS, it’s always locate file in ‘bundle resources’. For example, a image component with local:///app_icon will load image file named ‘app_icon’ in bundle resouce, and font file work in the same way. In Android, image component will load from ‘drawable’ resource folder like ‘res/drawable-xxx’. But load font file is different, android framework can not load font file from ‘res’, so SDK will load it from asserts folder. HTTP/HTTPSIt’s working in the same way as in web, Weex support these at very beginning. FileUse file scheme to access local disk file. This scheme has its limitations: You would not hard coded a file url in source page. Because not matter it’s running in different platform(iOS, Android) or not, the content will be totally different in another device, which is depend to the specific device.So one possible case is getting the file url in runtime dynamically, which you can use it to diaplay a local disk image, or maybe upload it later. Relative URILike we do in HTML, weex process ‘relative URI’ in the same way. The relative URI, which start with /,.,..,//, will resolve by the bunle url.Means URL start with / will resolve to the root folder as bundle js file, . and .. will resolve to current and parent folder, and // will resolve to same scheme bundle js have. URI AdapterAll the above is the default implementation, developers can extend or override these their own by providing a ‘URI Adapter’. Same as the other adapters, Custom adapter should be set before Weex SDK is initializing.","type":"references"},{"title":"Set Up Development Environment","path":"guide/set-up-env.html","permalink":"https://weex.apache.org/guide/set-up-env.html","text":"Set up development environmentUsing dotWe is a good choice, but if you want to develop locally on your own machine, you will need to set up your development environment. You will need Node.js and the Weex CLI. You can install Node using nvm (Simple bash script to manage multiple active node.js versions). Run the following commands in a Terminal after installing nvm: $ nvm install 6.10.0$ nvm use 6.10.0 Node.js comes with npm, which lets you install the Weex CLI. Run the following command in a Terminal: $ npm install -g weex-toolkit$ weex -vv1.0.3weex-builder : v0.2.4weex-previewer : v1.3.4 NOTE: If you get an error like “permission error”, try installing with sudo. Then you can use the Weex command to verify that the installation is successful: Generate a new Weex projectYou can use the CLI to generate a Weex project called “awesome-project”. Run the following command in a Terminal: $ weex init awesome-project Then enter the awesome-project folder, the CLI has been for us to generate a standard project structure. UsageWe enter the awesome-project folder and install dependencies with the following commands: npm install Then run npm run dev and npm run serve to start watch mode and static server. Finally, we can see the Weex page in http://localhost:8080/index.html. You can modify this page in src/foo.vue. The code is shown below: &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"weex\"&gt;Hello Weex!&lt;/text&gt; &lt;text class=\"vue\"&gt;Hello Vue!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .weex &#123; font-size: 60px; text-align: center; color: #1B90F7; &#125; .vue &#123; font-size: 60px; text-align: center; margin-top: 30px; color: #41B883; &#125;&lt;/style&gt; If you’re curious to learn more about technical details, continue on to the next section. And don’t forget to write code at dotWe and preview at anytime.","type":"guide"},{"title":"Platform Differences Between Weex and Web","path":"references/platfrom-difference.html","permalink":"https://weex.apache.org/references/platfrom-difference.html","text":"Platform Differences Between Weex and WebWork in progresss.","type":"references"},{"title":"Text Style","path":"references/text-style.html","permalink":"https://weex.apache.org/references/text-style.html","text":"Text StyleText alike components share some common style rules. The text alike components currently includes text and input. Properties color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weightv0.9+: values: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal is equal to 400, bold equel to 700 default value: normal apply to: &lt;text&gt;, &lt;input&gt; ios support showing 9 kind of font-weight. android support showing 2 kind of font-weight:400,700, other value will map to 400 or 700 Some standard values like lighter, bolder, number unit are not supported. The effect not apply to all elements, just &lt;text&gt; and &lt;input&gt;. In another way, it’s not inherited. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"references"},{"title":"CSS unit","path":"references/unit.html","permalink":"https://weex.apache.org/references/unit.html","text":"CSS unitWork in progresss.","type":"references"},{"title":"Web standards","path":"references/web-standards.html","permalink":"https://weex.apache.org/references/web-standards.html","text":"Web standardsHTMLrefs: https://www.advancedwebranking.com/html/ 2016-12-11 Overview percentage name supported 98.1% &lt;head&gt; - 97.9% &lt;body&gt; - 97.9% &lt;html&gt; - 97% &lt;title&gt; - 93.9% &lt;meta&gt; - 89.9% &lt;div&gt; ✓ 89.6% &lt;a&gt; ✓ 88.5% &lt;script&gt; ✓ 86.5% &lt;link&gt; - 86.3% &lt;img&gt; ✓ 81.5% &lt;p&gt; - (can be customized) 75.6% &lt;span&gt; - (can be customized) 73.8% &lt;li&gt; - (can be customized) 73.7% &lt;ul&gt; - (can be customized) 70.3% &lt;br&gt; ✕ 60.4% &lt;style&gt; ✓ 55.8% &lt;h1&gt; - (can be customized) 52.7% &lt;h2&gt; - (can be customized) 48.4% &lt;input&gt; ✓ 46.9% &lt;form&gt; ✕ 44.3% &lt;strong&gt; - (can be customized) 43.1% &lt;h3&gt; - (can be customized) 30.9% &lt;table&gt; ✕ 30.3% &lt;tr&gt; ✕ 30.2% &lt;td&gt; ✕ Forms percentage name supported 49.5% &lt;option&gt; ✕ 30.2% &lt;input&gt; ✓ 16.6% &gt; [type=&quot;hidden&quot;] - 8% &gt; [type=&quot;text&quot;] ✓ 4.2% &gt; [type=&quot;submit&quot;] - 2% &gt; [type=&quot;checkbox&quot;] - (&lt;switch&gt;) 1.2% &gt; [type=&quot;email&quot;] ✓ 1.1% &gt; [type=&quot;radio&quot;] ✕ 0.9% &gt; [type=&quot;image&quot;] - 0.8% &gt; [type=&quot;button&quot;] - 0.6% &gt; [type=&quot;search&quot;] ✕ 0.6% &gt; [type=&quot;password&quot;] ✓ 0.1% &gt; [type=&quot;tel&quot;] ✓ 0.1% &gt; [type=&quot;number&quot;] ✓ 0% &gt; [type=&quot;reset&quot;] - 0% &gt; [type=&quot;file&quot;] ✕ 0% &gt; [type=&quot;date&quot;] ✓ 0% &gt; [type=&quot;url&quot;] ✓ 0% &gt; [type=&quot;range&quot;] ✕ 0% &gt; [type=&quot;color&quot;] ✕ 0% &gt; [type=&quot;time&quot;] ✓ 0% &gt; [type=&quot;datetime-local&quot;] ✕ 7.2% &lt;label&gt; - 6.1% &lt;form&gt; - 3.7% &lt;button&gt; - (can be customized) 2.6% &gt; [type=&quot;button&quot;] - 1.3% &gt; [type=&quot;submit&quot;] - 0% &gt; [type=&quot;reset&quot;] - 1.9% &lt;select&gt; ✕ 0.7% &lt;textarea&gt; ✓ 0.5% &lt;fieldset&gt; - 0.1% &lt;optgroup&gt; ✕ 0.1% &lt;legend&gt; - 0% &lt;progress&gt; ✕ 0% &lt;datalist&gt; - 0% &lt;output&gt; - 0% &lt;meter&gt; - CSS Propertiesrefs: https://www.chromestatus.com/metrics/feature/popularity 2016-12-11 percentage name supported 90.5115% display ✕ flex only 89.8243% margin ✓ (not support combo) 88.7012% width ✓ 88.6468% overflow ✓ iOS only, hidden only for Android 88.6432% background-color ✓ 88.0803% height ✓ 87.7648% font-size ✓ 87.3837% padding ✓ 87.2721% color ✓ 86.9788% text-align ✓ 86.6841% position ✓ relative by default, static not supported 86.6039% font-family ✓ 86.5943% font-weight ✓ 85.0072% opacity ✓ 80.6911% max-width ✕ 79.4476% box-sizing ✕ border-box only 75.7623% max-height ✕ 74.9939% webkit-user-select ✕ 57.0292% align-items ✓ 56.8182% justify-content ✓ space-around not supported well in browser 50.5941% flex-direction ✓ 48.5052% border ✓ 47.5161% top ✓ 46.9136% background ✕ 46.1552% cursor ✕ 46.1443% margin-left ✓ 46.0956% left ✓ 46.0848% text-decoration ✓ 45.9575% float ✕ 45.8391% border-bottom ✓ 45.7639% padding-left ✓ 45.7128% margin-top ✓ 45.7013% line-height ✓ 45.5836% background-image ✕ 45.0837% z-index ✕ 45.0649% right ✓ 45.0516% margin-bottom ✓ 45.0459% white-space ✕ 44.8710% margin-right ✓ 44.8476% vertical-align ✕ 44.6306% padding-top ✓ 44.1466% border-radius ✓ 44.0136% border-top ✓ 43.9815% padding-bottom ✓ 43.9392% padding-right ✓ 43.8539% visibility ✕ 43.4306% background-position ✕ 43.4098% background-repeat ✕ 43.0391% clear ✕ 42.9100% bottom ✓ 42.2092% content ✕ 42.0690% box-shadow ✕ 41.9004% border-color ✓ 41.7341% outline ✕ 41.4297% border-right ✓ 41.2605% border-left ✓ 41.1127% min-height ✕ 41.0736% font-style ✓ 41.0523% min-width ✕ 40.4298% list-style ✕ 39.7341% font ✕ 38.8999% background-size ✕ 38.7811% border-width ✓ 38.7718% border-collapse ✕ 37.8110% border-style ✓ 37.4962% text-overflow ✓ must work with lines 37.3471% text-transform ✕ 37.2154% transition ✕ 36.5155% overflow-y ✕ 36.3025% transform ✕ 36.2488% text-indent ✕ 35.5075% text-shadow ✕ 34.7607% webkit-appearance ✕ 34.1925% list-style-type ✕ 34.0238% border-spacing ✕ 33.6664% word-wrap ✕ 31.9961% overflow-x ✕ 31.9922% zoom ✕ 31.2495% border-bottom-left-radius ✕ 31.1306% pointer-events ✕ 31.1229% border-top-left-radius ✕ 30.2131% border-bottom-color ✓ 29.9608% border-top-color ✓ 29.4297% border-bottom-right-radius ✕ 29.2668% border-top-right-radius ✕ 28.6489% letter-spacing ✕ 27.8327% animation ✕ 26.6738% border-right-width ✓ 26.0169% src ✕ 25.2661% clip ✕ 25.2512% webkit-font-smoothing ✕ 25.1971% border-bottom-width ✓ 25.0246% border-right-color ✓ 24.7790% direction ✕ 24.4094% webkit-tap-highlight-color ✕ 23.9751% border-left-color ✓ 23.9321% border-top-width ✓ 23.7902% fill ✕ 23.2617% border-left-width ✓ 22.7278% table-layout ✕ 21.5766% word-break ✕ 20.4319% background-clip ✕ 19.3198% transform-origin ✕ 18.9233% filter ✕ 17.7879% resize ✕ 16.2501% flex ✕ 15.1656% font-variant ✕ 14.9181% text-rendering ✕ 14.7125% webkit-filter ✕ 14.5263% transition-duration ✕ 14.3966% transition-property ✕ 14.2124% webkit-box-orient ✕ 13.5432% outline-offset ✕ 12.9300% transition-timing-function ✕ 12.2788% unicode-range ✕ 12.0880% word-spacing ✕ 11.9124% quotes ✕ 11.6800% border-bottom-style ✓ 11.4263% webkit-background-clip ✕ 11.0070% flex-grow ✕ 10.5925% backface-visibility ✕ 10.4417% animation-name ✕ 10.4302% stroke ✕ 10.4144% animation-duration ✕ 10.2804% touch-action ✕ 9.9663% list-style-position ✕ 9.8662% order ✕ 9.7770% outline-width ✕ 9.7504% transition-delay ✕ 9.4689% border-top-style ✓ 9.3474% webkit-box-pack ✕ 9.3078% webkit-box-align ✕ 9.2375% page-break-inside ✕ 9.1898% webkit-line-clamp ✕ 8.9350% list-style-image ✕ 8.8339% page-break-after ✕ 8.5735% speak ✕ 8.4754% unicode-bidi ✕ 8.4307% animation-timing-function ✕ 8.1464% webkit-box-flex ✕ 8.0048% orphans ✕ 7.9947% widows ✕ 7.6671% flex-wrap ✓ not supported well in browser 7.5756% animation-fill-mode ✕ 7.4163% animation-delay ✕ 7.3284% border-left-style ✓ 7.1586% outline-color ✕ 6.9102% flex-shrink ✕ 6.7754% perspective ✕ 6.7748% border-right-style ✓ 6.4619% outline-style ✕ 6.0382% animation-iteration-count ✕ 5.9838% background-origin ✕ 5.9714% fill-opacity ✕ 5.9357% will-change ✕ 5.3740% stroke-width ✕ 5.3172% transform-style ✕ 5.2608% overflow-wrap ✕ 5.1730% background-attachment ✕ 4.9039% counter-increment ✕ 4.5950% counter-reset ✕ 4.5031% align-self ✕ 4.4109% webkit-box-ordinal-group ✕ 4.4046% webkit-animation-direction ✕ 3.7598% background-position-x ✕ 3.6867% border-image ✕ 3.6601% background-position-y ✕ 3.5749% webkit-user-drag ✕ 3.3376% flex-basis ✕ 3.1840% align-content ✕ 3.1832% flex-flow ✕ 3.1774% image-rendering ✕ 3.0879% webkit-margin-start ✕ 2.9551% font-stretch ✕ 2.8934% empty-cells ✕ 2.7619% webkit-margin-after ✕ 2.7220% perspective-origin ✕ 2.6125% webkit-margin-end ✕ 2.6089% column-count ✕ 2.5880% webkit-text-fill-color ✕ 2.5466% webkit-box-direction ✕ 2.4618% font-feature-settings ✕ 2.3959% webkit-mask-image ✕ 2.3431% webkit-padding-end ✕ 2.2555% stroke-dasharray ✕ 2.1788% user-select ✕ 2.1679% object-fit ✕ 2.0643% column-gap ✕ 2.0459% text-size-adjust ✕ 2.0253% caption-side ✕ 1.9695% stroke-dashoffset ✕ 1.7923% stroke-linecap ✕ 1.7861% animation-direction ✕ 1.7559% webkit-font-feature-settings ✕ 1.7404% stroke-opacity ✕ 1.5926% stroke-miterlimit ✕ 1.5786% fill-rule ✕ 1.4859% webkit-user-modify ✕ 1.3439% webkit-border-image ✕ 1.3091% animation-play-state ✕ 1.2676% contain ✕ 1.2029% webkit-padding-start ✕ 1.1840% webkit-margin-before ✕ 1.1269% page-break-before ✕ 1.1222% webkit-margin-top-collapse ✕ 1.0418% columns ✕ 1.0354% webkit-mask-size ✕ 0.9650% border-image-slice ✕ 0.9425% stop-color ✕ 0.9408% webkit-mask-repeat ✕ 0.9125% webkit-box-lines ✕ 0.8804% webkit-column-break-inside ✕ 0.8752% size ✕ 0.8334% font-kerning ✕ 0.8034% stroke-linejoin ✕ 0.7869% tab-size ✕ 0.7689% break-inside ✕ 0.7589% webkit-text-stroke-width ✕ 0.7353% column-width ✕ 0.6924% webkit-mask-position ✕ 0.6869% border-image-width ✕ 0.6323% border-image-repeat ✕ 0.5994% border-image-outset ✕ 0.5885% all ✕ 0.5859% webkit-text-stroke-color ✕ 0.5435% webkit-print-color-adjust ✕ 0.5420% webkit-text-stroke ✕ 0.5195% writing-mode ✕ 0.4741% clip-rule ✕ 0.4685% webkit-clip-path ✕ 0.4578% text-anchor ✕ 0.4535% shape-rendering ✕ 0.4526% webkit-column-break-before ✕ 0.4494% clip-path ✕ 0.4452% webkit-mask ✕ 0.4393% mix-blend-mode ✕ 0.4166% text-align-last ✕ 0.4033% column-rule ✕ 0.3990% webkit-mask-box-image ✕ 0.3989% font-variant-ligatures ✕ 0.3881% column-fill ✕ 0.3865% webkit-line-break ✕ 0.3857% border-image-source ✕ 0.3528% stop-opacity ✕ 0.3075% webkit-perspective-origin-y ✕ 0.3054% webkit-perspective-origin-x ✕ 0.2994% webkit-writing-mode ✕ 0.2717% dominant-baseline ✕ 0.2634% column-rule-color ✕ 0.2586% webkit-box-decoration-break ✕ 0.2467% webkit-text-security ✕ 0.2374% webkit-background-origin ✕ 0.2146% font-variant-caps ✕ 0.2005% column-rule-style ✕ 0.1976% shape-outside ✕ 0.1971% webkit-padding-before ✕ 0.1896% break-after ✕ 0.1782% webkit-padding-after ✕ 0.1774% text-orientation ✕ 0.1747% webkit-text-orientation ✕ 0.1655% mask ✕ 0.1626% alignment-baseline ✕ 0.1572% page ✕ 0.1530% webkit-column-break-after ✕ 0.1521% webkit-box-reflect ✕ 0.1504% webkit-text-emphasis-color ✕ 0.1499% object-position ✕ 0.1470% break-before ✕ 0.1455% webkit-margin-collapse ✕ 0.1452% baseline-shift ✕ 0.1451% hyphens ✕ 0.1309% rx ✕ 0.1304% ry ✕ 0.1256% background-blend-mode ✕ 0.1136% font-variant-numeric ✕ 0.1135% background-repeat-x ✕ 0.1123% background-repeat-y ✕ 0.1086% webkit-text-emphasis ✕ 0.1058% webkit-rtl-ordering ✕ 0.1040% column-rule-width ✕ 0.1036% isolation ✕ 0.1002% webkit-highlight ✕ 0.0843% webkit-transform-origin-y ✕ 0.0786% webkit-transform-origin-x ✕ 0.0770% webkit-app-region ✕ 0.0685% column-span ✕ 0.0653% r ✕ 0.0611% y ✕ 0.0602% x ✕ 0.0555% webkit-border-vertical-spacing ✕ 0.0545% webkit-border-horizontal-spacing ✕ 0.0542% webkit-border-start-width ✕ 0.0450% webkit-border-start-color ✕ 0.0424% webkit-border-after-width ✕ 0.0424% webkit-border-before-width ✕ 0.0423% webkit-border-end-width ✕ 0.0351% marker ✕ 0.0349% webkit-border-end-color ✕ 0.0347% webkit-border-after-color ✕ 0.0347% webkit-border-before-color ✕ 0.0342% mask-type ✕ 0.0328% color-interpolation-filters ✕ 0.0325% webkit-border-end ✕ 0.0319% vector-effect ✕ 0.0307% color-rendering ✕ CSS Units and Valuesrefs: https://drafts.csswg.org/css-values/ 2016-12-11 Textual pre-defined keywords CSS-wide keywords initial inherit unset &lt;custom-ident&gt;: author-defined identifiers ✓ &lt;string&gt;: quoted strings (&quot;xxx&quot;) &lt;url&gt;: resourec locators (url()) Numeric &lt;integer&gt; ✓ &lt;number&gt; ✓ &lt;percentage&gt; Length &lt;length&gt; relative font-relative em ex ch ic rem ✓🔧 viewport-percentage vw ✓🔧 vh ✓🔧 vi vb vmin ✓🔧 vmax ✓🔧 absolute cm ✓🔧 mm ✓🔧 Q ✓🔧 in ✓🔧 pc ✓🔧 pt ✓🔧 px autofixed to number Quantities &lt;angle&gt; deg grad rad turn &lt;time&gt; s ms &lt;frequency&gt; Hz kHz &lt;resolution&gt; dpi dpcm dppx Elsewhere &lt;color&gt; ✓ &lt;image&gt; &lt;position&gt; Functional calc() toggle() attr() JS APIsrefs: https://www.w3.org/standards/techs/js 2016-12-11 Completed WorkStandards last update spec supported 2016-11-17 Media Source Extensions™ - (media related) 2016-11-08 Geolocation API Specification 2nd Edition ✕ developing 2016-10-27 Pointer Lock - 2016-10-18 Vibration API (Second Edition) ✕ 2016-04-19 Web Storage (Second Edition) ✓ async storage module 2015-10-22 Web Notifications ✕ 2015-05-19 HTML5 Web Messaging ✕ BroadcastChannel developing 2015-02-24 Pointer Events - 2015-02-10 Vibration API ✕ 2015-02-03 Server-Sent Events ✕ 2015-01-08 Indexed Database API ✕ 2014-03-13 Metadata API for Media Resources 1.0 - (media related) 2014-02-11 Progress Events ✕ 2014-01-16 JSON-LD 1.0 Processing Algorithms and API - 2013-12-12 Performance Timeline - (perf related) 2013-12-12 User Timing - (perf related) 2013-10-31 Widget Interface - 2013-10-29 Page Visibility (Second Edition) ✕ onviewappear/onviewdisappear 2013-10-10 Touch Events ✕ 2013-02-21 Selectors API Level 1 - 2012-12-17 Navigation Timing - (perf related) 2012-12-17 High Resolution Time - (perf related) 2008-12-22 Element Traversal Specification - DraftsProposed Recommendations last update spec supported 2016-09-15 WebIDL Level 1 - Candidate Recommendations last update spec supported 2016-12-08 Performance Timeline Level 2 - (perf related) 2016-11-22 Page Visibility Level 2 ✕ onviewappear/onviewdisappear 2016-11-01 High Resolution Time Level 2 - (perf related) 2016-08-18 DeviceOrientation Event Specification ✕ 2016-07-21 Resource Timing Level 1 - (perf related) 2016-07-14 Presentation API - 2016-07-07 Battery Status API ✕ 2016-07-05 Encrypted Media Extensions - 2016-05-19 Media Capture and Streams - (media related) 2014-12-11 Web Cryptography API - 2014-09-09 HTML Media Capture - (media related) 2012-09-20 The WebSocket API ✕ Last Call Drafts last update spec supported 2011-12-01 Geolocation API Specification Level 2 ✕ Other Working Drafts last update spec supported 2016-12-09 MediaStream Image Capture - (media related) 2016-12-06 MediaStream Recording - (media related) 2016-12-06 Selection API ✕ 2016-12-05 Input Events ✕ 2016-12-02 Gamepad - 2016-11-29 WebDriver - 2016-11-24 WebRTC 1.0: Real-time Communication Between Browsers ✕ 2016-11-22 Pointer Lock 2.0 - 2016-11-07 Remote Playback API - (media related) 2016-11-03 Resource Timing Level 2 - (perf related) 2016-11-02 Audio Output Devices API - (media related) 2016-11-01 Indexed Database API 2.0 ✕ 2016-11-01 User Timing Level 2 - (perf related) 2016-10-31 The Screen Orientation API ✕ 2016-10-31 High Resolution Time Level 3 - (perf related) 2016-10-24 UI Events KeyboardEvent code Values - 2016-10-24 UI Events KeyboardEvent key Values - 2016-10-11 Service Workers 1 ✕ 2016-09-21 Identifiers for WebRTC’s Statistics API - 2016-09-13 Accelerometer Sensor ✕ 2016-09-13 Gyroscope Sensor ✕ 2016-09-13 Magnetometer Sensor ✕ 2016-08-30 Ambient Light Sensor ✕ 2016-08-30 Media Capture from DOM Elements - (media related) 2016-08-30 Generic Sensor API ✕ 2016-08-03 Wake Lock API ✕ 2016-07-19 Proximity Sensor ✕ 2016-07-19 Pointer Events - Level 2 - 2016-07-14 Screen Capture ✕ 2016-07-12 Media Capture Depth Stream Extensions - (media related) 2016-05-17 Cooperative Scheduling of Background Tasks ✕ 2016-04-22 Navigation Timing Level 2 - (perf related) 2016-04-03 Clipboard API and events ✕ clipboard module 2015-12-15 Push API ✕ 2015-12-08 Web Audio API - (media related) 2015-10-15 FindText API - 2015-09-24 Web Workers ✕ 2015-04-21 File API ✕ 2014-02-20 Network Service Discovery ✕ 2012-03-06 MediaStream Capture Scenarios - (media related) 2011-12-15 Audio Processing API - (media related)","type":"references"},{"title":"Weex Variable","path":"references/weex-variable.html","permalink":"https://weex.apache.org/references/weex-variable.html","text":"Weex instance variableEach Weex page has a separate weex variable, which exists in the JS context. They hold a single instance or method of the current Weex page. weex.config This variable contains all the environment information for the current Weex page, including not only: BundleUrl: string: The URL of the JS bundle. Env: Object: environment object. WeexVersion: string: Weex sdk version. AppName: string: application name. AppVersion: string: app version. Platform: string: platform information, that is ‘iOS’, ‘android’ or ‘Web’. OsVersion: string: system version. DeviceModel: string: device model (native application only). DeviceWidth: number: device width DeviceHeight: number: device height. In Weex, the default width of viewport is 750px, thus you can obtain the height of screen by height = 750/deviceWidth*deviceHeight if the width of viewport remains its default value. weex.requireModule(module: string): Object Get all the methods of a native module, such as: &lt;template&gt; &lt;div&gt;&lt;text&gt;Hello World&lt;/text&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; var modal = weex.requireModule('modal') modal.toast({ message: 'I am a toast.', duration: 3 }) &lt;/script&gt; weex.document: Document Returns the document object of the current Weex page.","type":"references"},{"title":"如何参与社区","path":"cn/guide/contributing.html","permalink":"https://weex.apache.org/cn/guide/contributing.html","text":"如何参与社区加入 Weex 邮件列表 (Mailing List)在 Weex 官方社区所有的信息都会汇聚于邮件列表。订阅开发邮件列表的方式是发送邮件到 dev-subscribe@weex.incubator.apache.org 然后你的邮箱会收到一封来自 Apache 的回信 (英文)，把 Apache 的这封回信再次回复过去，即可完成订阅。 这里需要强调的是 Apache 是一个面向全球的全英文的社区，所以我们希望您能够用英文在邮件列表中跟大家交流。 如果您确实对使用英文存在很大的疑虑或困惑，我们也非常欢迎大家来中文问答平台 SegmentFault 提问，这里有非常多热心的开发者一起讨论和解答 Weex 相关的问题。 使用邮件列表的另外一个好处是它可以方便大家随时查阅之前的邮件记录: http://mail-archives.apache.org/mod_mbox/incubator-weex-dev/ 如果您对邮件列表中的内容已经不再感兴趣，这里也有退订邮件列表的方法: 发送邮件至 dev-unsubscribe@weex.incubator.apache.org 并根据回信的提示进行二次回复确认，完成退订。 除了开发 (dev) 邮件列表，我们还有另外几个的邮件列表供大家查阅：http://mail-archives.apache.org/mod_mbox/#weex.incubator 分支管理 (英)master ↑dev &lt;--- PR(hotfix/typo/3rd-PR) ↑ PR&#123;domain&#125;-feature-&#123;date&#125; master branch master is the latest (pre-)release branch. dev branch dev is the stable developing branch. It’s RECOMMENDED to commit hotfix (like typo) or feature PR to dev. {domain}-feature-{date} branch The branch for a developing iteration, e.g. android-feature-20160607 is an android developing iteration which is done at 2016.06.07. {domain} consists of android, ios, jsfm and html5. DO NOT commit any PR to such a branch. 分支命名&#123;module&#125;-&#123;action&#125;-&#123;shortName&#125; {module}, see commit log module {action} feature: checkout from {module} and merge to {module} later. If {module} not exists, merge to dev bugfix: like feature, for bugfix only hotfix: checkout from master or release tag, merge to master and {module} later. If {module} not exists, merge to dev for example: android-bugfix-memory jsfm-feature-communication android-hotfix-compute-layout 提交日志格式 (英)&#123;action&#125; [&#123;module&#125;] &#123;description&#125; {action} + add * update or bugfix - remove {module} Including: android, ios, jsfm, html5, component, doc, website, example, test, all {description} Just make it as clear and simple as possible. for example: + [android] close #123, add refreshing for WebView * [doc] fix #123, update video auto-play property - [example] remove abc 发送 Pull Request (英)You can create pull requests in GitHub. First we suggest you have some discussion with the community (commonly in our mailing list) before you code. Fork repo from https://github.com/apache/incubator-weex/ Finish the job you want to do. Create a pull request. 编码规范 (英)Objective-C Tabs for indentation(not spaces) * operator goes with the variable name (e.g. Type *variable;) Function definitions: place each brace on its own line. Other braces: place the open brace on the line preceding the code block; place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style.","type":"guide"},{"title":"集成 Weex 到已有应用","path":"cn/guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/cn/guide/integrate-to-your-app.html","text":"集成 Weex 到已有应用集成到 Android注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio) 下载源码 git clone https://github.com/alibaba/weex 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录WXSample地址 https://github.com/xkli/WXSample.git 集成到 iOS通过cocoaPods 集成 Weex iOS SDK到你的项目首先假设你已经完成了安装 iOS 开发环境 和 CocoaPods 第一步：添加依赖导入 Weex iOS SDK 到你已有的项目, 如果没有，可以参考新建项目在继续下面内容之前，确保你已有的项目目录有名称为 Podfile 文件，如果没有，创建一个，用文本编辑器打开 集成 framework WeexSDK 在 cocoaPods 上最新版本 可以在这获取 在 Podfile 文件中添加如下内容 source &apos;git@github.com:CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.9.5&apos; ## 建议使用WeexSDK新版本 end 源码集成 首先 拷贝 ios/sdk 目录到你已有项目目录 (此处以拷贝到你已有项目的根目录为例子)，然后在 Podfile 文件中添加 source &apos;git@github.com:CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos; end 第二步：安装依赖打开命令行，切换到你已有项目 Podfile 这个文件存在的目录，执行 pod install，没有出现任何错误表示已经完成环境配置。 第三步：初始化 Weex 环境在 AppDelegate.m 文件中做初始化操作，一般会在 didFinishLaunchingWithOptions 方法中如下添加。 //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel: WXLogLevelAll]; 第四步：渲染 weex InstanceWeex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 Weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController。 #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;] [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如 renderWithURL, onCreate, onFailed 等，可以参见 WXSDKInstance.h 的声明。 第五步：销毁 Weex Instance 在 viewController 的 dealloc 阶段 销毁掉 Weex instance，释放内存，避免造成内存泄露。 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework 到工程 可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature。 参考此处直接导入 weexSDK。","type":"guide"},{"title":"搭建开发环境","path":"cn/guide/set-up-env.html","permalink":"https://weex.apache.org/cn/guide/set-up-env.html","text":"搭建开发环境使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本节会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试。首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.3.1$ npm -v3.10.3 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 注意: weex-toolkit 在 1.0.1 之后才支持初始化 Vue 项目，使用前请确认版本是否正确。 $ npm install -g weex-toolkit$ weex -vv1.0.3weex-builder : v0.2.4weex-previewer : v1.3.4 国内开发者可以考虑使用淘宝的 npm 镜像 —— cnpm 安装 weex-toolkit $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第二步：初始化然后初始化 Weex 项目： $ weex init awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 第三步：开发之后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启静态服务器 debug: 调试模式 我们先通过 npm install 安装项目依赖。之后运行 npm run dev 和 npm run serve 开启watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 weex h5 页面。 初始化时已经为我们创建了基本的示例，我们可以在 src/foo.vue 中查看。 代码如下所示： &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"weex\"&gt;Hello Weex !&lt;/text&gt; &lt;text class=\"vue\"&gt;Hello Vue !&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .weex &#123; font-size: 60px; text-align: center; color: #1B90F7; &#125; .vue &#123; font-size: 60px; text-align: center; margin-top: 30px; color: #41B883; &#125;&lt;/style&gt; 关于 Weex 语法部分，你可以直接参考 Vue Guide，这里不再重复介绍。如果您想了解有关技术详情的更多信息，请继续阅读下一节。并且不要忘记在 dotWe 写代码并随时预览。","type":"guide"},{"title":"事件冒泡","path":"cn/references/bubble.html","permalink":"https://weex.apache.org/cn/references/bubble.html","text":"事件冒泡 v0.13+Weex 2.0 实现了 W3C 标准的事件冒泡机制。 使用&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播，依次触发。 注意需要注意的是: 为了兼容之前的版本，Weex 默认不会开启事件冒泡机制。需要在根元素的属性上，添加 bubble=&quot;true&quot; 来开启冒泡机制。否则，将不会向上传播事件，保持与之前版本的效果相同。 stopPropagation在事件处理函数中，可以使用 e.stopPropagation() 方法，来阻止本次事件向上的传递过程。注意，e.stopPropagation() 与 bubble=&quot;true&quot; 不同，前者只会影响当前元素以及父元素的传播，不会影响子元素的传播；后者是为了版本兼容而增加的开关机制，会全局关闭或者开启冒泡机制，两者可以共同存在使用，如下： &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播到父元素被终止，不再继续往根元素传播。","type":"references"},{"title":"Android APIs","path":"cn/references/android-apis.html","permalink":"https://weex.apache.org/cn/references/android-apis.html","text":"Android APIsWeex 初步接入请参考：https://github.com/weexteam/article/issues/25 WXSDKEngine 是 Weex 对外的总入口。主要提供了一下功能： 设置相关 Adapter 和获取 adapter。 注册自定义 module 和 component 重置 JSFramework Adapter 介绍Weex 为了重用 Native 通用库提供了对应的接口进行设置。 IWXImgLoaderAdapter 图片适配器。 Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。 Weex 没有提供图片默认实现。 接口定义如下： public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality 表示图片的质量，WXImageQuality 取如下值 LOW, NORMAL, HIGH, ORIGINAL 图片质量依次变高。默认为 LOW。WXImageStrategy 为扩展类，表示了图片是否可以裁剪 (isClipping) 锐化 (isSharpen) 占位符 (placeHolder) 等。 IWXHttpAdapter 网络下载适配器。 Weex 自定义了 WXRequest 和 OnHttpListener，Native 重载接口后可以从 Request 中获取URL，Header 等参数，网络请求完成后可以通过 OnHttpListener 进行回调通知。Weex 提供了默认网络请求：DefaultWXHttpAdapter， 使用的是 HttpURLConnection 进行网络请求。 接口定义如下： public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest 定义了网络请求相关的参数，请求方法，请求主体，超时时间。Weex默认超时时间是3000. OnHttpListener 定义了网络请求结束后对应方法。定义如下： interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response);&#125; IWXUserTrackAdapter Weex 相关性能数据 (首屏加载时间、JS-Native 通信时间、dom 更新时间等) 和其他通用信息 (JSLib 文件大小, Weex SDK 版本号等)。 接口定义： public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native 实现接口后可以通过 WXPerformance 和 params 获取对应的信息。WXPerformane 对应字段表示含义请参考文档：https://github.com/weexteam/article/issues/124 后续随着开发 Weex 还会定义更多的 Adapter，此文档也会定时更新。 Native 和 JS 通信 自定义事件通知 多用于某个自定义控件进行事件通知，例如自定义点击事件，响应下拉事件等。 WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：事件发生的控件 ID。 type: 自定义事件，Weex 默认以 onXxxxx 开头为自定义事件。onPullDown (下拉事件)。 data: 需要透出的参数，例如当前控件的大小，坐标等其他信息。 domChanges：更新 ref 对应控件的 Attribute 和 Style。 事件回调 多用于 Module 回调，例如定位 Module 完成后需要通知 JS。使用方法如下： public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //获取定位代码..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //通知一次 callback.invoke(data); //持续通知 callback.invokeAndKeepAlive(data); //invoke方法和invokeAndKeepAlive两个方法二选一 &#125;&#125; 注册滑动事件Weex 获取滑动事件可以通过 WXSDKInstance 注册 registerOnWXScrollListener 监听 接口定义如下： public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; 自定义NavBarWeex 提供了 WXNavigatorModule 进行导航控制，对应的方法可以通过设置 IActivityNavBarSetter 接口进行定制。 使用方法: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); 其他介绍动态适配容器因为 Android 手机的碎片化导致屏幕适配很困难。Weex 对外提供的接口 render 需要动态传入容器的宽高，但是传入的宽高有时会发生变化，例如 ActionBar 隐藏等，这是传入的 Weex 容器也要进行对应的变化。为了适应这种变化，Weex 提供了接口 WXSDKInstance.setSize(int width, int height) 来改变容器的大小。 /** * * @param width 容器宽度 * @param height 容器高度 */ public void setSize(int width, int height)&#123;&#125;; 降级使用Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 IWXRenderListener 中的 onException 方法进行处理，如果是主动降级 errCode 是以“|”分割的字符。“|”前面的字符为1表示主动降级，Native 端可以跳转到对应的 H5 页面。或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"颜色名称列表","path":"cn/references/color-names.html","permalink":"https://weex.apache.org/cn/references/color-names.html","text":"Weex 支持的所有颜色名称基础颜色关键词: 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词: 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"通用事件","path":"cn/references/common-event.html","permalink":"https://weex.apache.org/cn/references/common-event.html","text":"通用事件Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 longpress如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 Appear 事件如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象 type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Disappear 事件如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象 type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Page 事件注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象 type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"references"},{"title":"通用样式","path":"cn/references/common-style.html","permalink":"https://weex.apache.org/cn/references/common-style.html","text":"通用样式所有 Weex 组件都支持以下通用样式规则。 盒模型 Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 &lt;image&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例：&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400px; height: 200px; margin-left: 20px;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div v-for=\"(v, i) in list\" class=\"row\"&gt; &lt;div v-for=\"(text, k) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80px; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200px; height: 200px; background-color: #fc0000; &#125;&lt;/style&gt; 定位Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例 &lt;template scoped&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400px; height: 400px; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150px; left: 150px; background-color: #0055dd; &#125; .box3 &#123; top: 300px; left: 300px; background-color: #00ff49; &#125;&lt;/style&gt; transformtransform 属性向元素应用 2D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 目前支持的 transform 声明格式: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) transform-origin: number/percentage/keyword(top/left/right/bottom) 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; 伪类 v0.9.5+Weex 支持四种伪类：active, focus, disabled, enabled 所有组件都支持 active, 但只有 input 组件和 textarea 组件支持 focus, enabled, disabled。 规则 同时生效的时候，优先级高覆盖优先级低 例如：input:active:enabled 和 input:active 同时生效，前者覆盖后者 互联规则如下所示 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; 试一下 线性渐变 v0.10+Weex 支持线性渐变背景，具体介绍可参考 W3C description of the gradient。 所有组件均支持线性渐变。 使用 你可以通过 background-image 属性创建线性渐变。 background-image: linear-gradient(to top,#a80077,#66ff00); 目前暂不支持 radial-gradient（径向渐变）。 Weex 目前只支持两种颜色的渐变，渐变方向如下： to right从左向右渐变 to left从右向左渐变 to bottom从上到下渐变 to top从下到上渐变 to bottom right从左上角到右下角 to top left从右下角到左上角 Note background-image 优先级高于 background-color，这意味着同时设置 background-image 和 background-color，background-color 被覆盖。 不要使用 background 简写. 示例&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; 阴影(box-shadow) v0.11+Weex 支持阴影属性：active, focus, disabled, enabled inset(可选),offset-x,offset-y, blur-radius,color 注意 box-shadow仅仅支持iOS 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; 其他基本样式 opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式如果对于样式写法需要更多上手参考，可参考每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"references"},{"title":"降级方案","path":"cn/references/downgrade.html","permalink":"https://weex.apache.org/cn/references/downgrade.html","text":"降级方案Weex 2.0 降级方案改成模块的形式支持，具体请参考downgrade","type":"references"},{"title":"手势","path":"cn/references/gesture.html","permalink":"https://weex.apache.org/cn/references/gesture.html","text":"手势注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上设置 on 特性来监听手势即可。 手势类型目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三中类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend horizontalpan v0.10+：手势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 verticalpan v0.10+：势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedToucheschangedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 约束目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。","type":"references"},{"title":"HTML5 APIs","path":"cn/references/html5-apis.html","permalink":"https://weex.apache.org/cn/references/html5-apis.html","text":"HTML5 APIsWeex HTML5 APIs 与 Vue APIs 保持一致，请直接参考 Vue APIs。","type":"references"},{"title":"Native DOM APIs","path":"cn/references/native-dom-api.html","permalink":"https://weex.apache.org/cn/references/native-dom-api.html","text":"Native DOM APIsWeex 在 JS 引擎中，为每个页面都提供了一套 Native DOM APIs，这套接口和 HTML DOM APIs 非常接近，利用这套接口我们可以通过 JavaScript 控制 native 的渲染逻辑。而且 Weex 上层的 Vue 2.0 也是基于这套接口进行适配的。 绝大多数情况下 JS 框架会把 Native DOM APIs 都封装好，开发者不需要直接对 Native DOM 进行操作。 Document 类，整个页面文档。 Node 类，结点的基础类。 Element 类，元素结点，继承自 Node，单个视图单元。 Comment 类，注释结点，继承自 Node，无实际意义，通常用作占位符。 每个 Weex 页面都有一个 weex.document 对象，该对象就是一个 Document 类的实例，也是下面所有接口调用的起点。 接下来详细介绍它们的用法： Document 类每个 Document 实例在创建的时候都会自动拥有一个 documentElement 属性，表示文档结点。该文档结点可以拥有一个 body，即文档的主体结点。 注意事项: 文档的主体结点只接受 &lt;div&gt;、&lt;list&gt; 或 &lt;scroller&gt; 三种类型的元素结点。 构造函数new Document(id: string, url: string?) 成员方法createElement(tagName: string, props: Object?): Element 创建一个特定类型 tagName 的 Element 实例，即一个元素结点。props 可以包含 attr 对象和 style 对象。比如 createBody(&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}})。 createComment(text: string): Comment 创建一个 Comment 的实例，即一个注释结点，并设置一段文本描述。 createBody(tagName: string, props: Object?): Element 创建文档主体结点，并自动挂载到 documentElement 下。 fireEvent(el: Element, type: string, e: Object?, domChanges: Object?) 触发一个特定类型的事件，并附带一个事件对象 e。当该事件在产生过程中修改了 DOM 的特性或样式，则第四个参数用来描述这些改变，参数格式和上面 createElement 方法的格式相同。 destroy() 销毁当前文档。一旦销毁之后文档将不会再工作。 只读成员变量id: string 每个 Document 实例都有一个唯一的 id。这同时也是每个 Weex 页面唯一拥有的 id。 URL: string? 如果当前 Weex 页面有 JS bundle URL 的话，这里则会返回 这个 URL。 body: Element 文档的主体结点，概念类似 HTML DOM 里的 document.body。 documentElement: Element 文档的对应结点，概念类似 HTML DOM 里的 document.documentElement。 body 和 documentElement 的关系是：documentElement 是 body 的父结点。 getRef(id): Node 根据结点 id 获取结点。 Node 类构造函数new Node() 成员destroy() 只读成员变量或方法ref: string 每个 Node 实例都有各自的在整个 Document 实例中唯一的 ref 值。 nextSibling: Node? previousSibling: Node? parentNode: Node? 上述三个接口和 HTML DOM 的定义吻合。 children: Node[] 该结点拥有的所有子结点的数组。 pureChildren: Node[] 该结点拥有的所有子元素的数组。和 children 的区别是，pureChildren 只包含了 Element 实例而不包含 Comment 实例。 Element 类 继承自 Node构造函数new Element(type: string, props: Object?) 创建一个特定类型 type 的元素结点，参数 props 可以包含 attr 对象或 style 对象。 DOM 树操作appendChild(node: Node) insertBefore(node: Node, before: Node?) 上述两个接口类似 HTML DOM。 insertAfter(node: Node, after: Node?) 在一个子结点之前插入新结点 after。 removeChild(node: Node, preserved: boolean?) 删除子结点 node，参数 preserved 表示立刻从内存中删除还是暂时保留。 clear() 清除所有的子结点。 DOM 属性本身操作setAttr(key: string, value: string, silent: boolean?) setStyle(key: string, value: string, silent: boolean?) 上述两个接口中，当 silent 为真的时候，结点仅更新自己，不会传递命令给客户端渲染层。该参数用来处理用户事件在发生时已经改变结点相关属性的情况下，不会在 Native DOM 也改变之后重复发送命令给客户端。 addEvent(type: string, handler: Function) removeEvent(type: string) fireEvent(type: string, e: any) 绑定事件、解绑定事件、触发事件。 特定组件类型的组件方法特殊的：不同组件类型可以拥有自己特有的方法，比如 &lt;web&gt; 组件支持 refresh 方法，详见各组件的描述，在此情况下，我们会产生特定组件类型的 class，比如 WebElement，它继承自 Element。 如： WebElement 继承自 Element表示在 Weex 页面中嵌入一个 webview refresh(): 刷新当前 webview 只读成员变量或方法ref, nextSibling, previousSibling, parentNode 继承自 Node。 nodeType: number 永远是数字 1。 type: string 和构造函数里的 type 一致。 attr: Object 当前结点的所有特性的键值对。推荐通过 setAttr() 方法进行修改，而不要直接修改这里的对象。 style: Object 当前结点的所有样式的键值对。推荐通过 setStyle() 方法进行修改，而不要直接修改这里的对象。 event: Object 当前结点的所有事件绑定。每个事件类型对应一个事件句柄方法。推荐通过 addEvent() / removeEvent() 方法进行修改，而不要直接修改这里的对象。 toJSON(): Object 返回描述该元素结点的一段 JSON 对象，形如：{ref: string, type: string, attr: Object, style: Object, event: Array(string), children: Array}。 Comment 类 继承自 Node构造函数new Comment(value: string) 只读成员变量或方法ref, nextSibling, previousSibling, parentNode 继承自 Node。 nodeType: number 永远是数字 8。 type: string 永远是字符串 &#39;comment&#39; value: string 和构造函数里的 value 一致。 toJSON(): Object 返回描述该注释结点的一段 JSON 对象，形如：&lt;!-- value --&gt;。","type":"references"},{"title":"Path (英)","path":"cn/references/path.html","permalink":"https://weex.apache.org/cn/references/path.html","text":"Pathv0.9+ 本文将介绍 Weex 中 uri(url) 的用法。包括使用图像、字体等资源，处理相对路径以及如何访问本地及打包的资源文件。 Schemes 本地资源 Weex SDK 提供 local scheme 来访问打包在应用程序中的资源，此 scheme 无法在 H5 环境下使用。目前，开发者可以在 image 组件和字体文件中使用本地资源。 在 iOS 中，Weex 会在 bundle resources 中查找。例如，image 组件的 src 属性为 local:///app_icon&#39;， Weex 会加载 bundle resouce 中名为 app_icon 的图像资源，而字体文件也以相同的方式工作。 在 Android 中，image 组件将从 drawable 资源文件夹加载，如 res/drawable-xxx。但加载字体文件是不同的，Android 框架无法从 res 加载字体文件，因此 SDK 将从 asserts 文件夹加载它。 HTTP/HTTPS 它的工作方式与 web 相同，Weex 一直支持这种方式。 File 使用 file scheme 访问本地磁盘文件。这个方案有其局限性：你不应该在源页面中硬编码文件 url。因为不管它是否在不同的平台（iOS，Android）上运行，内容将在另一个设备上完全不同，这取决于具体的设备。 所以一种可行的方案是在运行时动态获取文件 url，你可以使用它来显示本地磁盘的图像，或者稍后上传它。 相对路径与我们在 HTML 中的用法类似，Weex 以相同的方式处理相对路径。以/、.、..、// 开头的相对 URI 将相对于 bunle url 解析。 这意味着， 一个以 / 开头的路径将是相对于 JS Bundle 文件的根文件夹。. 则是当前文件夹，.. 是父文件夹。 // 则被解析为与 JS Bundle 相同的 scheme。 URI Adapter以上所有是默认实现，开发者可以通过提供一个 URI Adapter 来扩展或覆盖默认实现。与其他 Adapter 相同，应在 Weex SDK 初始化之前设置自定义 Adapter。","type":"references"},{"title":"Weex 和 Web 平台的差异","path":"cn/references/platform-difference.html","permalink":"https://weex.apache.org/cn/references/platform-difference.html","text":"Weex 和 Web 平台的差异Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOMDOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作既然原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 并不支持 Web 中所有的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOMBOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端没有并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象 history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。","type":"references"},{"title":"文本样式","path":"cn/references/text-style.html","permalink":"https://weex.apache.org/cn/references/text-style.html","text":"文本样式v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性 color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}v0.9+：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考 颜色关键字列表。","type":"references"},{"title":"CSS 单位","path":"cn/references/unit.html","permalink":"https://weex.apache.org/cn/references/unit.html","text":"CSS 单位CSS color 单位支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持)表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"references"},{"title":"Web 标准","path":"cn/references/web-standards.html","permalink":"https://weex.apache.org/cn/references/web-standards.html","text":"Weex 中的 Web 标准HTMLrefs: https://www.advancedwebranking.com/html/ 2016-12-11 Overview percentage name supported 98.1% &lt;head&gt; - 97.9% &lt;body&gt; - 97.9% &lt;html&gt; - 97% &lt;title&gt; - 93.9% &lt;meta&gt; - 89.9% &lt;div&gt; ✓ 89.6% &lt;a&gt; ✓ 88.5% &lt;script&gt; ✓ 86.5% &lt;link&gt; - 86.3% &lt;img&gt; ✓ 81.5% &lt;p&gt; - (can be customized) 75.6% &lt;span&gt; - (can be customized) 73.8% &lt;li&gt; - (can be customized) 73.7% &lt;ul&gt; - (can be customized) 70.3% &lt;br&gt; ✕ 60.4% &lt;style&gt; ✓ 55.8% &lt;h1&gt; - (can be customized) 52.7% &lt;h2&gt; - (can be customized) 48.4% &lt;input&gt; ✓ 46.9% &lt;form&gt; ✕ 44.3% &lt;strong&gt; - (can be customized) 43.1% &lt;h3&gt; - (can be customized) 30.9% &lt;table&gt; ✕ 30.3% &lt;tr&gt; ✕ 30.2% &lt;td&gt; ✕ Forms percentage name supported 49.5% &lt;option&gt; ✕ 30.2% &lt;input&gt; ✓ 16.6% &gt; [type=&quot;hidden&quot;] - 8% &gt; [type=&quot;text&quot;] ✓ 4.2% &gt; [type=&quot;submit&quot;] - 2% &gt; [type=&quot;checkbox&quot;] - (&lt;switch&gt;) 1.2% &gt; [type=&quot;email&quot;] ✓ 1.1% &gt; [type=&quot;radio&quot;] ✕ 0.9% &gt; [type=&quot;image&quot;] - 0.8% &gt; [type=&quot;button&quot;] - 0.6% &gt; [type=&quot;search&quot;] ✕ 0.6% &gt; [type=&quot;password&quot;] ✓ 0.1% &gt; [type=&quot;tel&quot;] ✓ 0.1% &gt; [type=&quot;number&quot;] ✓ 0% &gt; [type=&quot;reset&quot;] - 0% &gt; [type=&quot;file&quot;] ✕ 0% &gt; [type=&quot;date&quot;] ✓ 0% &gt; [type=&quot;url&quot;] ✓ 0% &gt; [type=&quot;range&quot;] ✕ 0% &gt; [type=&quot;color&quot;] ✕ 0% &gt; [type=&quot;time&quot;] ✓ 0% &gt; [type=&quot;datetime-local&quot;] ✕ 7.2% &lt;label&gt; - 6.1% &lt;form&gt; - 3.7% &lt;button&gt; - (can be customized) 2.6% &gt; [type=&quot;button&quot;] - 1.3% &gt; [type=&quot;submit&quot;] - 0% &gt; [type=&quot;reset&quot;] - 1.9% &lt;select&gt; ✕ 0.7% &lt;textarea&gt; ✓ 0.5% &lt;fieldset&gt; - 0.1% &lt;optgroup&gt; ✕ 0.1% &lt;legend&gt; - 0% &lt;progress&gt; ✕ 0% &lt;datalist&gt; - 0% &lt;output&gt; - 0% &lt;meter&gt; - CSS Propertiesrefs: https://www.chromestatus.com/metrics/feature/popularity 2016-12-11 percentage name supported 90.5115% display ✕ flex only 89.8243% margin ✓ (not support combo) 88.7012% width ✓ 88.6468% overflow ✓ iOS only, hidden only for Android 88.6432% background-color ✓ 88.0803% height ✓ 87.7648% font-size ✓ 87.3837% padding ✓ 87.2721% color ✓ 86.9788% text-align ✓ 86.6841% position ✓ relative by default, static not supported 86.6039% font-family ✓ 86.5943% font-weight ✓ 85.0072% opacity ✓ 80.6911% max-width ✕ 79.4476% box-sizing ✕ border-box only 75.7623% max-height ✕ 74.9939% webkit-user-select ✕ 57.0292% align-items ✓ 56.8182% justify-content ✓ space-around not supported well in browser 50.5941% flex-direction ✓ 48.5052% border ✓ 47.5161% top ✓ 46.9136% background ✕ 46.1552% cursor ✕ 46.1443% margin-left ✓ 46.0956% left ✓ 46.0848% text-decoration ✓ 45.9575% float ✕ 45.8391% border-bottom ✓ 45.7639% padding-left ✓ 45.7128% margin-top ✓ 45.7013% line-height ✓ 45.5836% background-image ✕ 45.0837% z-index ✕ 45.0649% right ✓ 45.0516% margin-bottom ✓ 45.0459% white-space ✕ 44.8710% margin-right ✓ 44.8476% vertical-align ✕ 44.6306% padding-top ✓ 44.1466% border-radius ✓ 44.0136% border-top ✓ 43.9815% padding-bottom ✓ 43.9392% padding-right ✓ 43.8539% visibility ✕ 43.4306% background-position ✕ 43.4098% background-repeat ✕ 43.0391% clear ✕ 42.9100% bottom ✓ 42.2092% content ✕ 42.0690% box-shadow ✕ 41.9004% border-color ✓ 41.7341% outline ✕ 41.4297% border-right ✓ 41.2605% border-left ✓ 41.1127% min-height ✕ 41.0736% font-style ✓ 41.0523% min-width ✕ 40.4298% list-style ✕ 39.7341% font ✕ 38.8999% background-size ✕ 38.7811% border-width ✓ 38.7718% border-collapse ✕ 37.8110% border-style ✓ 37.4962% text-overflow ✓ must work with lines 37.3471% text-transform ✕ 37.2154% transition ✕ 36.5155% overflow-y ✕ 36.3025% transform ✕ 36.2488% text-indent ✕ 35.5075% text-shadow ✕ 34.7607% webkit-appearance ✕ 34.1925% list-style-type ✕ 34.0238% border-spacing ✕ 33.6664% word-wrap ✕ 31.9961% overflow-x ✕ 31.9922% zoom ✕ 31.2495% border-bottom-left-radius ✕ 31.1306% pointer-events ✕ 31.1229% border-top-left-radius ✕ 30.2131% border-bottom-color ✓ 29.9608% border-top-color ✓ 29.4297% border-bottom-right-radius ✕ 29.2668% border-top-right-radius ✕ 28.6489% letter-spacing ✕ 27.8327% animation ✕ 26.6738% border-right-width ✓ 26.0169% src ✕ 25.2661% clip ✕ 25.2512% webkit-font-smoothing ✕ 25.1971% border-bottom-width ✓ 25.0246% border-right-color ✓ 24.7790% direction ✕ 24.4094% webkit-tap-highlight-color ✕ 23.9751% border-left-color ✓ 23.9321% border-top-width ✓ 23.7902% fill ✕ 23.2617% border-left-width ✓ 22.7278% table-layout ✕ 21.5766% word-break ✕ 20.4319% background-clip ✕ 19.3198% transform-origin ✕ 18.9233% filter ✕ 17.7879% resize ✕ 16.2501% flex ✕ 15.1656% font-variant ✕ 14.9181% text-rendering ✕ 14.7125% webkit-filter ✕ 14.5263% transition-duration ✕ 14.3966% transition-property ✕ 14.2124% webkit-box-orient ✕ 13.5432% outline-offset ✕ 12.9300% transition-timing-function ✕ 12.2788% unicode-range ✕ 12.0880% word-spacing ✕ 11.9124% quotes ✕ 11.6800% border-bottom-style ✓ 11.4263% webkit-background-clip ✕ 11.0070% flex-grow ✕ 10.5925% backface-visibility ✕ 10.4417% animation-name ✕ 10.4302% stroke ✕ 10.4144% animation-duration ✕ 10.2804% touch-action ✕ 9.9663% list-style-position ✕ 9.8662% order ✕ 9.7770% outline-width ✕ 9.7504% transition-delay ✕ 9.4689% border-top-style ✓ 9.3474% webkit-box-pack ✕ 9.3078% webkit-box-align ✕ 9.2375% page-break-inside ✕ 9.1898% webkit-line-clamp ✕ 8.9350% list-style-image ✕ 8.8339% page-break-after ✕ 8.5735% speak ✕ 8.4754% unicode-bidi ✕ 8.4307% animation-timing-function ✕ 8.1464% webkit-box-flex ✕ 8.0048% orphans ✕ 7.9947% widows ✕ 7.6671% flex-wrap ✓ not supported well in browser 7.5756% animation-fill-mode ✕ 7.4163% animation-delay ✕ 7.3284% border-left-style ✓ 7.1586% outline-color ✕ 6.9102% flex-shrink ✕ 6.7754% perspective ✕ 6.7748% border-right-style ✓ 6.4619% outline-style ✕ 6.0382% animation-iteration-count ✕ 5.9838% background-origin ✕ 5.9714% fill-opacity ✕ 5.9357% will-change ✕ 5.3740% stroke-width ✕ 5.3172% transform-style ✕ 5.2608% overflow-wrap ✕ 5.1730% background-attachment ✕ 4.9039% counter-increment ✕ 4.5950% counter-reset ✕ 4.5031% align-self ✕ 4.4109% webkit-box-ordinal-group ✕ 4.4046% webkit-animation-direction ✕ 3.7598% background-position-x ✕ 3.6867% border-image ✕ 3.6601% background-position-y ✕ 3.5749% webkit-user-drag ✕ 3.3376% flex-basis ✕ 3.1840% align-content ✕ 3.1832% flex-flow ✕ 3.1774% image-rendering ✕ 3.0879% webkit-margin-start ✕ 2.9551% font-stretch ✕ 2.8934% empty-cells ✕ 2.7619% webkit-margin-after ✕ 2.7220% perspective-origin ✕ 2.6125% webkit-margin-end ✕ 2.6089% column-count ✕ 2.5880% webkit-text-fill-color ✕ 2.5466% webkit-box-direction ✕ 2.4618% font-feature-settings ✕ 2.3959% webkit-mask-image ✕ 2.3431% webkit-padding-end ✕ 2.2555% stroke-dasharray ✕ 2.1788% user-select ✕ 2.1679% object-fit ✕ 2.0643% column-gap ✕ 2.0459% text-size-adjust ✕ 2.0253% caption-side ✕ 1.9695% stroke-dashoffset ✕ 1.7923% stroke-linecap ✕ 1.7861% animation-direction ✕ 1.7559% webkit-font-feature-settings ✕ 1.7404% stroke-opacity ✕ 1.5926% stroke-miterlimit ✕ 1.5786% fill-rule ✕ 1.4859% webkit-user-modify ✕ 1.3439% webkit-border-image ✕ 1.3091% animation-play-state ✕ 1.2676% contain ✕ 1.2029% webkit-padding-start ✕ 1.1840% webkit-margin-before ✕ 1.1269% page-break-before ✕ 1.1222% webkit-margin-top-collapse ✕ 1.0418% columns ✕ 1.0354% webkit-mask-size ✕ 0.9650% border-image-slice ✕ 0.9425% stop-color ✕ 0.9408% webkit-mask-repeat ✕ 0.9125% webkit-box-lines ✕ 0.8804% webkit-column-break-inside ✕ 0.8752% size ✕ 0.8334% font-kerning ✕ 0.8034% stroke-linejoin ✕ 0.7869% tab-size ✕ 0.7689% break-inside ✕ 0.7589% webkit-text-stroke-width ✕ 0.7353% column-width ✕ 0.6924% webkit-mask-position ✕ 0.6869% border-image-width ✕ 0.6323% border-image-repeat ✕ 0.5994% border-image-outset ✕ 0.5885% all ✕ 0.5859% webkit-text-stroke-color ✕ 0.5435% webkit-print-color-adjust ✕ 0.5420% webkit-text-stroke ✕ 0.5195% writing-mode ✕ 0.4741% clip-rule ✕ 0.4685% webkit-clip-path ✕ 0.4578% text-anchor ✕ 0.4535% shape-rendering ✕ 0.4526% webkit-column-break-before ✕ 0.4494% clip-path ✕ 0.4452% webkit-mask ✕ 0.4393% mix-blend-mode ✕ 0.4166% text-align-last ✕ 0.4033% column-rule ✕ 0.3990% webkit-mask-box-image ✕ 0.3989% font-variant-ligatures ✕ 0.3881% column-fill ✕ 0.3865% webkit-line-break ✕ 0.3857% border-image-source ✕ 0.3528% stop-opacity ✕ 0.3075% webkit-perspective-origin-y ✕ 0.3054% webkit-perspective-origin-x ✕ 0.2994% webkit-writing-mode ✕ 0.2717% dominant-baseline ✕ 0.2634% column-rule-color ✕ 0.2586% webkit-box-decoration-break ✕ 0.2467% webkit-text-security ✕ 0.2374% webkit-background-origin ✕ 0.2146% font-variant-caps ✕ 0.2005% column-rule-style ✕ 0.1976% shape-outside ✕ 0.1971% webkit-padding-before ✕ 0.1896% break-after ✕ 0.1782% webkit-padding-after ✕ 0.1774% text-orientation ✕ 0.1747% webkit-text-orientation ✕ 0.1655% mask ✕ 0.1626% alignment-baseline ✕ 0.1572% page ✕ 0.1530% webkit-column-break-after ✕ 0.1521% webkit-box-reflect ✕ 0.1504% webkit-text-emphasis-color ✕ 0.1499% object-position ✕ 0.1470% break-before ✕ 0.1455% webkit-margin-collapse ✕ 0.1452% baseline-shift ✕ 0.1451% hyphens ✕ 0.1309% rx ✕ 0.1304% ry ✕ 0.1256% background-blend-mode ✕ 0.1136% font-variant-numeric ✕ 0.1135% background-repeat-x ✕ 0.1123% background-repeat-y ✕ 0.1086% webkit-text-emphasis ✕ 0.1058% webkit-rtl-ordering ✕ 0.1040% column-rule-width ✕ 0.1036% isolation ✕ 0.1002% webkit-highlight ✕ 0.0843% webkit-transform-origin-y ✕ 0.0786% webkit-transform-origin-x ✕ 0.0770% webkit-app-region ✕ 0.0685% column-span ✕ 0.0653% r ✕ 0.0611% y ✕ 0.0602% x ✕ 0.0555% webkit-border-vertical-spacing ✕ 0.0545% webkit-border-horizontal-spacing ✕ 0.0542% webkit-border-start-width ✕ 0.0450% webkit-border-start-color ✕ 0.0424% webkit-border-after-width ✕ 0.0424% webkit-border-before-width ✕ 0.0423% webkit-border-end-width ✕ 0.0351% marker ✕ 0.0349% webkit-border-end-color ✕ 0.0347% webkit-border-after-color ✕ 0.0347% webkit-border-before-color ✕ 0.0342% mask-type ✕ 0.0328% color-interpolation-filters ✕ 0.0325% webkit-border-end ✕ 0.0319% vector-effect ✕ 0.0307% color-rendering ✕ CSS Units and Valuesrefs: https://drafts.csswg.org/css-values/ 2016-12-11 Textual pre-defined keywords CSS-wide keywords initial inherit unset &lt;custom-ident&gt;: author-defined identifiers ✓ &lt;string&gt;: quoted strings (&quot;xxx&quot;) &lt;url&gt;: resourec locators (url()) Numeric &lt;integer&gt; ✓ &lt;number&gt; ✓ &lt;percentage&gt; Length &lt;length&gt; relative font-relative em ex ch ic rem ✓🔧 viewport-percentage vw ✓🔧 vh ✓🔧 vi vb vmin ✓🔧 vmax ✓🔧 absolute cm ✓🔧 mm ✓🔧 Q ✓🔧 in ✓🔧 pc ✓🔧 pt ✓🔧 px autofixed to number Quantities &lt;angle&gt; deg grad rad turn &lt;time&gt; s ms &lt;frequency&gt; Hz kHz &lt;resolution&gt; dpi dpcm dppx Elsewhere &lt;color&gt; ✓ &lt;image&gt; &lt;position&gt; Functional calc() toggle() attr() JS APIsrefs: https://www.w3.org/standards/techs/js 2016-12-11 Completed WorkStandards last update spec supported 2016-11-17 Media Source Extensions™ - (media related) 2016-11-08 Geolocation API Specification 2nd Edition ✕ developing 2016-10-27 Pointer Lock - 2016-10-18 Vibration API (Second Edition) ✕ 2016-04-19 Web Storage (Second Edition) ✓ async storage module 2015-10-22 Web Notifications ✕ 2015-05-19 HTML5 Web Messaging ✕ BroadcastChannel developing 2015-02-24 Pointer Events - 2015-02-10 Vibration API ✕ 2015-02-03 Server-Sent Events ✕ 2015-01-08 Indexed Database API ✕ 2014-03-13 Metadata API for Media Resources 1.0 - (media related) 2014-02-11 Progress Events ✕ 2014-01-16 JSON-LD 1.0 Processing Algorithms and API - 2013-12-12 Performance Timeline - (perf related) 2013-12-12 User Timing - (perf related) 2013-10-31 Widget Interface - 2013-10-29 Page Visibility (Second Edition) ✕ onviewappear/onviewdisappear 2013-10-10 Touch Events ✕ 2013-02-21 Selectors API Level 1 - 2012-12-17 Navigation Timing - (perf related) 2012-12-17 High Resolution Time - (perf related) 2008-12-22 Element Traversal Specification - DraftsProposed Recommendations last update spec supported 2016-09-15 WebIDL Level 1 - Candidate Recommendations last update spec supported 2016-12-08 Performance Timeline Level 2 - (perf related) 2016-11-22 Page Visibility Level 2 ✕ onviewappear/onviewdisappear 2016-11-01 High Resolution Time Level 2 - (perf related) 2016-08-18 DeviceOrientation Event Specification ✕ 2016-07-21 Resource Timing Level 1 - (perf related) 2016-07-14 Presentation API - 2016-07-07 Battery Status API ✕ 2016-07-05 Encrypted Media Extensions - 2016-05-19 Media Capture and Streams - (media related) 2014-12-11 Web Cryptography API - 2014-09-09 HTML Media Capture - (media related) 2012-09-20 The WebSocket API ✕ Last Call Drafts last update spec supported 2011-12-01 Geolocation API Specification Level 2 ✕ Other Working Drafts last update spec supported 2016-12-09 MediaStream Image Capture - (media related) 2016-12-06 MediaStream Recording - (media related) 2016-12-06 Selection API ✕ 2016-12-05 Input Events ✕ 2016-12-02 Gamepad - 2016-11-29 WebDriver - 2016-11-24 WebRTC 1.0: Real-time Communication Between Browsers ✕ 2016-11-22 Pointer Lock 2.0 - 2016-11-07 Remote Playback API - (media related) 2016-11-03 Resource Timing Level 2 - (perf related) 2016-11-02 Audio Output Devices API - (media related) 2016-11-01 Indexed Database API 2.0 ✕ 2016-11-01 User Timing Level 2 - (perf related) 2016-10-31 The Screen Orientation API ✕ 2016-10-31 High Resolution Time Level 3 - (perf related) 2016-10-24 UI Events KeyboardEvent code Values - 2016-10-24 UI Events KeyboardEvent key Values - 2016-10-11 Service Workers 1 ✕ 2016-09-21 Identifiers for WebRTC’s Statistics API - 2016-09-13 Accelerometer Sensor ✕ 2016-09-13 Gyroscope Sensor ✕ 2016-09-13 Magnetometer Sensor ✕ 2016-08-30 Ambient Light Sensor ✕ 2016-08-30 Media Capture from DOM Elements - (media related) 2016-08-30 Generic Sensor API ✕ 2016-08-03 Wake Lock API ✕ 2016-07-19 Proximity Sensor ✕ 2016-07-19 Pointer Events - Level 2 - 2016-07-14 Screen Capture ✕ 2016-07-12 Media Capture Depth Stream Extensions - (media related) 2016-05-17 Cooperative Scheduling of Background Tasks ✕ 2016-04-22 Navigation Timing Level 2 - (perf related) 2016-04-03 Clipboard API and events ✕ clipboard module 2015-12-15 Push API ✕ 2015-12-08 Web Audio API - (media related) 2015-10-15 FindText API - 2015-09-24 Web Workers ✕ 2015-04-21 File API ✕ 2014-02-20 Network Service Discovery ✕ 2012-03-06 MediaStream Capture Scenarios - (media related) 2011-12-15 Audio Processing API - (media related)","type":"references"},{"title":"Weex 实例变量","path":"cn/references/weex-variable.html","permalink":"https://weex.apache.org/cn/references/weex-variable.html","text":"Weex 实例变量每个 Weex 页面的 JS 上下文中都有一个相互独立的 weex 变量，用来持有当前 Weex 页面相关的单例内容或方法。 weex.config该变量包含了当前 Weex 页面的所有环境信息，包括不仅限于： bundleUrl: string: JS bundle 的 URL。 env: Object: 环境对象。 weexVersion: string: Weex sdk 版本。 appName: string: 应用名字。 appVersion: string: 应用版本。 platform: string: 平台信息，是 ‘iOS’、’android’ 还是 ‘Web’。 osVersion: string: 系统版本。 deviceModel: string: 设备型号 (仅原生应用)。 deviceWidth: number: 设备宽度。Weex 默认以宽度为 750px 做适配渲染，要获得750px下的屏幕高度，可以通过 height = 750/deviceWidth*deviceHeight 公式获得，可以使用到 CSS 中，用来设置全屏尺寸 deviceHeight: number: 设备高度。 weex.requireModule(module: string): Object获取某个 native module 的所有方法，比如： &lt;template&gt; &lt;div&gt;&lt;text&gt;Hello World&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.document: Document返回当前 Weex 页面的文档对象。","type":"references"},{"title":"Mobile App Architecture","path":"guide/intro/app-architecture.html","permalink":"https://weex.apache.org/guide/intro/app-architecture.html","text":"Mobile App ArchitectureToday’s Mobile AppLet’s talk about what we think a mobile app should be. Mobile App Needs Parallel DevelopmentNowadays, all mobile app teams requires the ability to develop in parallel. When a mobile app keeps growing, supporting large-scale parallel development must become a very important key thing. Otherwise it’s really easy to become a bottleneck. Mobile App Needs to be DynamicToday the development of mobile apps is very heavy. And it’s really slow in iteration, release, distribution and online bugfix. The size of the package of an app is growing fast too. All of this is not suitable for this mobile internet age. Mobile app needs to be dynaimic which is out of the cumbersome process of version deployment and distribution. Mobile App Needs Open InterconnectionToday in your phone, things are hard to connect and share between different apps. They needs some container with common standard and specs to be shared with each other. Our Thinking of Mobile AppWe think a dynamic, parallel development supported, standardized mobile app should be like this: |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| Pages: A whole mobile app should be divided into several mobile pages. Each mobile page has its own “URL”. Router: All the mobile pages above will be connected with router. And navigators or tab bars are just doing this job. Features: All kinds of APIs or services provided from the device. Every mobile page could use these features as they like. So before you build your mobile app, make sure how many mobile pages your mobile app has and what are they. How do they connect each other. Give each mobile page a URL. And sort out all the APIs and services your mobile app needs. Then create the pages and develop, debug and deploy them using Weex. Links Mobile page architecture If you have built a complete mobile app already and just want to using Weex to rebuild part of these pages, that’s absolutely no problem. Because Weex is just a SDK to build mobile pages which can coexist very well with other native views or hybrid pages. If the feature of WeexSDK is limited to your mobile app. You can extend your own components and modules. It requires some native development knowledge. But with our efforts on delivering more and more features, we believe this part of job will be getting smaller and smaller. Links Extend to iOS Extend to Android","type":"guide"},{"title":"iOS APIs","path":"cn/references/ios-apis.html","permalink":"https://weex.apache.org/cn/references/ios-apis.html","text":"iOS APIsNative 对外接口 注册 SDK 默认的 Module、Handler 和 Component 注册自定义 module、Handler 和 Component 重置 JSFramework Handler (对应于 Android 的 Adapter) 介绍 WXImgLoaderDefaultImpl 图片下载 handler。Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。WeexSDK kernel 本身没有提供图片下载的默认实现。 接口定义如下： @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native 和 JS 通信 自定义通知事件 用于 native 自定义部分和 js 进行实践通知，比如传递下拉事件到 js，这个是在 component 基类的方法，可以直接使用 /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName 事件名称，可以在weex文件某个标签组件监听，命名规范为 onXXX * @param params 数据 * @param domChanges 发生改变的数据 **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges 事件回调 多用于 Module 回调结果给 js，回调类型分为下面两种： WXModuleCallback 为了性能考虑，该回调只能回调通知js一次，之后会被释放，多用于一次结果 WXModuleKeepAliveCallback 该回调可以设置是否为多次回调类型，多次回调的场景如持续监听位置的变化，并返回给 js。 @implementation WXEchoModule@synthesize weexInstance; // 让该module 获得当前instanceWX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);// 此处设置true，该回调function 可以多次回调执行，可以写循环测试.&#125; 动态适配容器WeexSDK 在 WXSDKInstance 类中提供了方法 setFrame(CGRect) 来改变容器的大小。 如：在导航栏从有到无过程，需要 weexView 的变化， 可以在此时 native 调用该方法设置 降级使用Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 WXSDKInstance 中的 onFailed 回调进行处理，如果是主动降级则返回的错误 domain 为 TemplateErrorType，Native 端可以跳转到对应的 H5 页面，或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"JS Framework APIs","path":"cn/references/jsfm-apis.html","permalink":"https://weex.apache.org/cn/references/jsfm-apis.html","text":"JS Framework APIsBroadcastChannel v0.9+BroadcastChannel API 是 Weex 实例间通信的解决方案。 参考 BroadcastChannel specification. MessageEvent specification API postMessage(message): 通过消息通道发送特定消息给其他 BroadcastChannel 对象。 close: 关闭 BroadcastChannel 对象，以便垃圾回收。 onmessage: Event 处理函数, 当 BroadcastChannel 对象接收到消息时触发。 使用const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // in this case, it's \"Hulk Smash !!!\"&#125;// in another instanceconst Hulk = new BroadcastChannel('Avengers')Hulk.postMessage(\"Hulk Smash !!!\") 运行以上代码，Stack 可以从 Hulk 接收消息。 注意需要注意的是: message 如果是一个对象，该对象不会深拷贝。 参考以下例子 const a = new BroadcastChannel('app')const b = new BroadcastChannel('app')const message = &#123; lists: ['A', 'B']&#125;a.onmessage = function (event) &#123; // in this case, event.data is a reference of message console.assert(event.data === message)&#125;b.postMessage(message) 在这个例子中，event.data 全等于 message。 与深拷贝相比，这种方式能够提高效率并减少内存消耗。但是，不建议开发者在使用时缓存或修改事件对象 (所有类型的事件处理程序都应该有此限制)。","type":"references"},{"title":"How it works","path":"guide/intro/how-it-works.html","permalink":"https://weex.apache.org/guide/intro/how-it-works.html","text":"How it worksOverall StructureWeex is a client-side technology on the surface, but in fact it connects the whole way from the local development environment to the cloud deployment and distribution. Developers can first write an app page just like writing a web page, and then compile the app page into a piece of JavaScript which is called Weex JS bundle. In the cloud, developers can deploy the generated JS bundle. And then it can be requested or pre-fetched from a mobile app with WeexSDK. The WeexSDK would prepare a JavaScript engine to run corresponding JS bundle when user opens a Weex page anytime. Usually the JS bundle will make some calls to native-side through Weex JS bridge. They let native-side render the user interface or handle user interactions, storage data, make network communications, call device powers and so on. Even if a user does not install the App, he can still open a same web page in the browser, using the same source code. Local Development EnvironmentThe design of local development environment of Weex is based on the web development experience. It help web developers writing mobile app UI with their familiar HTML / CSS / JavaScript. At the same time Weex also do the official support to Vue.js, a very great front-end framework. In addition, the management of a Weex project is also very familiar with a web project. First, web developers can use npm packages to manage dependencies. Second, web developers can refer to all best practices from every process of a web project such as scaffolding, development, preview, debugging, test etc. Also same as the best practice of web development, each Weex page will be built into a JS bundle. In the browser, we put JS bundle into the web page as a &lt;script&gt; tag. In the client, we put JS bundle into the local, and execute it in WeexSDK. Links Platform differences between Weex and web Differences of using Vue between Weex with web Get Started Using Devtools Cloud Deployment &amp; DistributionWeex JS bundle can be deployed and distributed as a static resource. Almost all current web development system and best practice can be applied to Weex directly such as generating JS bundle through CMS system or deploying JS bundle to static CDN, monitoring JS bundle traffic through server log, caching or pre-fetching JS bundle to reduce networking cost etc. Client-side JavaScript EngineBoth iOS and Android client-side of Weex run a JavaScript engine to execute JS bundles and send well defined instructions to the native render layers. We choose JavaScriptCore in iOS and v8 in Android which provide strong performance and stability. In order to make the mobile resources better utilized, we just run only one instance of JavaScript for all Weex pages. That is, all JS bundles share the same JavaScript instance, but each JS bundle context also isolated well by default in the runtime. We also put Vue 2.0 as a built-in JS Framework, developers do not have to pack it in each JS bundle, which save the size and time of networking. Client Rendering LayerWeex offers both iOS and Android native rendering layers. Each of them are based on the Native DOM model and exposed to JavaScript APIs. At the same time we provide a set of native components and modules to use. Also Weex has high performance especially on first-screen loading time, memory cost and re-reuse of long list, etc. Although Weex has provided a group of most commonly used components and modules officially. But we definitely know they couldn’t satisfy everyone. So we design our native render as extendable as possible. You can extend more components and modules on your own. We can build and share an Weex eco-system together. Links Differences between Weex and web standard Using Weex in iOS Using Weex in Android Extend to iOS Extend to Android In the BrowserBesides iOS and Android client, Weex also has a web version based on Vue 2.0. Developers can just use Vue 2.0 to build the same page in browsers. Links Using Weex in HTML5 Extend to HTML5","type":"guide"},{"title":"Web Dev Experience","path":"guide/intro/web-dev-experience.html","permalink":"https://weex.apache.org/guide/intro/web-dev-experience.html","text":"Web Dev ExperienceWhat is Web Dev Experience?Weex dev experience is very close to web dev experience. It describes the UI structure and content with HTML or HTML-based template, describes the UI style with CSS, and describes user behavior and business logic with JavaScript. And it has completed project mechanism. Why We Choose Web Dev Experience? There are a huge number of web developers in the community today. Weex can give more web developers abilities to build high-performance and great-experienced mobile apps. Web development itself has very high efficiency and flexibility. And Weex is committed to solve the dynamic requirement of mobile apps. They just match each other. Web standards and web dev experience is built by a lot of outstanding technology companies together. It has very high quality assurance. Standard itself is a force. Base on standards, respect for standards, close to the standard means that there are more possibilities. The eco-system and community of web today are very prosperous. There are many mature tools, libraries, systems, best practices to be used. How Does Weex Support Web Standard?We have the following aspects to sort out: HTML tags: Weex currently supports basic container (div), text, image, video and other components. And almost all of HTML block-level tags can be simulated through the custom container components. Inline-level tags can be simulated through the custom text components. And Weex also supports some form components such as input / textarea. CSS: Weex supports some commonly used CSS properties, values and units. We will continue to support more based on user feedback and the usage frequency in web. JavaScript: Weex currently offers a simplified version of the DOM APIs for operating the native UI. And Weex will continue to support more W3C Device APIs. About frameworks, Weex officially build Vue 2.0 in. and support its related libs such as vuex, vue-router, etc. At the same time developers can directly use all kinds of third-party JavaScript libs. About engineering, we recommend using npm to pack and manage deps. And we recommend webpack for the JS bundle package. Also we provide weex-devtool, which make developers debug native app just like in Chrome devtools. Weex also is friendly to current mainstream web page publishing system, caching mechanism and other best practices. Links Differences between Weex and web standard Using Vue.js Using Devtools","type":"guide"},{"title":"Weex Page Architecture","path":"guide/intro/page-architecture.html","permalink":"https://weex.apache.org/guide/intro/page-architecture.html","text":"Weex Page ArchitectureA Weex page is a independent mobile page which includes UI, interaction logic, device power, lifecycle management etc. UINative DOM ModelWeex page has its HTML-like DOM model to manage UI. It will be decomposed into a DOM tree which consists of some DOM nodes. Links Weex Native DOM APIs ComponentsWeex supports many kinds of components. Some of them are content components such as text, image and videos. Some of them are container components such as div, list, scroller. Also there are some special components like slider, input, textarea, and switch. Links All components Weex supports Layout SystemWeex use some CSS properties to layout every nodes in the DOM tree together. It includes: Box model: Describe the width, height, padding, margin and border of a component node. Flexbox: Describe the relations between different nodes with CSS Flexbox Spec. Supportting absolute, relative, fixed and sticky value of CSS position property. FeaturesWeex supports lots of device features through modules such as storage, navigation, modals etc. Each of them exposes some JS APIs. Links All modules Weex supports LifecycleEvery Weex page has its lifecycle which is defined and implemented in WeexSDK. All Weex pages will go through the whole process, from being created and last to being destroyed.","type":"guide"},{"title":"use weex-toolkit","path":"guide/tools/toolkit.html","permalink":"https://weex.apache.org/guide/tools/toolkit.html","text":"weex-toolkitweex-toolkit is an official command line tool to help developers to create, debug and build their Weex project. Installuse npm to install weex-toolkit: $ npm install -g weex-toolkit if you make it, you can input “weex” in your command line terminal to test it. The right output: if you have never installed node.js, you should go node.js.org to download and install it. node engine version &gt;= 6. You can try n to manage your node versions*If you meet some errors when installing like permission error, please go weex-toolkit issues to find some solution or have a discuss with us. initialize Weex project$ weex init awesome-project After command running, you can find awesome-project directory and there are some Weex templates in it.There are some useful npm scripts you will use in the future: build: build the source code and generate the JS bundle dev: run webpack watch configuration serve: start a web server debug: open the debug mode When all dependences are ready, you can input npm run dev and run npm run server in a command line tab. Now you can visit our web page in : http://localhost:8080/index.html preview Weex page in timeweex-toolkit supports previewing your Weex file(.we or .vue) in a watch mode. You only need specify your file path. $ weex src/foo.vue The browser will auto open the location and you could see the layout and effects of your Weex page. If you have a Playground app in your mobile devices, you can scan the QR code at the opened page.Try the command below, you’ll preview the whole directory files. $ weex src --entry src/foo.vue You need to specify the directory path and the entry file(--entry). build Weex projectUse weex compile to build your single weex file or the whole project.weex compile src/foo.vue dist There are two arguments. One is your code source path (a single file or a directory) and another is your destination path you want to build debugweex-toolkit has the ability to extend third party script. And Weex devtools is a custom devtools for Weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page, both android and iOS platform are supported. So you can use weex-devtools feature by weex-toolkit. usageweex debug [options] [we_file|bundles_dir] Options: -h, --help output usage information -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer|loader] -w, --watch watch we file changes auto build them and refresh debugger page![default enabled] start debugger$ weex debug this command will start debug server and launch a chrome opening DeviceList page.this page will display a qrcode ,you can use Playground App scan it for starting debug. debug .we | .vue file$ weex debug your_weex.vue this command will compile your_weex.we to your_weex.js and start the debug server as upon command.your_weex.js will deploy on the server and displayed in DeviceList page as another qrcode contain the url of your_weex.js. . start debugger with a directory of we files$weex debug your/we/path -e index.we this command will build every file in your/we/pathand deploy them on the bundle server. your directory will mapping to http://localhost:port/weex/use -e to set the entry of these bundles. and the url of index.we will display on device list page as another qrcode. FeaturesConnect devices Inspector Inspector can be used to show your Element \\ Network \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. Element NetWorkshow the total time and latency show the header and response Console Resource Debugger Breakpoint and CallStack Integrate devtools Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. IOS See the doc Weex devtools (IOS), it will lead you to config and use it step by step. weex-toolkit extends weexpack commandweexpack helps to setup Weex application from scratch quickly. With simple commands, developers could create a Weex project, add different platform template, could install plugins from local, GitHub or Weex market, could pack up his application project and run on mobile. For those who would like to share his own plugins, he could publish them to the Weex market. Now weex-toolkit can run the same commands of weexpack because of the new architecture. If your directory is generated by weexpack, you can build your iOS or android app. weex platform and run commandsUse platform add|remove to add or remove Weex app template and run it in your target devices. $ weex platform add ios If you use these commands firstly, you might see the prompt. Just enter Y. Then run platform, you will see an iPhone simulator. $ weex run ios weex plugin commandsIf you want to use some plugins on the weex market, weex-toolkit is the right choice. $ weex plugin add plugin_name You need to specify the plugin name from market like “weex-chart”: $ weex plugin add weex-chart Remove some plugins(eg: weex-chart): $ weex plugin remove weex-chart Learn more about weexpack .","type":"guide"},{"title":"Extend JS framework","path":"references/advanced/extend-jsfm.html","permalink":"https://weex.apache.org/references/advanced/extend-jsfm.html","text":"Extend JS frameworkThis part of the extension of JS framework is still in the discussion, may be adjusted at any time, please pay attention. Weex wants to be able to respect as many developer development habits as possible.So, in addition to Weex official support Vue 2.0, the developer can also customize and horizontally extension their own or their favorite JS Framework.The steps to customize the JS Framework are as follows: First you have a complete set of JS Framework. Learn about Weex’s JS engine feature support. Adapting Weex’s native DOM APIs. Adapting Weex’s initialization portal and multi-instance management mechanism. Add your own JS Framework to the framework configuration of the Weex JS runtime. Then pack it. Build JS bundles based on the JS Framework. You need to add a specific prefix comment so that the Weex JS runtime can recognize it. Weex JS engine features support Under iOS, Weex uses the JavaScriptCore that comes with the system, so the ES support depends on the version of the operating system.The current conservative judgments, ES5 features on the market mainstream iOS devices are perfectly supported, but some of the features of ES6 + is not supported. Under Android, Weex uses the v8 kernel provided by UC. For performance and stability considerations, we are not using the latest version of the v8 kernel.The same conservative judgment, the ES5 feature can all support, including strict mode Object.freeze and so on. The Weex JS engine does not support HTML DOM APIs and HTML5 JS APIs, including document, setTimeout`, and so on. We added Promise‘s polyfill, as well as the console‘s polyfill. In addition, in order to ensure that the JS engine can manage memory as much as possible, we have a generic global object for the Object.freeze () freeze operation, which includes: Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype Adapt to Weex’s initial entry and multi-instance management mechanismThe JS Framework provided by the developer needs to be packaged as a CommonJS package, and the package needs to be extension to the following methods: Framework initialization init(config) config Document Element Comment TaskSender CallbackManager This method places the Native DOM class and two auxiliary classes provided by Weex in the config parameter and allows the framework itself to be initialized. Tip: At the same time, the author can pass in a different config in the framework of the initialization time. This allows for framework testing or environmental simulation. Introduction to parameter format TaskSender: wip… CallbackManager: wip… Register available native components and modules registerComponents(components) registerModules(modules) These two methods are called immediately after the frame is initialized. This framework will be able to know which components and modules the current client supports. Introduction to parameter format components: Array: Describe the array of components, each of which includes: type: string: Component name, for example div。 methods: string[]: Optional, a list of method names supported by this component. These methods can follow the native DOM APIs call. modules: Object: Describe the hash table of a series of modules. Key is the module name, the value is an array. The elements of the array describe a method in the module. The information of the method includes: name: string: Method name args: string[]: Parameter number and type description E.g: registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) Multi - instance lifecycle management createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) Each Weex page has two stages: created and destroyed. At the same time in the Weex page running process, native can send messages to the Weex page. Different frameworks can follow their own ideas to achieve the message. Introduction to parameter format instanceId: string: The unique id of the Weex page is generated by native. code: string:The Wex page’s JS bundle’s code is passed through native. config: Object?: The configuration information for the Wex page, such as the bundleUrl representing the bundle address, is generated by the native configuration. It has nothing to do with the contents of the JS bundle itself. data: Object?: Native can import an external data when creating a Weex page. The JS framework can also generate different page content for the same JS bundle with different data. env: Object?:The current environment information about the Weex page, the meaning of each field: info: Object: Framework information, see the “JS Bundle format requirements” later. config: Object:Equivalent to the third parameter of the method config callbacks: CallbackManager: only CallbackManagerinstance of Weex page. created: number:The number of seconds that the Wex page was created. framework: string:The name of the framework used by the Wex page. Equivalent to info.framework. Native communication receiveTasks(instanceId, tasks) Native can use the refreshInstance method to send a message to the JS framework layer. But in many cases will use receiveTasks to send user events or methods callback to the JS framework. For example, if the user clicks on a button, native will send a fireEvent type of task to the JS framework, and then the JS framework will handle the corresponding event logic. This part of the working mechanism is related to the design of the addEvent in the native DOM interface. Another example is the user using fetch to send network requests. When the request is done at the native end, it will be sent to the JS framework with a callback type of task. Since native can not pass the function in JavaScript, it actually only sends a callbackId to the JS framework. This part of the working mechanism is related to the design of CallbackManager. Auxiliary method getRoot(instanceId): JSON This method returns the full JSON description of the document body node. Developers can view the full native DOM tree as a result. The format of the specific return value is the same as the return method of the toJSON () method in the native DOM interface. This feature is used extensively as a developer tool extension. Configure the JS Framework in WeexSDKPrepare your JS Framework code// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; Register a JS Frameworkimport * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; And then packaged JS runtime, integrated into WeexSDK. JS Bundle format requirementsFramework infoThe note(alias framework info) at the beginning of the JS Bundle file is very important. The format is as follows: // &#123; \"framework\": \"Vue\" &#125; So that the Weex JS engine will know that the JS bundle needs to use the Vue framework to resolve.Similarly, Weex supports multiple frameworks.It will be based on js bundle notes to select the corresponding framework resolution.","type":"references"},{"title":"Extend to Android","path":"references/advanced/extend-to-android.html","permalink":"https://weex.apache.org/references/advanced/extend-to-android.html","text":"Extend to AndroidModule extendweex sdk support Module extend, Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module Follow the steps below. Step to customize a module Customize module must extend WXModule @WXModuleAnno annotation must be added, as it is the only the way to recognized by Weex The access levels of mehtod must be public The module class also can not be an inner class Customize can not be obfuscated by tools like ProGuard Module methods will be invoked in UI thread, do not put time consuming operation there Weex params can be int, double, float, String, Map, List Refer to the following example: public class WXEventModule extends WXModule&#123; private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\"; @WXModuleAnno public void openURL(String url)&#123; //implement your module logic here &#125;&#125; Support synchronous/asynchronous callbackYou can add @JSMethod (uiThread = false or true) annotation to choose the callback mode of moudle. See the follow example. // as sync-callback mode@JSMethod (uiThread = false)public void testSyncCall()&#123; WXLogUtils.d(\"WXComponentSyncTest : Thread.currentThread().getName());&#125;// as async-callback mode@JSMethod (uiThread = true)public void testAsyncCall()&#123; WXLogUtils.e(\"WXComponentASynTest : Thread.currentThread().getName() );&#125; Register the mouldeWXSDKEngine.registerModule(\"event\", WXEventModule.class); Use this module in weex DSLNow event moudle is avaiable in weex, use the module like this: var event = weex.requireModule('event');event.openURL(\"http://www.github.com\"); Javascript callbackIf the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @WXModuleAnnopublic void openURL(String url,JSCallback callback)&#123; //implement your module logic here Map&lt;String,Object&gt; resp = new HashMap(); resp.put(\"result\",\"ok\"); callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extendThere are label, image, div, scroll, ect. components in weex, you can also customize your own components. Step to customize a component Customize components must extend WXComponent or WXContainer @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK. The access levels of mehtod must be public The component class can not be an inner class Customize can not be obfuscated by tools like ProGuard Component methods will be invoked in UI thread, do not put time consuming operation there. Weex params can be int, double, float, String, Map, List, Array Refer to the following example public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; super(instance, dom, parent, instanceId, isLazy); &#125; @Override protected void initView() &#123; mHost = new TextView(mContext); &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; Register the ComponentWXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); Adapter extendImagedownloadAdapterWeex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examples. public class ImageAdapter implements IWXImgLoaderAdapter &#123; private Activity mContext; public ImageAdapter(Activity activity) &#123; mContext = activity; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; mContext.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\"))&#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width&lt;=0 || view.getLayoutParams().height&lt;=0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .resize(view.getLayoutParams().width, view.getLayoutParams().height).into(view); &#125; &#125;); &#125;&#125; Component Method from WeexSDK 0.9.5, you can define your component method for example, define a method in component: @JSMethodpublic void focus()&#123; //method implementation&#125; after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt;``` #### Proguard RulesIf you want to using proguard to protect your source code, please add the following rules to your profile:```java-keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;","type":"references"},{"title":"Extend to HTML5","path":"references/advanced/extend-to-html5.html","permalink":"https://weex.apache.org/references/advanced/extend-to-html5.html","text":"Extend to HTML5Weex itself offers a lot of built-in components and modules, but also has the ability to expand horizontally. It allows developers to expand and customize themselves. But it is important to note that Weex is a cross-platform solution. When extending its built-in components or modules, you need to implement it on the three ends (Android, iOS, Web). After Weex switches the kernel to Vue 2.x, it will be easier to extend the Vue component on the Web side. Extend Web componentsVue.js is an independent front-end framework. In the browser, you can not use the Weex container for page rendering. So, the two things are the same: (1) for the Weex platform to expand Vue.js Web components. (2) directly using Vue.js to develop a Web component. The development of components can refer to its documentation: component. It is also recommended to use the file to write components. How to use it: [Single file component](https://vuejs.org/v2/guide/single-file-components.html). ### Example of component extensionTo extend ```&lt;sidebar&gt;``` as an example, you should first write the logic of the component itself: ```html&lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=&quot;sidebar&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; And then register the component globally before using it:```javascriptimport Vue from &apos;vue&apos;import Sidebar from &apos;./path/to/sidebar.vue&apos;// register the ```&lt;sidebar&gt;``` component globallyVue.component(&apos;sidebar&apos;, Sidebar) When you extend the Weex component, if you only use the built-in components provided by Weex and use the styles that Weex supports, it is no different from the normal custom component and does not need to be implemented at the Native side. If you find a component that does not support labels and styles that are not supported by Weex, you will need to really extend the Weex component. At the same time, you also need to extend in the Android side and the iOS side, or will lead to rendering exception. Extend the Web moduleIn addition to the common components, Weex also provides a common module, you can easily call the native API. In general, the registered Weex module requires three ends to be implemented, otherwise it will affect its normal use. Register the moduleIf we import the library, we can get the weex variable globally. You can register the module using the ```registerModule```method. #### API format + `registerModule`21.```name```: &#123;String&#125; Required, module name. 22.```define```: &#123;Object&#125; Required, module definition. 2#### The example of register module The following code registers a module called guide: ```javascriptweex.registerModule(&apos;guide&apos;, &#123; greeting () &#123; console.log(&apos;Hello, nice to meet you. I am your guide.&apos;) &#125;, farewell () &#123; console.log(&apos;Goodbye, I am always at your service.&apos;) &#125;&#125;) Use the moduleWeex provides the require method for getting registered modules. You only need to pass the module name directly: //import moduleconst guide = weex.requireModule('guide')// use the methods of moduleguide.greeting()guide.farewell() The above wording is as useful as the native end, except that the methods in the module are provided by Native.","type":"references"},{"title":"Extend to iOS","path":"references/advanced/extend-to-ios.html","permalink":"https://weex.apache.org/references/advanced/extend-to-ios.html","text":"Extend to iOSNoticeAll of the exported APIs in Weex are controllable and safe, they can not access private APIs or do any system hacks at runtime, neither can they change the primary purpose of the Application. If you are extending your custom modules/components, be sure NOT to export the ability of Objective-C runtime, be sure NOT to export dynamic and uncontrolled methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), be sure NOT to export any private methods. Module extendWeex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module following the steps below. Step to customize a module Module customized must implement WXModuleProtocol A macro named WX_EXPORT_METHOD must be added, as it is the only way to export methods to JavaScript. The weexInstance should be synthesized. Each module object is bind to a specific instance. Module methods will be invoked in UI thread, so do not put time consuming operation there. If you want to execute the whole module methods in other thread, please implement the method - (NSThread *)targetExecuteThread in protocol. In the way, tasks distributed to this module will be executed in targetExecuteThread. Weex params can be String or Map. Module supports to return results to Javascript in callback. This callback is type of WXModuleCallback, the params of which can be String or Map. @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end export synchronous methods v0.10+If you want to export synchronous methods which could make Javascript receive return values from natvie, you can use WX_EXPORT_METHOD_SYNC macro. native code: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString)) - (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js code: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" You can alse return number/array/dictionary except string. notice: the exported synchronous native method can only be called on JS thread. Do not do heavy work which will block js execution. notice: Vue 2.0 has not supported this feature yet. It will be supported in version 0.12 at the soonest. Register the moduleYou can register the customized module by calling the method registerModule:withClass in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; Handler extendWeex SDK doesn’t have capabilitis, such as image download 、navigator operation，please implement these protocols by yourself. WXImgLoaderProtocolWeex SDK has no image download capability, you need to implement WXImgLoaderProtocol. Refer to the following examples. WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished. */ -(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock; @end Implement above protocol as follows. @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end Register the handlerYou can register the handler which implements the protocol by calling registerHandler:withProtocol in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; Custom Native Components for iOSComponent extendThere are a lot of native components ready to be used in the Weex SDK, but users always have their own use cases. You might have written an awesome native UI widget in your previous work and just want to wrap up it and export to Weex. So we provide a way to enable developers to create their own custom fully-native components. This guide will use the implementation of existing component image to show you how to build a native component. It will also assume that you are familiar with iOS programming. RegistrationDefining a custom native component is simple. Just call [WXSDKEngine registerComponent:withClass:] with the component’s tag name as first argument. [WXSDKEngine registerComponent:@&quot;image&quot; withClass:[WXImageComponent class]]; Then you can create a WXImageComponent class to represent the implementation of image component. Now you can use &lt;image&gt; wherever you want in the template. &lt;image&gt;&lt;/image&gt; Adding PropertiesThe next thing we can do is to extend some native properties to make the component more powerful. As an image, let’s say we should have a src attribute as image’s remote source and a resize attribute as image’s resize mode(contain/cover/stretch). @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end All of the styles, attributes and events will be passed to the component’s initialization method, so here you can store the properties which you are interested in. @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; &#125; return self;&#125;@end The properties getted in the attributes are of id type, so we have to convert them to the type we want using a conversion function. Basic conversion functions can be found in the WXConvert file, or you can just add your own conversion function. Hooking Render Life CycleA Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. method description initWithRef:type:… Initializes a new component using the specified properties. layoutDidFinish Called when the component has just laid out. loadView Creates the view that the component manages. viewWillLoad Called before the load of component’s view . viewDidLoad Called after the component’s view is loaded and set. viewWillUnload Called just before releasing the component’s view. viewDidUnload Called when the component’s view is released. updateStyles: Called when component’s style are updated. updateAttributes: Called when component’s attributes are updated. addEvent: Called when adding an event to the component. removeEvent: Called when removing an event frome the component. As in the image component example, if we need to use our own image view, we can override the loadView method. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; Now Weex will use WXImageView to render the image component. As an image component, we will need to fetch the remote image and set it to the image view. This can be done in viewDidLoad method when the view is created and loaded. viewDidLoad is also the best time to perform additional initialization for your view， such as content mode changing. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; If image’s remote source can be changed, you can also hook the updateAttributes: method to perform your attributes changing logic. Component’s view always has been loaded while updateAttributes: or updateStyles: is called. - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; Maybe there is even more life cycle hooks you might need to consider, such as layoutDidFinish while layout computing is finished. If you want to go deeper, check out the WXComponent.h file in the source code. Now you can use &lt;image&gt; and its attributes wherever you want in the template. &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; Component Methodfrom WeexSDK 0.9.5, you can define your component method by macro WX_EXPORT_METHODfor example: @implementation WXMyComponent +WX_EXPORT_METHOD(@selector(focus)) +- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self; &#125; - (void)focus &#123; NSLog(@&quot;you got it&quot;); &#125;@end after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"Integrate Devtool to Android","path":"references/advanced/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/references/advanced/integrate-devtool-to-android.html","text":"Integrate Devtool to AndroidWeex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your Android App. Integrate to AndroidInstalling DependenciesWeex Devtools depend on weex_inspector. I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. There are two choices to install it: From Gradle dependencies &#123; compile 'com.taobao.android:weex_inspector:0.8.0.0'&#125; From source code you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(':inspector')&#125; Version compatibility weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - Adding Debug mode switchThe key to control the opening and closing of the debug mode can be summarized as three rules: No.1: Set the switch and Debugger Server addresses via sRemoteDebugMode and sRemoteDebugProxyUrl. WXEnvironment class has a pair of static variables mark Weex current debug mode: public static boolean sRemoteDebugMode; // default closepublic static String sRemoteDebugProxyUrl; // Debugger Server addresses You have to set WXEnvironment.sRemoteDebugMode and WXEnvironment.sRemoteDebugProxyUrl at the right time, for example: private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; No.2: You must call WXSDKEngine.reload() method when sRemoteDebugMode was changed. You can control a state of debug mode via the WXEnvironment.sRemoteDebugMode, but you need reset Weex runtime if you changed a state of debug mode. private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; In this way, You can control the debug mode flexibly. No.3: Auto refresh page via ACTION_DEBUG_INSTANCE_REFRESH broadcast ACTION_DEBUG_INSTANCE_REFRESH can be broadcast messages when the debug mode is switched or Chrome page refresh. You can use this mechanism to inform the current page to refresh in time. public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; ExampleThe easiest way is reuse the code of playground. On the other hand QR code is not necessary, if you review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. There are two examples of how to open debug modes in the Playground App: Set the debug mode via XXXApplication public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; Set the debug mode by scan QR code You review the source code of playground. Debug mode switch control: WXApplication.java Refresh control WXPageActivity.java Known IssuesYou can report issues and bugs here. We will reply as soon as possible.","type":"references"},{"title":"Using Vue","path":"guide/intro/using-vue.html","permalink":"https://weex.apache.org/guide/intro/using-vue.html","text":"Using VueVue in WeexVue.js is an excellent progressive JavaScript framework written by Evan You which is very easy and flexible to use. Developers can write *.vue files with friendly &lt;template&gt;, &lt;style&gt;, &lt;script&gt; tags to build componentized web apps. In Oct 2016 Vue.js launched 2.0, which includes the virtual-DOM and pre-compiler for HTML templates. This means Vue.js can run in a JS-only environment without HTML / CSS parsers. The virtual-DOM layer also makes Vue 2.x able to render native UIs through JavaScript. Weex and Vue now support each other officially. Now that Weex includes Vue 2.x as its built-in JS Framework, Vue can be used to develop native mobile apps. Links Weex tutorial Vue Introduction How Weex works New Features of Vue 2.x in WeexStream RenderingIn Weex, developers can use &lt;foo append=&quot;tree|node&quot;&gt; to customize the rendering granularity to balance different UI complexity and business logic in order to get the best first-paint performance. append=tree means that the entire node, including all its child nodes, will be one-time rendered to native UI after all of the nodes generated completely. And append=node means just render the current node itself first and its child nodes will be futher rendered later. Two-way Data Binding in Form ControlsIn Weex, we provide the same v-model directive as web dev exprience for both &lt;input&gt; and &lt;textarea&gt; components. Developers can write &lt;input v-model=&quot;message&quot;&gt; or &lt;textarea v-model=&quot;message&quot;&gt; to bind data message and show it on the text box automatically. When user modifies the text box, the value of data message will be automatically updated. Isolate Each Page ContextsAs described in how Weex works, all Weex’s JS bundles share a JavaScript instance. So how can we make Vue 2.x used in multiple JS bundles completely isolated, and that one page which extends or rewrites Vue does not affect other pages becomes a problem. Through the collaboration between Weex and Vue. The problem has been solved. &lt;transition&gt;Weex supports the awesome &lt;transition&gt; syntax in Vue 2.x. Developers can easily define the transition of an interface in both states with &lt;transition&gt; tag. NoticeWeb development and native development, after all, there are some differences in functionality and development experience, which are essentially the differences between the native development platform and the Web platform, and Weex is trying to narrow the scope of this difference. See differences of Vue 2.x between Weex and web Using Vue-related LibsVue.js also has more cool related libs. For example Vuex and vue-router. They all work well in Weex. For using Vuex and vue-router, see Using Vuex and vue-router in Weex。 We developed a complete project based on Weex and Vue 2.x which named weex-hackernews. It includes WeexSDK with Vue 2.x in iOS, Android and web. Also we use Vuex and vue-router. The whole project uses the same source code for three different platforms.","type":"guide"},{"title":"Write once, Run Everywhere","path":"guide/intro/write-once.html","permalink":"https://weex.apache.org/guide/intro/write-once.html","text":"Write Once, Run EverywhereWeex is a “Write Once, Run Everywhere” solution. First, Weex is based on web dev experience, which includes syntax and project management. Second, all components &amp; modules in Weex are discussed by iOS, Android, web developers together to ensure it’s common enough to satisfy every platforms. You only need write the same Weex code for each platforms. We think about it in these aspects below: Today for almost all mobile apps, one app solves the same problem in different platforms. Weex hope to supply a lightweight way to describe your business logic which works well in all platforms you need. For the differences of all mobile platforms, we are willing to fill the gap in 3 points: Design the same APIs for all platforms to ensure different platforms have the same business logic description. Implement the APIs with different style or behaviors to ensure the implementation and user experience matches different platforms. Platforms obviously differ among each other. We also have some environment variables to help developers in certain situations. We trust (web) standard is the best for all features in all platforms.","type":"guide"},{"title":"Integrate Devtool to iOS","path":"references/advanced/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/references/advanced/integrate-devtool-to-ios.html","text":"Integrate Devtool to iOSWeex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your iOS App. Integrate to iOSInstalling DependenciesThere are two choices to install dependencies: No.1 From cocoapodssource https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. No.2 From source code Get source code by GitHub. Copy source folder to your project. Choose options as the picture shows. IntegrateStep 1. Add header file in AppDelegate.m From cocoapods: #import &lt;TBWXDevtool/WXDevtool.h&gt; ``- From source code #import “WXDevtool.h” #### Step 2. Initialize inspector when the APP launchedYou can see the WXDevtool header file as follows: ```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */ + (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end Note: The inspector API must be called before weex is initialized setDebug setDebug is used to control the state of debug mode, when its value is YES, open the debug mode, otherwise closed. (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; open inspect model, remove the @selector (setDebug:) or add [WXDevTool setDebug:NO] eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; Step 3. Auto refreshQ: Why do we need auto refresh feature? A: As shown in future, when you click the debugger button, Javascript runtime environment will change from the phone (JavaScriptCore) to PC (Chrome V8), then Weex need to re-initialize the Weex environment, re-render the page. Page rendering is required for the developer to add on its own page. Q: What kind of scene need to add refresh feature? Click debugger button Switch remoteDebug Refresh inspect page Q: How to add auto refresh feature? Register events when Weex initialization. [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; Notes: You must cancel this event in the dealloc method. For example: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; For example, First you can destroy the current instance, and then re-create instance: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; You can see the details in this case WXDemoViewController.m","type":"references"},{"title":"<image>","path":"references/components/image.html","permalink":"https://weex.apache.org/references/components/image.html","text":"&lt;image&gt;Summaryimage tag is used to render a specified picture, and it shouldn’t contain any child component. &lt;img&gt; is not supported currently. Notes: the styles of width and height should be specified, otherwise it won’t work. Child ComponentsThis component supports no child components. Attributes src: &lt;string&gt; image source url resize: v0.5+ &lt;string&gt; the ‘ScaleType’ of the component. The default value is stretch, if this attribute is not specified. Possible values are cover, contain, each of which has the same meaning with w3c standard. placeholder: v0.9+ &lt;string&gt; image to display while the network image src is loading. Styles width: &lt;length&gt; the width of the component. This style should be specified. height: &lt;length&gt; the height of the component. This style should be specifed. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events loadv0.8+ event. The load event fires on an image has been loaded. Only Android and iOS are supported currently. example event object success : true if the image was loaded successfully, otherwise false size : the original size of image, contains two parameters: naturalWidth representing the original width of image in pixels, naturalHeight representing the original height of image in pixels. default value. The default value for both parameters is 0. Examples&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .page-head &#123; width: 750px; height: 200px; &#125; .title-bg &#123; width: 750px; height: 200px; &#125; .title-box &#123; width: 750px; height: 200px; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32px; font-weight: bold; &#125; .article &#123; padding: 20px; &#125; .paragraph&#123; margin-bottom: 15px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<a>","path":"references/components/a.html","permalink":"https://weex.apache.org/references/components/a.html","text":"&lt;a&gt;a defines a hyperlink to a page in the web. Its purpose and syntax is very similar to in HTML5. Child ComponentsThis type of component supports all kinds of weex component as it’s child components except for its own kind. Attributes href: href attributes defines the URL of the hyperlink. Styles:common stylesCheck out the common styles Eventscommon eventsCheck out the common events NotesWe can’t guarantee the order of execution between onclick function and href. we recommend that do not use the click event in a. Examples&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a class=\"button\" href=\"http://dotwe.org/raw/dist/3e0e40f9ddad79f98cd236753965ffd8.js\"&gt; &lt;text class=\"text\"&gt;Jump&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; width: 450px; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5 &#125; .text &#123; font-size: 60px; color: #666666; text-align: center; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<cell>","path":"references/components/cell.html","permalink":"https://weex.apache.org/references/components/cell.html","text":"&lt;cell&gt;SummaryThis component must be used as a subcomponent of a list component, which is for the performance optimizing during scrolling. Child ComponentsThis type of component supports all kinds of weex component as its child components. AttributesNotes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. keep-scroll-position {boolean}: v0.11+ List Whether to keep the last sliding position after inserting the Cell Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Notes: cell itself is a container, its layout info is managed by list, so specifying cell’s margin info will not work. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Exampleplease refer to List","type":"references"},{"title":"<input>","path":"references/components/input.html","permalink":"https://weex.apache.org/references/components/input.html","text":"inputThe weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child ComponentsThis component supports no child components. Attributes type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, password, tel, email, url , number etc. each of which has the same meaning with \u001dW3C standard. value: the value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. maxlength: v0.7+ a number value to specify maxlength of input. return-key-type {string}：v0.11the keybord returen key type support defalut;go;next;search;send,done. Styles placeholder-color: the color of placeholder. Default value is ‘#999999’. Pseudo-classv0.9.5+: input component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support ‘color’ style. support ‘font-size’ style. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Events input: the value of an input character changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a ‘blur’ event. focus: a component has received focus. blur: a component has lost focus. return:the return key click. the object property of event: returnKeyType: return key Type of component value: component text value common eventscheck out common events support ‘appear’ / ‘disappear’ event. Methoads focus() v0.9+ The focus() method is used to give focus to an input component and tigger soft keybord(if it can be focused). blur()v0.9+ The blur() method is used to remove focus from an input component and close soft keybord(if it has focus). setSelectionRange(selectionStart,selectionEnd) v0.11+set text selection range of input or textarea selectionStart {number}:set starting location text selection range selectionEnd {number}:set end location text selection range getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+get text selection range of input or textarea selectionStart {number}:get starting location text selection range selectionEnd {number}: get end location text selection range Notesdoes not support the common-event ‘click’. Please listen to the ‘input’ or ‘change’ event instead. Parameters of events’ object for ‘input’ and ‘change’ events:’value’: the value of the component who dispatched this event.’timestamp’: the time stamp of the event. for ‘focus’ and ‘blur’ events:’timestamp’: the time stamp of the event. Example&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; try it","type":"references"},{"title":"<div>","path":"references/components/div.html","permalink":"https://weex.apache.org/references/components/div.html","text":"&lt;div&gt;SummaryThe most fundamental component which is a contianer to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child ComponentsThis type of component supports all kinds of weex component as its child components including its own kind. AttributesThere is no specific attribute for this component. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<indicator>","path":"references/components/indicator.html","permalink":"https://weex.apache.org/references/components/indicator.html","text":"&lt;indicator&gt;SummaryThis component must be used as a subcomponent of a slider component. Child ComponentsThis component supports no child components. AttributesThere is no specific attribute for this component. Styles item-color: &lt;colors&gt; This style attribute sets the normal item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-size: &lt;length&gt; The size of the indicator elements, which is an float attribute. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"4500\" @change=\"onchange\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;img.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .title &#123; position: absolute; top: 20px; left: 20px; padding-left: 20px; width: 200px; color: #FFFFFF; font-size: 36px; line-height: 60px; background-color: rgba(0, 0, 0, 0.3); &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125; .indicator &#123; width: 700px; height: 700px; item-color: green; item-selected-color: red; item-size: 50px; top: 200px; left: 200px; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; title: 'item A', src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item B', src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item C', src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;, methods: &#123; onchange (event) &#123; console.log('changed:', event.index) &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<refresh> & <loading>","path":"references/components/refresh.html","permalink":"https://weex.apache.org/references/components/refresh.html","text":"refresh &amp; loadingv0.6.1+ Loading ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component. Attributes display has value of show or hide. Stylescommon styles: check out common styles for components Events onloading triggered when loading Restrictions refresh/loading does not support remove action, Weex 0.9 will fix it. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. Example&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;loading class=\"loading\" @loading=\"onloading\" :display=\"showLoading\"&gt; &lt;text class=\"indicator\"&gt;Loading ...&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; showLoading: 'hide', lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onloading (event) &#123; modal.toast(&#123; message: 'loading', duration: 1 &#125;) this.showLoading = 'show' setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; this.showLoading = 'hide' &#125;, 1500) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125; .loading &#123; justify-content: center; &#125; .indicator &#123; color: #888888; font-size: 42px; padding-top: 20px; padding-bottom: 20px; text-align: center; &#125;&lt;/style&gt; Refresh ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component. Attributes display has value of show or hide, default value is show. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components Events onrefresh: triggered when the scroller has been pulled down onpullingdown: triggered when the scroller has been pulled down. you can get dy, pullingDistance, viewHeight, type from onpullingdown event object. dy: the differencen between two scroll actionspullingDistance: the distance of pullingviewHeight: the height of refreshView type: &quot;pullingdown&quot; constant string type for this event Restrictions refresh/loading does not support remove action, may support in Weex 0.9. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. example&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;refresh class=\"refresh\" @refresh=\"onrefresh\" @pullingdown=\"onpullingdown\" :display=\"refreshing ? 'show' : 'hide'\"&gt; &lt;text class=\"indicator\"&gt;Refreshing ...&lt;/text&gt; &lt;/refresh&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; refreshing: false, lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onrefresh (event) &#123; console.log('is refreshing') modal.toast(&#123; message: 'refresh', duration: 1 &#125;) this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, onpullingdown (event) &#123; console.log('is onpulling down') modal.toast(&#123; message: 'pulling down', duration: 1 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .indicator &#123; color: #888888; font-size: 42px; text-align: center; &#125; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<slider>","path":"references/components/slider.html","permalink":"https://weex.apache.org/references/components/slider.html","text":"&lt;slider&gt;SummaryA slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child ComponentsIt supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: . This value determines the index of current shown slide. The default value is 0. offset-x-accuracy {float}：set the scroll event trigger precision, precision value represents the rolling distance of a page width ratio. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. scroll 0.11+：this event is fired when scrolling. The current offsetXRatio value is given in this event callback. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<switch>","path":"references/components/switch.html","permalink":"https://weex.apache.org/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ The weex builtin component switch is used to create and manage an IOS styled On/Off buttons, for example, the Airplane mode button in the Settings app is a switch button. Child ComponentsThere are no child components for the switch component. Attributes checked &lt;boolean&gt; true|false, default value is false, indicating whether the button is on or not. disabled &lt;boolean&gt; true|false, default value is false, indicating whether the button is enable or not. StylesNotes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxs padding and padding-xxs border and border-xxs Notes: If the container of &lt;switch&gt; is not set to align-items:flex-start, the switch in android will be stretched. common styles: check out common styles for components Events onappear / ondisappear event. check out common events onclick: check out common events onchange: check out common events Parameters of events’ object for onchange event: value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event. Examples&lt;template&gt; &lt;div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;normal&lt;/text&gt; &lt;switch&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;checked&lt;/text&gt; &lt;switch checked=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;disabled&lt;/text&gt; &lt;switch disabled=\"true\" checked=\"true\"&gt;&lt;/switch&gt; &lt;switch disabled=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;onchange&lt;/text&gt; &lt;switch @change=\"onchange\"&gt;&lt;/switch&gt; &lt;text class=\"info\"&gt;&#123;&#123;checked&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; checked: false &#125; &#125;, methods: &#123; onchange (event) &#123; console.log(`onchage, value: $&#123;event.value&#125;`) this.checked = event.value &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .example &#123; flex-direction: row; justify-content: flex-start; margin-top: 60px; &#125; .label &#123; font-size: 40px; line-height: 60px; width: 350px; color: #666; text-align: right; margin-right: 20px; &#125; .info &#123; font-size: 30px; line-height: 60px; color: #BBB; margin-left: 10px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<list>","path":"references/components/list.html","permalink":"https://weex.apache.org/references/components/list.html","text":"Listv0.6.1+ The List component, which inherits from Scroller component, is a core component, and it provides the most popular features for using a list of items. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. example &lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; lists: ['A', 'B', 'C', 'D', 'E'] &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 300px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 88px; text-align: center; color: #41B883; &#125;&lt;/style&gt; Child ComponentsNotes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsonloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events APIAll cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore eventloading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. Example&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"references/components/video.html","permalink":"https://weex.apache.org/references/components/video.html","text":"&lt;video&gt;v0.6.1+ The video component can be used to embed video content in a weex page. Child Components text is the only valid type of child component. Attributes src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed. example&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<textarea>","path":"references/components/textarea.html","permalink":"https://weex.apache.org/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ SummaryThe weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child ComponentsThis component supports no child components. attributes value: &lt;string&gt; the value of the control. placeholder: &lt;string&gt; a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: &lt;boolean&gt; a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: &lt;boolean&gt; a boolean attribute lets you specify that a form control should have input focus when the page loads. rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. StylesPseudo-classv0.9.5+: textarea component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<text>","path":"references/components/text.html","permalink":"https://weex.apache.org/references/components/text.html","text":"&lt;text&gt;The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Child ComponentsThis component supports no child components. Attributes value(string): text value of this component. This is equal to the content of ‘text’. examplevar textComponent = this.$el(&quot;textid&quot;);this.text = textComponent.attr.value; Styles lines: specify the text lines. Default value is 0 for unlimited. text styles: check out text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. line-height in iOS is different from h5 and Android, text value will be placed at bottom of line box. not support ‘flex-direction, ‘justify-content’, ‘align-items’ which is active for child nodes, and text has no child nodes. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Eventscommon eventscheck out common events support ‘click’ event. support ‘appear’ / ‘disappear’ event. iconfontsupport:v0.12.0 support ttf and woff font format to custom your text, call addRule in dom module to build your own font-family &lt;template&gt; &lt;div style='flex-direction:row;margin-top:50px'&gt; &lt;text style='font-family:iconfont4;font-size:50;color:green'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:50;'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&amp;#xe61d;&amp;#xe714;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:blue'&gt;&amp;#xe711;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:green'&gt;&amp;#xe71c;&amp;#xe60b;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; mounted: function() &#123; var domModule = weex.requireModule('dom'); //目前支持ttf、woff文件，不支持svg、eot类型,moreItem at http://www.iconfont.cn/ domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\" &#125;); &#125;&#125;&lt;/script&gt; try it Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex 是一套简单易用的跨平台开发方案，能以 Web 的开发体验构建高性能、可扩展的原生应用。Vue 是一个轻量并且功能强大的渐进式前端框架。&lt;/text&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex is an cross-platform development solution that builds high-performance, scalable native applications with a Web development experience. Vue is a lightweight and powerful progressive front-end framework. &lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .panel &#123; width: 600px; margin-left: 75px; border-width: 2px; border-style: solid; border-color: #BBB; padding-top: 15px; padding-bottom: 15px; padding-left: 15px; padding-right: 15px; margin-bottom: 30px; &#125; .text &#123; lines: 3; color: #666666; font-size: 32px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<waterfall>","path":"references/components/waterfall.html","permalink":"https://weex.apache.org/references/components/waterfall.html","text":"waterfallv0.11.0+ A component providing waterfall layout. Child ComponentsNotes: The waterfall now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell: presents the content for a single data item in waterfall header: components that need to stretch across multiple columns. It can be sticky by using css position. Attributes column-width : This property describes the width of columns in waterfall elements. auto: means that the column width will be determined by other properties(e.g., column-count, if it has a non-auto value). &lt;length&gt;: describes the optimal column width. The actual column width may be wider (to fill the available space), or narrower (only if the available space is smaller than the specified column width). Specified values must be greater than 0. column-count:This property describes the number of columns of a multicol element. auto: means that the number of columns will be determined by other properties (e.g., column-width, if it has a non-auto value). &lt;integer&gt;: describes the optimal number of columns into which the content of the element will be flowed. Values must be greater than 0. If both column-width and column-count have non-auto values, the integer value describes the maximum number of columns. column-gap:sets the gap between columns. if normal is specified, the gap will be 32. To see other attributes, please checkout List Component Attributes Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events APIAll subcomponents in waterfall support the scrollToElement API in dom module Examplesee playground waterfall example","type":"references"},{"title":"<web>","path":"references/components/web.html","permalink":"https://weex.apache.org/references/components/web.html","text":"&lt;web&gt;v0.5+ Use web component to display any web content in the weex page. The srcattribute is used to specify a special source. You also can use webview module to control some web operation such as goBack,goForward and reload. see webview module.For example,You can use web component and webview module to assemble a browser. Child ComponentsThis component supports no child components. Attributessrc(string): this attribute specifies the page source to load. Styleswidth(float): the width of the component, default value is 0. This style must be specified. height(float): the height of the component, default value is 0. This style must be specifed. common stylescheck out the common styles. support flexbox related stylessupport box model related stylessupport position related styles Eventspagestart: sent after the web component starts loading a page.pagefinish: sent after the web component finishes loading a page.error: sent if the web component failed to load a page. common eventssupport appear / disappear event. Check out common events Notesnot support click event. ExampleWe use a simple Browser Demo to show how to use web component and webview module. Check out webview module. &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<scroller>","path":"references/components/scroller.html","permalink":"https://weex.apache.org/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ A scroller is a component in vertical direction which can have multiple child components in one column. If total height of its child components exceed the height of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. Child ComponentsScroller supports all kinds of components, such as div, text, etc.And there are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical scroll-direction defines the scrollable axis of scroller and flex-direction defines the layout axis of scroller. scroll-direction and flex-direction must be set to the same direction, otherwise, undefined behavior may happen. Default value for scroll-direction is vertical, and for flex-direction is row . Use scroll-direction:horizontal and flex-direction: row when a horizontal layout and scrollable scroller is expected. Use scroll-direction:vertical and flex-direction: column when a vertical layout and scrollable scroller is expected. But thoes two values are default, if you don’t set them, it also works fine. loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsloadmore used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"The difference between Weex and Vue","path":"references/migration/difference.html","permalink":"https://weex.apache.org/references/migration/difference.html","text":"The difference between Weex and VueWork in progresss.","type":"references"},{"title":"Migration from Weex","path":"references/migration/migration-from-weex.html","permalink":"https://weex.apache.org/references/migration/migration-from-weex.html","text":"Migration from WeexWork in progresss.","type":"references"},{"title":"animation","path":"references/modules/animation.html","permalink":"https://weex.apache.org/references/modules/animation.html","text":"animationSmooth and meaningful animation is very effective for enhancing the user experience of mobile application, you can use the animation module to perform animation on components. A animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component. So, if you have a image component, you can move, rotate, grow, or shrink it. APItransition(node, options, callback)Argumentsnodetype: node position: An element that will be animated, for example , specify the ref attribute for the element you want to animated as element, so you can get this element by calling this.refs.element. optionstype: object position: Transition options. duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description example linear Specifies a transition effect with the same speed from start to end ease-in Specifies a transition effect with a slow start ease-out Specifies a transition effect with a slow end ease-in-out Specifies a transition effect with a slow start and end cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value example width The width applied to the component after the animation finished. length none height The height applied to the component after the animation finished. length none backgroundColor The background color applied to the component after the animation finished. string none opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center transform Transform function to be applied to the element. The properties in the following table are supported object none properties of transform: name description value type default value translate/translateX/translateY Specifies the location of which the element will be translated to. pixel or percent none rotate Specifies the angle of which the element will be rotated, the unit is degree. number none scale/scaleX/scaleY Stretch or shrink the element. number none callbacktype: function position: Callback which is called after the completion of transition. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div ref=\"test\" @click=\"move\" class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const animation = weex.requireModule('animation') const modal = weex.requireModule('modal') export default &#123; methods: &#123; move () &#123; var testEl = this.$refs.test; animation.transition(testEl, &#123; styles: &#123; color: '#FF0000', transform: 'translate(250px, 100px)', transformOrigin: 'center center' &#125;, duration: 800, //ms timingFunction: 'ease', delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; width: 250px; height: 250px; background-color: #DDD; &#125;&lt;/style&gt; try it","type":"references"},{"title":"globalEvent","path":"references/modules/globalevent.html","permalink":"https://weex.apache.org/references/modules/globalevent.html","text":"globalEventv0.8+ SummaryglobalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removeEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global eventsAPI development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) ExampleAndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\", params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)register global event. Arguments eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Examplevar globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123;2console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)remove global event Arguments eventName(string): You no longer need to listen for event names. Examplevar globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"clipboard","path":"references/modules/clipboard.html","permalink":"https://weex.apache.org/references/modules/clipboard.html","text":"clipboardv0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution only support text. only works on Android and iOS. NOT works for html5, for web security reason. APIgetString(callback)reads from clipboard. Argumentscallback(function): the callback function after executing this action. data is the return value. setString(text)sets the text to clipboard, having the same effect as copying manually. Argumentstext(string): the text copied to clipboard. Example&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"modal","path":"references/modules/modal.html","permalink":"https://weex.apache.org/references/modules/modal.html","text":"modalWeex provides a series of message boxes: toast, alert, confirm and prompt. APItoast(options)A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. For Android: If the duration is longer than 3, it will use a system defined variable called LONG, otherwise it will use another variable called SHORT For iOS: It will show the toast during the specified time. alert(options, callback)An alert box is often used if you want to make sure information comes through to the user.When an alert box pops up, the user will have to click “OK” to proceed. Arguments options (object): alert box options. message (string): the text message that the alert shows. okTitle (string): the text of positive button, default is ‘OK’. callback (function): callback when complete.This method has a callback function whose arguments will be: result (string): the title text of the confirm button that clicked by user. confirm(options, callback)A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user. prompt(options, callback)A prompt box is often used if you want the user to input a value before entering a page.When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. Arguments options (object): some options. message (string): the message that the prompt shows. okTitle (string): the title text of confirm button, default is ‘OK’. cancelTitle (string): the title text of cancel button, default is ‘Cancel’. callback (function): callback when complete.This method has a callback function whose arguments will be: ret (object): the argument will be a object, which has attributes result and data, like { result: &#39;OK&#39;, data: &#39;hello world&#39; } result (string): the title of the button that clicked by user. data (string): the value of the text that entered by user. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"showToast\"&gt;Toast&lt;/text&gt; &lt;text class=\"button\" @click=\"showAlert\"&gt;Alert&lt;/text&gt; &lt;text class=\"button\" @click=\"showConfirm\"&gt;Confirm&lt;/text&gt; &lt;text class=\"button\" @click=\"showPrompt\"&gt;Prompt&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') export default &#123; methods: &#123; showToast (event) &#123; console.log('will show toast') modal.toast(&#123; message: 'This is a toast', duration: 0.3 &#125;) &#125;, showAlert (event) &#123; console.log('will show alert') modal.alert(&#123; message: 'This is a alert', duration: 0.3 &#125;, function (value) &#123; console.log('alert callback', value) &#125;) &#125;, showConfirm (event) &#123; console.log('will show confirm') modal.confirm(&#123; message: 'Do you confirm ?', duration: 0.3 &#125;, function (value) &#123; console.log('confirm callback', value) &#125;) &#125;, showPrompt (event) &#123; console.log('will show prompt') modal.prompt(&#123; message: 'This is a prompt', duration: 0.3 &#125;, function (value) &#123; console.log('prompt callback', value) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"navigator","path":"references/modules/navigator.html","permalink":"https://weex.apache.org/references/modules/navigator.html","text":"Navigatorv0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can let us to specify whether to apply animation or not during the transition. APIpush(options, callback)push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. url(stirng): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. pop(options, callback)pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"storage","path":"references/modules/storage.html","permalink":"https://weex.apache.org/references/modules/storage.html","text":"storagev0.7+ Summarystorage is a series of apis, allowing you to for example add, modify or delete stored data items. APIsetItem(key, value, callback)When passed a key name and value, will add that key to the storage,or update that key’s value if it already exists. Arguments key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. getItem(key, callback)When passed a key name, will return that key’s value. Arguments key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. removeItem(key, callback)When passed a key name, will remove that key from the storage. Arguments key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = weex.requireModule('storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)Returns an integer representing the number of data items stored in the Storage object. Arguments callback(object): the callback function after executing this action. getAllKeys(callback)Returns an array that contains all keys stored in Storage object. Arguments callback(object): the callback function after executing this action. Example&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"picker","path":"references/modules/picker.html","permalink":"https://weex.apache.org/references/modules/picker.html","text":"pickerv0.9+ SummaryA series of stream api. It provides function: pick data,pick date,pick time APIpick(options, callback[options])pick data(single column) Arguments options {Object}:pick options index {number}:default selected row items {array}:picker’s data callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {number}:the selected index,it exists when result is success. pickDate(options, callback[options])pick date Arguments options {Object}:pick date options value {string}:Required，date picker selected value by default，date’s form is yyyy-MM-dd max {string}:optional，date’s max value min {string}:optional，date’s min value callback {function (ret)}：the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is yyyy-MM-dd ,it exists when result is success. pickTime(options, callback[options])pick time Arguments options {Object}:pick time options value {string}:required，the form of value is HH:mm callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter： result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is HH:mm,it exists when result is success. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"stream","path":"references/modules/stream.html","permalink":"https://weex.apache.org/references/modules/stream.html","text":"streamA series of stream api. It provides a network request. APIfetch(options, callback,progressCallback)Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): response type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Note Default Content-Type is ‘application/x-www-form-urlencoded’. (The type specified in fetch is the response type!) You need to set the Content-Type header to ‘application/json’ manually if you want to post the json body. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Weex Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;weexStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Vue Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;vueStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var stream = weex.requireModule('stream') export default &#123; data () &#123; return &#123; weexStar: 'unknown', vueStar: 'unknown' &#125; &#125;, methods: &#123; getStarCount (repo, callback) &#123; return stream.fetch(&#123; method: 'GET', type: 'json', url: 'https://api.github.com/repos/' + repo &#125;, callback) &#125; &#125;, created () &#123; this.getStarCount('alibaba/weex', res =&gt; &#123; this.weexStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) this.getStarCount('vuejs/vue', res =&gt; &#123; this.vueStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; &#125; .title &#123; font-size: 45px; color: #888888; &#125; .count &#123; font-size: 45px; font-weight: bold; margin-left: 12px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"WebSocket","path":"references/modules/websocket.html","permalink":"https://weex.apache.org/references/modules/websocket.html","text":"WebSocketv0.12+ SummaryWebSockets is an advanced technology that makes it possible to open an interactive communication session between the user’s H5/iOS/android and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply Notes: iOS and h5 provide webSocket default handle. if you use webSocket in android environment . you should provide custom adapter implementation,source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; refer: weex playground APIWebSocket(url, protocol)create websocket Arguments url {string}:The URL to which to connect; protocol {string}:the websocket protocol send(data)Transmits data to the server over the WebSocket connection Arguments data {string}:A text string to send to the server. close(code,reason)Closes the WebSocket connection or connection attempt, if any. If the connection is already CLOSED, this method does nothing. Arguments code {number}: the status code explaining why the connection is being closed. reason {string}:a string explaining why the connection is closing onopen(options)An event listener to be called when the WebSocket connection’s readyState changes to OPEN; this indicates that the connection is ready to send and receive data. Arguments options {object}:an empty object onmessage(options)An event listener to be called when a message is received from the server Arguments options {object}:the server message options data {string}: The listener received message onclose(options)An event listener to be called when the WebSocket connection’s readyState changes to CLOSED Arguments options {object}:the CloseEvent is sent to clients using WebSockets when the connection is closed code {number}: Returns an unsigned short containing the close code send by the server reason {string}: Returns a string indicating the reason the server closed the connection wasClean {boolen}: Returns a Boolean that Indicates whether or not the connection was cleanly closed. onerror(options)An event listener to be called when an error occurs. Arguments options {object}:the error event data {string}: The listener received error data Example&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"references/modules/webview.html","permalink":"https://weex.apache.org/references/modules/webview.html","text":"webviewA series of web operation api like goBack, goForward, and reload. ‘webview’ module used with the web component. APIgoBack(webElement)Loads the previous location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goBack(webElement); goForward(webElement)Loads the next location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goForward(webElement); reload(webElement)Reloads the current web page. Arguments webElement(web): the element of the web component. Examplevar webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.reload(webElement.ref); Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"references/modules/dom.html","permalink":"https://weex.apache.org/references/modules/dom.html","text":"domSummaryA series of dom apis that sending virtual-dom’s messages to the native renderer to update the dom tree. The only API for developers to use in a .vue file is scrollToElement which you can use by calling the $scrollTo method. Other APIs mentioned on this page should only be used through the native renderer in the callNative process. APIscrollToElement(node, options)Scroll the page to the specified node. This API should only be used on the element in the scroller or list component. This API can be used by calling the VM’s method $scrollTo (deprecated). You can use weex.requireModule(&#39;dom&#39;).scrollToElement to call this API in your .we file. Arguments node(Node): an element that scrolled into the view. options(object): some options. offset(number): An offset to the visible position, default is 0. animated (bool) :set element animation, default true Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; /*justify-content: space-around;*/ justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it getComponentRect(ref,callback) v0.9.4+You can get the view rectangle information of named element. An example callback result maybe: &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; If you want to get the rectangle information of ‘weex view’ container, you can specify the ref=&#39;viewport&#39;. Example Useage: &lt;template&gt; &lt;div class=\"wrapper\" style='margin-top:200px'&gt; &lt;div ref=\"box\" class=\"box\"&gt; &lt;text class=\"info\"&gt;Width: &#123;&#123;size.width&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Height: &#123;&#123;size.height&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Top: &#123;&#123;size.top&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Bottom: &#123;&#123;size.bottom&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Left: &#123;&#123;size.left&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Right: &#123;&#123;size.right&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"info btn\" @click='click()'&gt;&#123;&#123;this.tip&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; const dom = weex.requireModule('dom') function round(size) &#123; var roundSize = &#123; 'width': Math.round(size.width), 'height': Math.round(size.height), 'top': Math.round(size.top), 'bottom': Math.round(size.bottom), 'left': Math.round(size.left), 'right': Math.round(size.right) &#125; return roundSize &#125; export default &#123; data () &#123; return &#123; size: &#123; width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 &#125;, ref:\"viewport\", tip:\"get box rect\" &#125; &#125;, mounted () &#123; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125;, methods:&#123; click:function() &#123; if (this.ref === 'viewport') &#123; this.ref = this.$refs.box; this.tip = \"get viewport rect\" &#125; else &#123; this.ref = 'viewport' this.tip = \"get box rect\" &#125; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .btn &#123; margin-top:20px; border-width:2px; border-style: solid; border-radius:10px; width:300px; margin-left:170px; padding-left:35px; border-color: rgb(162, 217, 192); &#125; .btn:active &#123; background-color: #8fbc8f;22border-color: gray; &#125; .box &#123; align-items:center; margin-left: 150px; width: 350px; height: 400px; background-color: #DDD; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .info &#123; font-size: 40px; top:30px; margin-left:20px; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; color: #41B883; &#125;&lt;/style&gt; try it addRulesupport:v0.12.0 you can add your rule for dom by this, now we support fontFace only for building your custom font-family, use it on text directly. fontFacevar domModule = weex.requireModule('dom');domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;); try it","type":"references"},{"title":"Using Vuex and vue-router","path":"references/vue/difference-of-vuex.html","permalink":"https://weex.apache.org/references/vue/difference-of-vuex.html","text":"Using Vuex and vue-routerVue.js also has many peripheral technology products such as Vuex and vue-router, etc. Those libraries can also works well in Weex. We developed a complete project based on Weex and Vue.js which named weex-hackernews. We used Vuex and vue-loader in it, and it works well on both iOS, Android and web. Using Vuex Official Vuex documents Vuex is a state management pattern + library for Vue.js applications. it’s also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. As a kind of state management library, Vuex is platform-independent, It also can be used in Weex. Read its official documents for more details. It also integrates with Vue’s official devtools extension to provide advanced features on web platform, such as zero-config time-travel debugging and state snapshot export / import. (web platform only) Using vue-router Official vue-router documents Creating a Single-page Application with Vue.js + vue-router is dead simple. With Vue.js, you are already composing our application with components. When adding vue-router to the mix, all you need to do is map your components to the routes and let vue-router know where to render them. However, there are many difference between web and Android or iOS, some features of vue-router are limited in Weex. Router modevue-router provides three routing modes: hash: uses the URL hash for routing. Works in all Vue-supported browsers, including those that do not support HTML5 History API. (default) history: requires HTML5 History API and server config. See HTML5 History Mode. abstract: works in all JavaScript environments, e.g. server-side with Node.js. You can pass the mode parameter when creating a router: new Router(&#123; mode: 'abstract', // ...&#125;) Obviously “hash” mode and “history” mode are only available on the web, and have no effect in Weex. That is, you have to use “abstract” mode in Android and iOS. However, vue-router will automatically be forced into “abstract” mode if no browser API is present. so, just don’t set the mode option, or set it to “abstract”. Programmatic navigationvue-router use &lt;router-link&gt; to create a navigation link, but in which some of the features based on the DOM events, it doesn’t work well in the native environment. In Weex, you must use the Programmatic Navigation to manage the router. Here is an basic example using &lt;router-link&gt;: &lt;!-- Can only be used on the web, it takes no effects on Android or iOS! --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; For native platforms, you have to use the router.push: &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"Difference with Web","path":"references/vue/difference-with-web.html","permalink":"https://weex.apache.org/references/vue/difference-with-web.html","text":"Differences between using Vue in Web and WeexPlatform DifferencesVue.js was designed for the Web platform at the begining. Although it can be based on Weex to develop native applications, there are still many differences between web and native. See Platform Differences Between Weex and Web for more details. Due to those differences, Weex doesn’t support those features in Vue.js (mostly are DOM-related): Event bubbling and capturing are not supported. Event modifiers, such as .prevent,.capture, .stop,.self are meaningless in the native environment. The keyboard event modifiers, like .{KeyCode | keyAlias} is also meaningless. (see docs in Vue.js) No need to call vm.$mount manually, the entry component will mount to the root view of the native container by default. v-html andv-text directives are not supported. Functional differencesVue 2.0 Runtime-only buildVue 2.0 provides two available builds, the standalone build and the runtime-only build. see the official document for more information. Weex only required the runtime-only build of Vue 2.0 for better performance and less code size. The specific differences are: The template attribute is not supported when defining a component. Does not support using x-templates. Does not support using Vue.compile. Isolate the context of multiple pagesWeex use the “multiple-pages” concept in native, different js bundle will be run in different native views, there context is isolated. Even the Vue variable is not the same instance between js bundles. (However, all the js bundle will share the same Weex runtime.) Based on this feature, the global configurations in Vue will only take effect on the current page: Vue.config Vue.component Vue.directive Vue.filter Vue.mixin Vue.use Note: Those methods are still work, but its effect will be limited to the current page. Restrictions in styleCSS is very flexible, has a lot of properties, support a variety of layout modes. This is the advantage of CSS, but also a bottleneck in browser performance optimization. The style in Weex is parsed by the native renderer, and for the sake of performance and complexity, Weex makes some trade-offs about CSS features to make it better suited to “best practices”. Single class selectorWeex only supports to use single class name in &lt;style&gt;, does not support type selectors, ID selectors, attribute selectors, adjacent sibling selectors and the combinators. /* Support single class name selector */.one-class &#123; font-size: 36px;&#125;/* Does not support to use combinators between selector */.parent &gt; .child &#123; padding-top: 10px;&#125;.foo + .bar &#123; margin-left: 20px;&#125;/* Does not support attribute selectors. The `v-cloak` directive is not supported */[V-cloak] &#123; color: #FF6600;&#125; The restriction is only for the style definition, does not affect the use of class names. You can still use multiple class names on a single tag, such as: &lt;template&gt; &lt;div class=\"one two three\"&gt;&lt;div&gt;&lt;/template&gt; Scoped by defaultIn Weex, For single file components, the styles written in the &lt;style&gt; can only be used in the current component. In order to maintain consistency with Native, it is recommended that you write the style in the .vue file with thescoped attribute, that is, &lt;style scoped&gt;. Supported CSS attributesWeex supports a subset of CSS, and will continue to expand. Weex supports box-model and flexbox, as well as other common styles. See Weex Common Style and Supported Web Standards for more information. In addition, you should also pay attention to the following points: No need to write style prefix. Weex doesn’t support display: none; and therefore doesn’t support the v-show directive. In order to optimize the efficiency of CSS parser, Weex doesn’t support shorthand attributes, involving the following attributes: flex border, border-(top|bottom|left|right) margin padding font background Differences in developmentBecause of the platform difference, you have to compile your source file in two different ways: For the web, you can compile source files in any official way, such as Webpack + vue-loader or Browserify + vueify. and require the weex-vue-render, which is a group of Weex build-in components. For Android and iOS, we’ve provided weex-loader to compile the .vue files. That is, use Webpack + weex-loader to generate the js bundle that is available for the native. Use weex-loaderweex-loader is a loader for Webpack, see the official document to learn how to use it. One more thing should be reminded is that if the entry file of your webpack config is a .vue file, you also need to pass an additional entry parameter, usually set to true. module.exports = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true', // other configurations ... module: &#123; loaders: [&#123; // matches the .vue file path that contains the entry parameter test: /\\.vue(\\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;,&#125; You don’t need to write those additional parameters if you are using .js file as entry file. We recommend using javascript files as the entry file of webpack config. Setup native development environmentsSince your are using Weex to develop native apps, setup native development environments, both Android and iOS, would be very useful. See Integrating Weex to the existing application for more information.","type":"references"},{"title":"Extend to Android","path":"v-0.10/advanced/extend-to-android.html","permalink":"https://weex.apache.org/v-0.10/advanced/extend-to-android.html","text":"Extend to AndroidModule extendweex sdk support Module extend,Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module Follow the steps below. Step to customize a module Customize module must extend WXModule @WXModuleAnno annotation must be added, as it is the only the way to recognized by Weex The access levels of mehtod must be public The module class also can not be an inner class Customize can not be obfuscated by tools like ProGuard Module methods will be invoked in UI thread, do not put time consuming operation there Weex params can be int, double, float, String, Map, List Refer to the following example: public class WXEventModule extends WXModule&#123; private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\"; @JSMethod public void openURL(String url)&#123; //implement your module logic here &#125;&#125; Register the mouldeWXSDKEngine.registerModule(\"event\", WXEventModule.class); Use this module in weex DSLNow event moudle is avaiable in weex, use the module like this: var event = require('@weex-module/event');event.openURL(\"http://www.github.com\"); Javascript callbackIf the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @JSMethodpublic void openURL(String url,JSCallback callback)&#123; //implement your module logic here Map&lt;String,Object&gt; resp = new HashMap(); resp.put(\"result\",\"ok\"); callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extendThere are label, image, div, scroll, ect. components in weex, you can also customize your own components. Step to customize a component Customize components must extend WXComponent or WXContainer @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK. The access levels of mehtod must be public The component class can not be an inner class Customize can not be obfuscated by tools like ProGuard Component methods will be invoked in UI thread, do not put time consuming operation there. Weex params can be int, double, float, String, Map, List, Array Refer to the following example public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; super(instance, dom, parent, instanceId, isLazy); &#125; @Override protected void initView() &#123; mHost = new TextView(mContext); &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; Register the ComponentWXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); Adapter extendImagedownloadAdapterWeex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examples. public class ImageAdapter implements IWXImgLoaderAdapter &#123; private Activity mContext; public ImageAdapter(Activity activity) &#123; mContext = activity; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; mContext.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\"))&#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width&lt;=0 || view.getLayoutParams().height&lt;=0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .resize(view.getLayoutParams().width, view.getLayoutParams().height).into(view); &#125; &#125;); &#125;&#125; Component Methodfrom WeexSDK 0.9.5, you can define your component method for example, define a method in component: @JSMethodpublic void focus()&#123;//method implementation&#125; after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt; &lt;/template&gt; &lt;script&gt; module.exports = { created: function() { this.$el('mycomponent').focus(); } } &lt;/script&gt;","type":"advanced"},{"title":"Extend to web","path":"v-0.10/advanced/extend-to-html5.html","permalink":"https://weex.apache.org/v-0.10/advanced/extend-to-html5.html","text":"Extend Weex HTML5IntroWeex is a extendable cross-platform solution for dynamic programming and publishing projects. You can build your own components on web platform or native platform by extending the components system. Also you can extend weex by adding new methods for one module, new moudles or new bundle loaders. Follow the steps bellow you can dive into the journy of creating multiple builtin components, APIs and loaders. First of all, components, APIs and loaders are extensions to weex, so you can create your extensions without requiring the weex package, that means your extensions can be totally standalone. Second, you should always implement a extension for all the three platforms (android, ios and web), except that you only use it on one specific platform. After all weex is a cross platform framework and the equality of user expierence in all platforms is very important. Although you can create components separately on one platform by another, or welcome other developers on other platforms to join your work (You can always find coders who want the same feature with you in the commity). Here are docs about how to create native extensions on ios and android. You should publish your extensions somewhere weex developers can easily find, somewhere popular, independent and easy to search and use, such as, npm. Npm is what we strongly recommended. The most important thing is, you’d better name your extension appropriately: it should begin with a weex- if it is a weex extension, and it should end up with a -&lt;platform&gt; as a platform mark. If your package is wrapped up with all the three platforms you can ignore it through. Here is a demonstrating component &lt;weex-hello-web&gt; to show how to define your own component. Create a new componentSteps: Extend Weex.Component, override methods of component class. Use Weex.registerComponent to register your customized component in the init method of the installation module. export the init method for the installation (Every weex-html5 extension has to have a init method in the export object, which is for another weex project to install.) Here’s a example to create a weex component for web platform (weex-html5): const attr = &#123; // ...&#125;const style = &#123; // ...&#125;const event = &#123; // ...&#125;// every extension file should have a init method.function init (Weex) &#123; const Component = Weex.Component const extend = Weex.utils.extend // the component's constructor function Hello (data) &#123; Component.call(this, data) &#125; // extend the prototype Hello.prototype = Object.create(Component.prototype) extend(Hello.prototype, proto) // config the attributes, styles and events. extend(Hello.prototype, &#123; attr &#125;) extend(Hello.prototype, &#123; style: extend(Object.create(Component.prototype.style), style) &#125;) extend(Hello.prototype, &#123; event &#125;) Weex.registerComponent('weex-hello', Hello)&#125;// export the init method.export default &#123; init &#125; The code above is extracted from weex-hello-web/src/index.js. This demo has overrided the create method of the base class Component. You can also override other methods to customize your component’s behavior. The typical methods of class Component you may override are: create: to create the node of the component, and return it. createChildren to create the children’s nodes. insertBefore to insert a child before another child. appendChild to append a child in the children list. removeChild to remove a child in the children list. Advanced: Need more code demonstrations about overriding the component’s methods ? Just take a look at the weex repo’s code. Basically the most of the built-in components are defined this way. Important! To register your component in the init method, use Weex.registerComponent. Here’s the demo code: Weex.registerComponent('weex-hello', Hello) The code above is from weex-hello-web/src/index.js Install the component using Weex.install. // import the original weex-html5.import weex from 'weex-html5'import hello from 'weex-hello-web'// install the component.weex.install(hello) The code above is from weex_extend_demo/src/main.js use the component in your .we file: &lt;template&gt; &lt;div&gt; &lt;weex-hello class=\"hello\" style=\"txt-color:#fff;bg-color:green\" value=\"WEEX\" onclick=\"handleClick\"&gt; &lt;/weex-hello&gt; &lt;/div&gt;&lt;/template&gt; The code above is from weex_extend_demo/demo/index.we Add a new APIYou can add new API modules, or just add a new API for any existing API modules. For example, you can add a new module user with APIs like ‘login’, ‘logout’ etc. The developer can invoke the API by using require(&#39;@weex-module/moduleName)[methodName](arg1, arg2, ...) (Module APIs). Steps: Implement your API modules. Use Weex.registerAPIModules to register your API modules in the init method of your installation module. Here is a example for register a new API module First create a file named user.js for a new module, then define login/logout methods. const user = &#123; // for user to login. login (callbackId) &#123; login.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;, // for user to logout. logout (callbackId) &#123; logout.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;&#125;// add meta info to user module.const meta = &#123; user: [&#123; name: 'login', args: ['function'] &#125;, &#123; name: 'logout', args: ['function'] &#125;]&#125;export default &#123; init (Weex) &#123; // Register your new module. The last parameter is your // new API module's meta info. Weex.registerApiModule('user', user, meta) &#125;&#125; After above coding work, you can publish this user helper API to npm now, for example, with the name of weex-user-helper. Install the component using Weex.install in your new weex project. import Weex from 'weex-html5'import user from 'weex-user-helper'Weex.install(user) Use the user helper API in your dsl code (xxx.we): &lt;template&gt; &lt;div&gt; &lt;div class=\"btn\" onclick=\"handleClick\"&gt; &lt;text&gt;LOGIN&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var userHelper = require('@weex-module/user') module.exports = &#123; methods: &#123; handleClick: function () &#123; userHelper.login(function () &#123; // ... do sth. in callback. &#125;) &#125; &#125; &#125;&lt;/script&gt; Add a new loaderLoader is only a type of extension for weex-html5 (web platform), native platform is not needing this. Weex’s builtin loaders to load a weex bundle are xhr, jsonp and source. The default loader is xhr. You can register your own loader by using weex.registerLoader. For example, you got a service method named myServe.getWeexBundle, which can load a weex bundle file through some magical tunnel: function loadByMyServe(pageId, callback) &#123; myServe.getWeexBundle(pageId).then(function (bundle) &#123; callback(bundle) &#125;).catch(function(err) &#123; callback(err) &#125;)&#125;// export the init method to enable weex install this loader.export default &#123; init (Weex) &#123; Weex.registerLoader('myserve', loadByMyServe) &#125;&#125; install and use your loader in your project’s entry file: import Weex from 'weex-html5'// or import from './myserve.js', no matter where you can import your loader file.import loader from 'myLoader'Weex.install(loader)// use your loader in the init function:(function () &#123; function getUrlParam (key) &#123; const reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') const match = location.search.match(reg) return match &amp;&amp; match[1] &#125; const page = getUrlParam('page') || 'examples/build/index.js' Weex.init(&#123; appId: location.href, loader: 'myserve', // use the loader type you defined. source: page, rootId: 'weex' &#125;)&#125;)(); That’s the major extension feature weex brought to you. The deep details can be found in the weex’s repo and the weex’s community.","type":"advanced"},{"title":"How data-binding works","path":"v-0.10/advanced/how-data-binding-works.html","permalink":"https://weex.apache.org/v-0.10/advanced/how-data-binding-works.html","text":"How data-binding worksWeex JS Framework is a MVVM framework. It observe data and use {{bindedKey}} syntax to bind in views. When data is changed in anyway, the view will automatically be updated due to data-binding. For example, The content of a &lt;text&gt; component is bound with the key notes in data: &lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;notes&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;template&gt;&lt;script&gt; module.exports = &#123; data: &#123; notes: 'Hello' &#125; &#125;&lt;/script&gt; Weex JS Framework first observe the data object to make sure each data change in the future will be observed. And then it will compile the whole &lt;template&gt;. When it finds that the content of the &lt;text&gt; is bound with notes, JS Framework will watch the data.notes changes and set a handler which will update the &lt;text&gt; content with new data.notes. So developer only need to manage the data, the view display could automatically do corresponding changes. Some special data-binding syntax here: will watch the condition value changes. When it changes to true, the &lt;foo&gt; element will be created and attached, otherwise it will be not created or removed. will watch the mutations of a list. At the beginning the &lt;foo&gt; element will be cloned and attached with each item in list. When some items are added, removed or moved, the &lt;foo&gt; element list will be re-generated new content in the right order with minimum alterations. will process repeat first and if the second. In another way, it will walk through each item in list, if the item’s condition value is true, a &lt;foo&gt; element will be cloned and attached with this certain item value. Compared with virtual DOM diff algorithm, we just “diff” the data and only calculate/update the virtual DOM with minimum alterations for each user interaction or data-change operation. So it’s more lightweight and fast especially for small views in mobile devices.","type":"advanced"},{"title":"Extend to iOS","path":"v-0.10/advanced/extend-to-ios.html","permalink":"https://weex.apache.org/v-0.10/advanced/extend-to-ios.html","text":"Extend to iOSModule extendWeex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module following the steps below. Step to customize a module Module customized must implement WXModuleProtocol A macro named WX_EXPORT_METHOD must be added, as it is the only way to be recognized by Weex. It takes arguments that specifies the method in module called by JavaScript code. The weexInstance should be synthesized. Each module object is bind to a specific instance. Module methods will be invoked in UI thread, so do not put time consuming operation there. If you want to execute the whole module methods in other thread, please implement the method - (NSThread *)targetExecuteThread in protocol. In the way, tasks distributed to this module will be executed in targetExecuteThread. Weex params can be String or Map. Module supports to return results to Javascript in callback. This callback is type of WXModuleCallback, the params of which can be String or Map. @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end Register the moduleYou can register the customized module by calling the method registerModule:withClass in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; Handler extendWeex SDK doesn’t have capabilitis, such as image download 、navigator operation，please implement these protocols by yourself. WXImgLoaderProtocolWeex SDK has no image download capability, you need to implement WXImgLoaderProtocol. Refer to the following examples. WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished. */ -(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock; @end Implement above protocol as follows. @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end Register the handlerYou can register the handler which implements the protocol by calling registerHandler:withProtocol in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol; [WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; Custom Native Components for iOSComponent extendThere are a lot of native components ready to be used in the Weex SDK, but users always have their own use cases. You might have written an awesome native UI widget in your previous work and just want to wrap up it and export to Weex. So we provide a way to enable developers to create their own custom fully-native components. This guide will use the implementation of existing component image to show you how to build a native component. It will also assume that you are familiar with iOS programming. RegistrationDefining a custom native component is simple. Just call [WXSDKEngine registerComponent:withClass:] with the component’s tag name as first argument. [WXSDKEngine registerComponent:@&quot;image&quot; withClass:[WXImageComponent class]]; Then you can create a WXImageComponent class to represent the implementation of image component. Now you can use &lt;image&gt; wherever you want in the template. &lt;image&gt;&lt;/image&gt; Adding PropertiesThe next thing we can do is to extend some native properties to make the component more powerful. As an image, let’s say we should have a src attribute as image’s remote source and a resize attribute as image’s resize mode(contain/cover/stretch). @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end All of the styles, attributes and events will be passed to the component’s initialization method, so here you can store the properties which you are interested in. @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; &#125; return self;&#125;@end The properties getted in the attributes are of id type, so we have to convert them to the type we want using a conversion function. Basic conversion functions can be found in the WXConvert file, or you can just add your own conversion function. Hooking Render Life CycleA Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. method description initWithRef:type:… Initializes a new component using the specified properties. layoutDidFinish Called when the component has just laid out. loadView Creates the view that the component manages. viewWillLoad Called before the load of component’s view . viewDidLoad Called after the component’s view is loaded and set. viewWillUnload Called just before releasing the component’s view. viewDidUnload Called when the component’s view is released. updateStyles: Called when component’s style are updated. updateAttributes: Called when component’s attributes are updated. addEvent: Called when adding an event to the component. removeEvent: Called when removing an event frome the component. As in the image component example, if we need to use our own image view, we can override the loadView method. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; Now Weex will use WXImageView to render the image component. As an image component, we will need to fetch the remote image and set it to the image view. This can be done in viewDidLoad method when the view is created and loaded. viewDidLoad is also the best time to perform additional initialization for your view， such as content mode changing. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; If image’s remote source can be changed, you can also hook the updateAttributes: method to perform your attributes changing logic. Component’s view always has been loaded while updateAttributes: or updateStyles: is called. - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; Maybe there is even more life cycle hooks you might need to consider, such as layoutDidFinish while layout computing is finished. If you want to go deeper, check out the WXComponent.h file in the source code. Now you can use &lt;image&gt; and its attributes wherever you want in the template. &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; Component Methodfrom WeexSDK 0.9.5, you can define your component method by macro WX_EXPORT_METHODfor example: @implementation WXMyComponent +WX_EXPORT_METHOD(@selector(focus)) +- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self; &#125; - (void)focus &#123; NSLog(@&quot;you got it&quot;); &#125;@end after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt; &lt;/template&gt; &lt;script&gt; module.exports = { created: function() { this.$el('mycomponent').focus(); } } &lt;/script&gt;","type":"advanced"},{"title":"Integrate to Android","path":"v-0.10/advanced/integrate-to-android.html","permalink":"https://weex.apache.org/v-0.10/advanced/integrate-to-android.html","text":"Integrate to AndroidWhen you need to use the new features or to customize specific features, you can rely on the Source SDK for development。 PrerequisitesAssuming you have the Android SDK installed, run android to open the Android SDK Manager. Make sure you have the following installed: Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.2 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) Android NDK (download &amp; extraction instructions here) Point Gradle to your Android SDK: either have $ANDROID_SDK and $ANDROID_NDK defined, or create a local.properties file in the root of your weex checkout with the following contents: sdk.dir=absolute_path_to_android_sdkndk.dir=absolute_path_to_android_ndk Example: sdk.dir=/Users/your_name/android-sdk-macosxndk.dir=/Users/your_name/android-ndk-r10e Building the source1. Clone source from githubFirst, you need to git clone weex from github: git clone https://github.com/alibaba/weex.git 2. Build APK 1) Android studio build APK Step 1: run android studio Step 2: open the file of ~/weex/android/playground/build.gradle Step 3: Run the Project and the Apk will auto install in your android device 2) Gradle build APK Step 1: enter the direction of &quot;/weex/android/playground&quot;Step 2: run the build command: ./gradlew clean assembleStep 3: obtain the payground APK from the direction of weex/android/playground/app/build/outputs/apk/Step 3: then adb install -r weex/android/playground/app/build/outputs/apk/playgroud.apk 3. Adding the :weex_sdk_android projectAdd the :weex_sdk_android project in android/settings.gradle: include ':weex_sdk_android'project(':weex_sdk_android').projectDir = new File( rootProject.projectDir, '../weex_sdk_android') Modify your android/app/build.gradle to use the :weex_sdk_android project instead of the pre-compiled library, e.g. - replace compile &#39;com.taobao.android:weex_sdk:0.4.1 with compile project(&#39;:weex_sdk_android&#39;): dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.0.1' compile project(':weex_sdk_android') ...&#125; 3. Making 3rd-party modules use your projectIf you use 3rd-party weex modules, you need to override their dependencies so that they don’t build the pre-compiled library. Otherwise you’ll get an error while compiling - Error: more than one library with package name &#39;com.taobao.weex&#39;. Modify your android/app/build.gradle and replace compile project(&#39;:weex-custom-module&#39;) with: compile(project(':weex-custom-module')) &#123; exclude group: 'com.taobao.weex', module: 'weex_sdk_android'&#125; 4、How to load local Your Js bundle in the directory of Android assetsBesides load a Js Bundle online, you also can load the js bundle from the directory of Android assets. For Example: String yourbundleStr = WXFileUtils.loadFileContent(&quot;yourBundle.js&quot;, context);WXSDKInstance.render(TAG, yourbundleStr, options, null, width, Height, WXRenderStrategy.APPEND_ASYNC); Building from Android StudioFrom the Welcome screen of Android Studio choose “Import project” and select the playground folder of your app. You should be able to use the Run button to run your app on a device. Tip Since the packet size limit is currently only compiled arm , X86 does not support. Gradle build fails in ndk-build. See the section about local.properties file above. #Quick access Requirements an existing, gradle-based Android app Prepare your appIn your app’s build.gradle file add the WEEX dependency: compile &apos;com.taobao.android:weex_sdk:0.4.1&apos; You can find the latest version of the WEEX library on jcenter. Next, make sure you have the Internet permission in your AndroidManifest.xml: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; Add native codeYou need to add some native code in order to start the Weex runtime and get it to render something. To do this, we’re going to create an Application to init weex, then we we’re going to create an Activity that creates a WeexContainerView, starts a Weex application inside it and sets it as the main content view. public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); WXEnvironment.addCustomOptions(\"appName\",\"TBSample\"); WXSDKEngine.init(this); try &#123; WXSDKEngine.registerComponent(\"wtRichText\", WTRichText.class); ...... WXSDKEngine.registerModule(\"event\", WXEventModule.class); &#125; catch (WXException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Next, // Create or find RenderContainer view. // Notice: If you create RenderContainer manually, don't forget add it to view tree.RenderContainer renderContainer = (RenderContainer)findViewById(R.id.container);//crate Weex instanceWXSDKInstance mInstance = new WXSDKInstance(this);//set render containermInstance.setRenderContainer(renderContainer);//set image AdaptermInstance.setImgLoaderAdapter(new ImageAdapter(this));//register render listenermInstance.registerRenderListener(new IWXRenderListener() &#123; @Override public void onViewCreated(WXSDKInstance instance, View resultView) &#123; // Notice: If you don't setRenderContainer before render, you need add the resultView to view tree here. &#125; @Override public void onRenderSuccess(WXSDKInstance instance) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode,String msg) &#123; &#125;&#125;); //start render weex view mInstance.render(pageName,template, null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); That’s it, your activity is ready to run some JavaScript code. Reference ExampleWeex Examples","type":"advanced"},{"title":"Integrate to web","path":"v-0.10/advanced/integrate-to-html5.html","permalink":"https://weex.apache.org/v-0.10/advanced/integrate-to-html5.html","text":"Integrate Weex HTML5 to your projectIntroWeex is a extendable cross-platform solution for dynamic programming and publishing projects, which is for developers to write code once and run the code everywhere. The bundle transformed from the source can currently run on android, ios and web platform. Weex HTML5 is a renderer for weex bundle to run on a webview or a modern browser etc. Get Weex HTML5Use npm to install the latest version of Weex HTML5, require it in your code by CommonJS and use it as a npm package. Install from npmMake sure you get the latest version by npm install or npm update. For more information of npm, please visit the npm official site. npm install weex-html5 require weex-html5: const weex = require(&apos;weex-html5&apos;) Initialize and runYou can initialize weex through the API init. This method takes a config object as the first argument to confirm the runtime infomation and environment. Following parameters can be set by this config object: appId: app instance id, can be either a string or a number source: the requested url of weex bundle, or the transformed code it self. loader: the loader type to load the weex bundle, which value is ‘xhr’ or ‘jsonp’ or ‘source’. xhr: load the source (weex bundle url) by XHR jsonp: load the source bundle by JSONP source: the source parameter above should be a weex bundle content (transformed bundle). rootId: the id of the root element. Default value is ‘weex’. Here is a example to do the initialzation: function weexInit() &#123; function getUrlParam (key) &#123; var reg = new RegExp(&apos;[?|&amp;]&apos; + key + &apos;=([^&amp;]+)&apos;) var match = location.search.match(reg) return match &amp;&amp; match[1] &#125; var loader = getUrlParam(&apos;loader&apos;) || &apos;xhr&apos; var page = getUrlParam(&apos;page&apos;) // jsonp callback name should be specified or be the default // value &apos;weexJsonpCallback&apos; if the &apos;jsonp&apos; loader is used. var JSONP_CALLBACK_NAME = &apos;weexJsonpCallback&apos; window.weex.init(&#123; jsonpCallback: JSONP_CALLBACK_NAME, appId: location.href, source: page, loader: loader, rootId: &apos;weex&apos; &#125;)&#125;weexInit()","type":"advanced"},{"title":"Integrate to iOS","path":"v-0.10/advanced/integrate-to-ios.html","permalink":"https://weex.apache.org/v-0.10/advanced/integrate-to-ios.html","text":"import Weex iOS to your projectYou will need to build Weex from source if you want to work on a new feature/bug fix, try out the latest features not released yet, or maintain your own fork with patches that cannot be merged to the core. Assuming you have installed iOS Develop Environment and CocoaPods. 1. Clone source from githubFirst, you need to git clone weex from github: git clone https://github.com/alibaba/weex.git 2. Import WeexSDK to projectCopy the whole folder /ios/sdk to your project directory. Before adding the dependencies, please confirm that the project directory already exists the Podfile. If not, create a new one. Then, edit this file, adding some necessary dependecis for the target. target &apos;YourTarget&apos; do2platform :ios, &apos;7.0&apos;2pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos;end You can get your YourTarget below Run pod install in current directory, for a while, .xcworkspace will be created. At this point, the dependencies have been established. 3. Init Weex EnvironmentWe are used to doing some initial tasks in appDelegate. Of course, there is no exception. You can do this in didFinishLaunchingWithOptions as follows. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment]; //register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel:WXLogLevelVerbose]; 4. Render Weex InstanceWeex supports two different modes, the full page rendering and part of page rendering.Something you have to do is to render weex view with specific URL, then add it to the parent container, which may be the viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123;2[super viewDidLoad];22_instance = [[WXSDKInstance alloc] init];2_instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; [_instance renderWithURL:self.url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very imporent class, which provides you with some basic methods and callbacks, such as renderWithURL、onCreate、onFailed and etc. You can understand their usage by reading WXSDKInstance.h. 5. Destroy Weex InstancePlease release weex instance in dealloc stage of viewContoller, or it will lead to memory leak. - (void)dealloc&#123; [_instance destroyInstance];&#125; 6. Build .IPA for WeexWe can also pack all the JS files into the app’s resources. This way you can run your app without development server and submit it to the AppStore. Install weex-toolkit and transform your .we file to JS by running weex index.we -o index.js, index.we is the entry file of your app. Move index.js to your app’s Xcode project and add the file to your target. Replace [_instance renderWithURL:&#39;httpURL&#39;] with: [_instance renderWithURL: [[NSBundle mainBundle] URLForResource:@&quot;index&quot; withExtension:@&quot;js&quot;]] Go to Product -&gt; Archive in Xcode and follow the steps to build your .IPA file and submit it to the AppStore.","type":"advanced"},{"title":"Devtools for Android","path":"v-0.10/tools/devtools-android.html","permalink":"https://weex.apache.org/v-0.10/tools/devtools-android.html","text":"Devtools for Android Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page.At present The devtools consist of two part : Inspector and Debugger. If you want it work well, you must install a weex-devtool as debug server. InspectorInspector can be used to show your Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. DebuggerDebugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Install and launch devtools serverOpen your terminal then type npm install -g weex-toolkit and run.Launch it just type and run the command weex debug, then a Chrome web page will be opened. Use on an android device or emulatorTaste of first debug with playgroundIf you are a green hand to the debug of weex, we recommend you to try your first debug with playground, what you need to do is just launch the playground and scan the QR code shown in the debug page which wound opened if the devtools server have been launched. after you scan the QR code, the web page will list your connected devices. How Debugger WorksDevtools expands Chrome Debugging Protocol and the mechanism of communication between client and debug sever is based on JSON-RPC. Devtools ClientDevtools Client is integrated in App as aar, it connects to debug server through webscoket protocol with out permission check. I recommend you just packaged it in your debug version consider of the security mechanism. Devtools Debug ServerDevtools Debug Server is the center node of the communication, it connects to both app and chrome, acts as the turn server of debugging protocol messages and the manager of the js runtime. Chrome FrontEndChrome’s V8 engine acts as the javascript runtime, when debug mode is enabled, all the js code run on it. On the other side we also reuse most of the Chrome’s debugging user interface, such as set breakpoint, see call stack and so on. Enable devtools in your own appOf course you can reuse the code of playground to build your own app, that is the simplest way to let your app’s js code debuggable. On the other hand QR code is not necessary, if your review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. following those steps you can do the same thing. Gradle dependency on inspector.There are two choices to set the dependency, the Choice A is recommanded if you have no change to weex_sdk or inspector, while if you use your own custom weex_sdk or inspector Choice B is suitable. A - aar dependency from jcenter.dependencies &#123; compile &apos;com.taobao.android:weex_inspector:0.0.8.1&apos;&#125; I strongly recommend you use the latest version since both weex sdk and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. B - source code dependency. you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(&apos;:inspector&apos;)&#125; Version compatibility weex sdk weex inspector debug server 0.8.0.1+ 0.0.8.1 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 Initialize in your XXXApplication file. public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;/*&quot;DEBUG_SERVER_HOST&quot;*/); &#125; private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = &quot;ws://&quot; + host + &quot;:8088/debugProxy/native&quot;; &#125;&#125; Ship It! You must launch your bundle server firstly. In your weex dir, run command “./start”; Launch your remote debug server. Run command weex debug, chrome will open a web page show a simply guidance and QR code; Launch your app and make sure debug mode was enabled. You will see a device list in the chrome web page opened by last step, each device item have two button, Debugger and Inspector;There are two way to enable debug mode: scaning the QR code and handle the content just like the playground have done. init it in the XXXApplication by calling initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;), if you call initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;) after weex sdk inited, you need to call WXSDKEngine.reload() to refresh the runtime. Once you click the button Inspector chrome will open a page show the inspector view, on the other side, click the button Debugger chrome will open a new page to show the debug view; OPTIONS[OPTION] set your remote bundle server ip.For example, in the playground it is in the `IndexActivity.java`, you need to change the value of `DEFAULT_IP` in IndexActivity.java from `&quot;your_current_IP&quot;` to a server ip like `&quot;30.30.30.150&quot;`: private static final String DEFAULT_IP = &quot;30.30.30.150&quot;; // &quot;your_current_IP&quot;; [OPTION] enable network inspection.OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new OkHttpInterceptor()); Notice The network inspection only support OKHttpClient right now!!! If you want to use the network inspection to catch your bundle request, you must change your bundle server ip to the real server ip. Known Issues You can report issues and bugs here. We will reply as soon as possible.","type":"tools"},{"title":"Devtools for IOS","path":"v-0.10/tools/devtools-ios.html","permalink":"https://weex.apache.org/v-0.10/tools/devtools-ios.html","text":"Devtools for IOSRemote debug for your native iOS app using Chrome Developer Tools weex-devtool launch： install and run weex-devtool $:npm install -g weex-devtool $:weex-devtool it will launch chrome browser, showing wss ip address in chrome address bar. playground install WXDevtool Install dependencies. $:pod install Usage AppDelegate.m header file #import &quot;WXDevTool.h&quot; Initialize inspector when the APP launched Note: The inspector API must be called before weex is initialized + (void)setDebug:(BOOL)isDebug; isDebug default is NO, now you open inspect model. opposite is YES, if you set isDebug to YES, then open debug model and inspect model. + (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } open inspect model, remove the @selector(setDebug:) or add [WXDevTool setDebug:NO] eg：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } Build and running APP, this time chrome will display your device with App name, select inspector to open the inspector tab. Log print support for different levels of print. eg: #import &quot;WXDevTool.h&quot; PDLogE()/PDLogW() WXDevtool DependenciesYour app must be linked against the following frameworks/dylibs libicucore.dylib CFNetwork.framework CoreData.framework Security.framework Foundation.framework","type":"tools"},{"title":"Devtools","path":"v-0.10/tools/devtools.html","permalink":"https://weex.apache.org/v-0.10/tools/devtools.html","text":"DevtoolsWeex devtools is a custom devtools for weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page, both Android and IOS platform are supported. Install$ npm install -g weex-toolkit usageweex debug [options] [we_file|bundles_dir] Options: -h, --help output usage information -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer|loader] -w, --watch watch we file changes auto build them and refresh debugger page![default enabled] start debugger$weex debug this command will start debug server and launch a chrome opening DeviceList page.this page will display a qrcode ,you can use Playground App scan it for starting debug. start debugger with a we file$weex debug your_weex.we this command will compile your_weex.we to your_weex.js and start the debug server as upon command.your_weex.js will deploy on the server and displayed in DeviceList page as another qrcode contain the url of your_weex.js start debugger with a directory of we files$weex debug your/we/path -e index.we this command will build every file in your/we/path and deploy them on the bundle server. your directory will mapping to http://localhost:port/weex/use -e to set the entry of these bundles. and the url of “index.we” will display on device list page as another qrcode. FeaturesConnect devices Inspector Inspector can be used to show your Element \\ Network \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. Elementnative view element weex dom element Networkshow the total time and latency show the header and response Console Resource Debugger Debugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Breakpoint and CallStack Integrate devtools Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. IOS See the doc Weex devtools (IOS), it will lead you to config and use it step by step.","type":"tools"},{"title":"Event Bubble","path":"v-0.10/references/bubble.html","permalink":"https://weex.apache.org/v-0.10/references/bubble.html","text":"Event Bubble v0.13+Weex 1.0 implements the W3C standard event bubbling mechanism. Usage&lt;template&gt; &lt;div class=\"root\" onclick=\"rootClick\" bubble=\"true\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"outer\" onclick=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" onclick=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the elements, you can see the event spread up, followed by the trigger. NoticeOne thing should be noticed: For compatibility with previous versions, Weex does not turn on event bubbling by default. You need to add bubble = &quot;true&quot; on the root element’s properties to turn on the bubbling mechanism. Otherwise, the event will not be propagated upwards, keeping the same effect as the previous version. stopPropagationIn the event handler function, you can use the e.stopPropagation() method to prevent the event from escalating. Note that e.stopPropagation() differs from bubble = &quot;true&quot;, which affects only the current elements and the propagation of parent elements, without affecting the propagation of child elements; the latter is a switching mechanism that is added for compatibility, Will be a global shutdown or open the bubble mechanism, the two can co-exist, as follows: &lt;template&gt; &lt;div class=\"root\" onclick=\"rootClick\" bubble=\"true\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"outer\" onclick=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" onclick=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the element, you can see the event up to the parent element is terminated, no longer continue to spread to the root element.","type":"references"},{"title":"Transformer","path":"v-0.10/tools/transformer.html","permalink":"https://weex.apache.org/v-0.10/tools/transformer.html","text":"gulp-weex gulp plugin for weex transformer Usagevar gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) OptionsoldFormatwhether transform to old format. default: false. isEntrywhether is an entry module which has bootstrap(...). default: true.","type":"tools"},{"title":"Component APIs","path":"v-0.10/references/api.html","permalink":"https://weex.apache.org/v-0.10/references/api.html","text":"APIsYou can access these apis through this(Vm) context in script methods. e.g. &lt;script&gt;module.exports = &#123; methods: &#123; somemethod: function() &#123; this.$vm('someId'); &#125; &#125;&#125;&lt;/script&gt; $(id)Deprecated, please use $vm instead. $el(id)Return the element referenced by specific id. Arguments id(string): the unique identifier. Returns (Element): an Element object referenced. Tips id is only guaranteed to be unique within the current (page)components, if you are looking for the parent components or child components, you can make use of the communication mode between components. Further reading: id, Communicate Between Components $vm(id)Return the vm object referenced by specific id. Arguments id(string): the unique identifier. Returns vm(Vm): a Vm object referenced. Tips id is only guaranteed to be unique within the current (page)components, if you are looking for the parent components or child components, you can make use of the communication mode between components. Further reading: id, Communicate Between Components $getConfig()Get the current global environment variables and configuration information. Returns config(object): the object of config. bundleUrl(string): the url of bundle. debug(boolean): if is debug mode. env(object): a object of envrioment. weexVersion(string): a version of weex sdk. appName(string): a name of app. appVersion(string): a version of app. platform(string): the platform, one of iOS, Android and Web. osVersion(string): the version of os. deviceModel(string): the model of device. native only deviceWidth(number): the width of device, in pixels. deviceHeight(number): the height of device, in pixels. $call(module, method, …args)Deprecated, please use require(&#39;@weex-module/module&#39;)[method](...args) instead. See modules for more information","type":"references"},{"title":"","path":"v-0.10/references/cheatsheet.html","permalink":"https://weex.apache.org/v-0.10/references/cheatsheet.html","text":"Weex Cheat SheetNative Components component attribtues styles events special parent children &lt;div&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;text&gt; value box modelflexpositionbackground-coloropacitycolorfont-sizefont-stylefont-weighttext-decorationtext-aligntext-overflowline-height clickappeardisappear - text only &lt;image&gt; src box modelflexboxpositionbackground-coloropacityresize clickappeardisappear - (none) &lt;scroller&gt; show-scrollbarscroll-direction box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;list&gt; loadmoreoffset box modelflexboxpositionbackground-coloropacity clickappeardisappearloadmorerefreshloading - &lt;cell&gt;&lt;header&gt;&lt;refresh&gt;&lt;loading&gt; &lt;cell&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear &lt;list&gt; (any) &lt;slider&gt; auto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearchange - (any)&lt;indicator&gt; &lt;indicator&gt; - box modelflexboxpositionitem-coloritem-selected-coloritem-size clickappeardisappear &lt;slider&gt; (none) &lt;wxc-navpage&gt; heightbackground-colortitletitle-colorleft-item-titleleft-item-colorright-item-titleright-item-colorleft-item-srcright-item-src box modelflexboxpositionbackground-coloropacity clickappeardisappearnaviBar.leftItem.clicknaviBar.rightItem.click - (any) &lt;wxc-tabbar&gt; tab-items box modelflexboxpositionbackground-coloropacity tabBar.onClick - (none) &lt;embed&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappear - (none) &lt;web&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappearpagestartpagefinisherror - (none) &lt;video&gt; srcplay-statusauto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearstartpausefinishfail - (none) &lt;a&gt; href box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;input&gt; typevalueplaceholderdisabledautofocus box modelflexboxpositionbackground-coloropacityplaceholder-colorcolorfont-sizefont-stylefont-weighttext-align clickappeardisappear - (none) &lt;switch&gt; checkeddisabled box modelflexboxpositionbackground-coloropacity appeardisappearinputchangefocusblur - (none) Native Modules module apis @weex-module/dom scrollToElement(node, { offset }) @weex-module/modal toast({ message, duration })alert({ message, okTitle }, callback)confirm({ message, okTitle, cancelTitle }, callback(result))prompt({ message, okTitle, cancelTitle }, callback(result, data)) @weex-module/stream fetch({ method, url, headers, type, body }, callback({ status, ok, statusText, data, headers }), progressCallback({ readyState, status, length, statusText, headers})) @weex-module/webview goBack(ref)goForward(ref)reload(ref) @weex-module/navigator push({ url, animated }, callback)pop({ animated }, callback) @weex-module/animation transition(node, { styles, duration, timingFunction, delay, transform-origin }, callback) Special Template Syntax &lt;foo x=&quot;abc&quot;&gt; &lt;foo style=&quot;name1: value1; name2: value2&quot;&gt; &lt;foo class=&quot;a b c&quot;&gt; &lt;foo onclick=&quot;methodName&quot;&gt; &lt;foo id=&quot;abc&quot;&gt; &lt;foo if=&quot;expr&quot;&gt; &lt;foo repeat=&quot;item in list&quot;&gt; &lt;foo repeat=&quot;(key,item) in list&quot;&gt; &lt;component type=&quot;foo&quot;&gt; ViewModel APIs this.$vm(el) this.$el(el) this.$getConfig() this.$emit(type, data) this.$dispatch(type, data) this.$broadcast(type, data) ViewModel Options data methods computed init, created, ready events example: module.exports = &#123; data: function () &#123; return &#123; x: 1, y: 2 &#125; &#125; methods: &#123; foo: function () &#123; console.log('foo') &#125; &#125;, computed: &#123; z: function () &#123; return this.x + this.y &#125; &#125;, events: &#123; custom: function (e) &#123; console.log(e) &#125; &#125;, init: function () &#123;&#125;, created: function () &#123;&#125;, ready: function () &#123;&#125;&#125;"},{"title":"Common Events","path":"v-0.10/references/common-event.html","permalink":"https://weex.apache.org/v-0.10/references/common-event.html","text":"Common EventsWeex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Bellow are the common event attributes that can be added to weex components to define event actions. Click eventThe onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example: &lt;template&gt; &lt;text style=\"font-size: 60px\" onclick=\"{{update}}\"&gt;I am {{name}}&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = { data: { name: 'Tom' }, methods: { update: function () { this.name = this.name === 'Tom' ? 'Jerry' : 'Tom' } } } &lt;/script&gt; Longpress eventIf a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example: &lt;template&gt; &lt;div style=\"width: 400px; height: 200px; background-color: {{bg}}; justify-content: center; align-items: center;\" onlongpress=\"{{update}}\"&gt; &lt;text style=\"font-size: 60px\"&gt;Press me&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = { data: { bg: '#FF0000' }, methods: { update: function () { this.bg = this.bg === '#FF0000' ? '#00FF00' : '#FF0000' } } } &lt;/script&gt; Appear eventIf a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. example Disappear eventIf a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. example Page eventWeex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered example","type":"references"},{"title":"List of the names of colors","path":"v-0.10/references/color-names.html","permalink":"https://weex.apache.org/v-0.10/references/color-names.html","text":"List of the names of colorsBasic color keywords: Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords: Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"Common Style","path":"v-0.10/references/common-style.html","permalink":"https://weex.apache.org/v-0.10/references/common-style.html","text":"Common StyleAll of weex tags share some common style rules Box Model Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0DO NOT use border-width:1. There is a default viewport &lt;viewport width=&quot;750&quot;&gt;, if the actual width of a device is 720px, then border-width:1 will be border-width:0.96. As weex do not support sub-pixel, this border would not be rendered. border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) Although the the default overflow style is overflow:hidden in android, a view will not be clipped by its parents’ border-radius. This only happens on Android, it works fine on iOS. border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 Notes: The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt; and &lt;text&gt;. Weex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. example: &lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex containerFlexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examplesa list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Positionwe can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50; left: 50; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50; left: 50; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Other Common Style opacity background-color Type of Style Value length type number type color type (The list of color keywords.) enumerated type Simple StepThese up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"references"},{"title":"Common Attribute","path":"v-0.10/references/common-attrs.html","permalink":"https://weex.apache.org/v-0.10/references/common-attrs.html","text":"Common AttributeAttributes provide additional information about weex tags. All weex tags can have attributes, attributes are always specified in the start tag and usually come in name/value pairs like: name=”value”. Mustache can be used inside a value.All of weex tags have the following attributes： idSpecifies a unique id for an element in &lt;template&gt; scope. With id attribute you can easily refer a weex tag. &lt;div id=\"logo\"&gt;&lt;/div&gt; &lt;div id=\"item-{{index}}\"&gt;&lt;/div&gt; styleSpecifies an inline style for an element. &lt;div style=\"width: 200; height: 200\"&gt;&lt;/div&gt; &lt;div style=\"padding: {{x}}; margin: 0\"&gt;&lt;/div&gt; classSpecifies one or more classnames for an element (refers to a class in a style sheet). &lt;div class=\"button\"&gt;&lt;/div&gt; &lt;div class=\"button {{btnStatus}}\"&gt;&lt;/div&gt; repeatWe can use the repeat attribute to render a list of items based on an array. The repeat attribute has a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on. &lt;div repeat={{list}}&gt;&lt;/div&gt; &lt;div repeat={{item in list}}&gt;&lt;/div&gt; ifProvide a boolean value to decide whether or not to display current tag. &lt;div if=\"true\"&gt;&lt;/div&gt; &lt;div if=\"{{opened}}\"&gt;&lt;/div&gt; &lt;div if=\"{{direction === 'row'}}\"&gt;&lt;/div&gt; appendBy providing the value of tree or node, it determines the progress of rendering. &lt;div append=\"tree/node\"&gt;&lt;/div&gt; Event Handing (on…)Register event handlers on weex tag. &lt;div onclick=\"openDetail\"&gt;&lt;/div&gt; &lt;div onappear=\"{{loadMore}}\"&gt;&lt;/div&gt; Notes!Weex is basically following HTML attribute naming rule, so please do not use CamelCase in your attribute, kebab-case with “-“ as delimiter is much better.","type":"references"},{"title":"Component Definition","path":"v-0.10/references/component-defs.html","permalink":"https://weex.apache.org/v-0.10/references/component-defs.html","text":"Component DefinitionA component definition is a set of options to describe a component. It’s always assigned to module.exports in &lt;script&gt;. module.exports = &#123; // a set of options here&#125; Data &amp; Methods optionsmodule.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, methods: &#123; doThis: function () &#123;...&#125;, doThat: function () &#123;...&#125; &#125;, ...&#125; The data option is a function that return a observable data object for this ViewModel.The methods option is a map which contains all ViewModel methods. Each data or methods property will be proxied to the ViewModel instance. So you can read and write data with this.x, also you can call methods with this.doThis(...). A whole example: &lt;template&gt; &lt;div style=\"width: &#123;&#123;w&#125;&#125;; height: &#123;&#123;h&#125;&#125;; background-color: red;\" onclick=\"update\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;w: 750, h: 200&#125; &#125;, methods: &#123; update: function (e) &#123; this.h += 200 &#125; &#125; &#125;&lt;/script&gt; Events optionsmodule.exports = &#123; data: ..., methods: &#123; foo: function () &#123; ... this.$emit('customtype1', data) &#125; &#125;, events: &#123; customtype1: function (e) &#123; console.log(e.type, e.detail) &#125; &#125;, ...&#125; The events options could allow you to add custom event listeners when ViewModel created. Then it will listen these type of events and handle them by the function-type value. The first argument is a event object which contains event data in e.detail. Lifecycle optionsmodule.exports = &#123; data: ..., methods: ..., init: function () &#123; console.log('ViewModel constructor begins') &#125;, created: function () &#123; console.log('Data observation finished') &#125;, ready: function () &#123; console.log('Virtual DOM finished') &#125;, ...&#125; Weex ViewModel now supports these lifecycle hook functions which could be write as component options: init: fired at the beginning of a ViewModel constructor call. created: fired when ViewModel observes default data but not compile the template. ready: fired when ViewModel observes default data and compiles the template to generate virtual DOM finally. Note: If you want to use the function in methods, events or lifecycle options as a parameter, please make sure the context is correct as expect. For example: module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, ready: function () &#123; // `undefined` // because the context changed this.foo(this.bar) // `1` // because the context bound correct this.foo(this.bar.bind(this)) &#125;, methods: &#123; foo: function (fn) &#123; return fn() &#125;, bar: function () &#123; return this.x &#125; &#125;&#125;","type":"references"},{"title":"Gesture","path":"v-0.10/references/gesture.html","permalink":"https://weex.apache.org/v-0.10/references/gesture.html","text":"Gesture Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Just set on attributes on a node to listen to gesture. TypeFor now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. Swipe is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. PropertiesThe following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedToucheschangedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. ConstrainCurrently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting. How to useExample: &lt;template&gt;2&lt;div ontouchstart=\"handleTouchstart\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;2methods: &#123;22handleTouchstart: function(eventProperties) &#123;222// handling with the Event Properties22&#125;2&#125;&#125;&lt;/script&gt; With the code above, a touchstart event will be fired when a touch point is placed on the touch surface.","type":"references"},{"title":"Text Style","path":"v-0.10/references/text-style.html","permalink":"https://weex.apache.org/v-0.10/references/text-style.html","text":"Text Style0.5 Text alike components share some common style rules. The text alike components currently includes text and input. Properties color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weight: &lt;enum&gt; normal | bold. This property specifies the boldness of the font. Default value is normal. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"references"},{"title":"Special Element","path":"v-0.10/references/special-element.html","permalink":"https://weex.apache.org/v-0.10/references/special-element.html","text":"Special ElementContentThe element serves as content distribution outlet in a composed component template. The element itself will be replaced. alias: ‘slot’. ExampleAs shown in the example, ‘content’ replaced by ‘text’. &lt;we-element name=\"item\"&gt; &lt;template&gt; &lt;div&gt; &lt;content&gt;&lt;/content&gt; &lt;/div&gt; &lt;/template&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;item&gt; &lt;text&gt;Content Text&lt;/text&gt; &lt;/item&gt; &lt;/div&gt;&lt;/template&gt;","type":"references"},{"title":"使用 weex-toolkit","path":"cn/guide/tools/toolkit.html","permalink":"https://weex.apache.org/cn/guide/tools/toolkit.html","text":"weex-toolkitweex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 安装使用 npm 安装: $ npm install -g weex-toolkit 安装成功后，你输入 weex 应该可以看到下面的提示效果； 如果你本地没有安装 node.js 你可以前往官网下载安装。 *请确保你的 node 版本是&gt;=6，你可以使用 n 来进行 node 的版本管理。 中国用户如果npm遭遇网络问题，可以使用淘宝的 cnpm 镜像： $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 如果你安装的过程中遇到了问题，比如 permission error 你可以去 weex-toolkit issues 找到解决方法。 初始化 weex 项目$ weex init awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 然后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启静态服务器 debug: 调试模式 我们先通过 npm install 安装项目依赖。之后运行 npm run dev 和 npm run serve 开启 watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 Weex h5 页面。 实时预览weex-toolkit 支持预览你当前开发的weex页面(.we或者.vue)，你只需要指定预览的文件路径即可： $ weex src/foo.vue 浏览器会自动弹出页面，这个时候你可以看到你所编辑的 Weex页面的具体效果和页面布局。如果你使用 Playground 扫描右边的二维码，就能够看到 Weex 在 Android/IOS 设备上的效果了。 如果你需要预览整个项目目录，你可以输入这样的命令: $ weex src --entry src/foo.vue 你需要在传入的参数指定预览的目录和入口文件。 打包weex项目如果开发完成后，你可以使用 weex compile 通过命令行工具进行单个文件或者整个项目的打包。 weex compile src/foo.vue dist 命令行需要两个参数，你的源码文件或者目录， 以及你生成打包后的目录地址。 调试 Weex 页面weex-toolkit支持调试工具。weex devtools ，它是专门为Weex定制的一款实现了 Chrome Debugging Protocol 的 inspect/debug 工具，能够帮助你快速查看 app 运行状态和调试 Weex 中的 JS 代码，当前支持 IOS 和 Android 两个平台。 用法weex debug [options] [we_file|bundles_dir] 选项: -h, --help 显示帮助-V, --verbose 显示 debug 服务器运行时的各种 log-v, --version 显示版本-p, --port [port] 设置 debug 服务器端口号 默认为8088-e, --entry [entry] debug 一个目录时,这个参数指定整个目录的入口 bundle 文件,这个 bundle 文件的地址会显示在 debug 主页上(作为二维码)-m, --mode [mode] 设置构建 we 文件的方式，transformer 最基础的风格适合单文件， loader:webpack 风格 适合模块化的多文件 . 默认为 transformer 开启调试$ weex debug 单纯启动一个调试服务器，并同时唤起Chrome浏览器打开调试主页。这个调试主页上会有一个二维码，使用 Playground App 扫这个二维码可以开启 Playground 调试。开启调试后,设备列表中会出现您的设备，根据提示进行后续的调试操作。 调试 .we | .vue 文件$ weex debug your_weex.vue 这个命令会将 your_weex.vue 编译成 JS Bundle 文件 部署到 debug 服务器；并启动debug服务器如上述命令那样打开的调试vue主页会多显示一个二维码，使用 Playground App扫这个二维码码可以加载 your_weex.we (注意要先扫描开启调试的那个二维码码)。这个命令会自动检测 your_weex.we 文件变动，如果发现内容被修改则立即重新编译部署，并刷新 debugger 页面。. 调试整个bundle/we文件夹同样你也可以调试整个目录的文件，你只需要传入目录的路径和入口文件即可； $weex debug your/we/path -e index.we 这个命令会编译你指定目录下的所有的 .we 文件,并把编译好的 JS Bundle 部署到 debug 服务器,他们的地址会映射到 http://lcoalhost:8088/weex/ 下比如 your/we/path/index.we 可以通过 http://lcoalhost:8088/weex/index.js 访问。your/we/path/demo/test.we 可以通过 http://lcoalhost:8088/weex/demo/index.js 。 -e 参数可以指定一个入口的 .we 文件，这个文件的地址会显示在调试主页上(作为二维码)。 特性连接设备 Inspector Inspector 能够用来查看 Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View 等。 Element NetWork查看网络请求的总耗时和延时 查看网络请求的header和response 控制台 资源 Debugger 调试器用来调试 Weex 中的 JS 代码，能够设置断点、查看调用栈。 Breakpoint and CallStack 集成devtools Android 请参考文档 Weex devtools (Android)，其中有详细说明。 IOS 请参考文档 Weex devtools (iOS)， 其中有详细说明。 weex-toolkit 对 weexpack 的水平扩展weexpack 是基于 Weex 快速搭建应用原型的利器。它能够帮助开发者通过命令行创建 Weex 工程，添加相应平台的 Weex app 模版，并基于模版从本地，GitHub 或者 Weex 应用市场安装插件，快速打包 Weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建 Weex 插件模版并发布插件到 Weex 应用市场。 现在使用 weex-toolkit 同样支持对 weexpack 的命令调用,如果你当前的项目与 weexpack 生成的项目目录一致，那么你可以直接实现对于 platform 的操作，从而构建具体的 Android/IOS app 。 weex platform 以及 run 命令如果我们希望在模拟器或者真机上查看 Weex 运行的效果，我们可以使用 platform 添加或者删除 Weex 应用模板。 $ weex platform add ios 在第一次使用 platform/plugin 命令的时候，可能会遇到下面的界面，你只需要输入 Y 或者直接 enter 键即可。 添加ios平台，然后这个时候只要输入: $ weex run ios 就能看到启动的模拟器运行的效果了。 weex plugin 命令如果你想使用插件市场的插件，你可以使用： $ weex plugin add plugin_name 你只需要输入插件的名称就可以从远程添加插件到你本地的项目，比如添加 weex-chart，我们可以输入命令： $ weex plugin add weex-chart 我们可以使用plugin remove移除插件，比如移除安装好的 weex-cahrt： $ weex plugin remove weex-chart 关于 weexpack 更加详细的介绍，你可以阅读 官方文档。","type":"guide"},{"title":"用 Weex 构建移动应用","path":"cn/guide/intro/app-architecture.html","permalink":"https://weex.apache.org/cn/guide/intro/app-architecture.html","text":"用 Weex 构建移动应用今天的移动应用这里谈一谈 Weex 对移动应用的理解。 移动应用需要支撑并行研发如今移动应用的开发需要并行研发的能力，当一个移动应用发展到一定规模的时候，能否支撑大规模的并行研发就成为了一件非常关键而又重要的事情。否则很容易变成工程瓶颈。 移动应用需要动态性如今移动应用不论从研发节奏、部署的灵活性和时效性、包大小、还是从研发到发布再到反馈的迭代周期上，都和移动互联网的发展速度极不相符。移动应用需要更简单轻量的研发模型，需要摆脱版本部署和分发的笨重过程。 移动应用需要开放互联如今移动应用的内容和信息都是相互孤立的，应用之间的交流变得非常复杂和困难，也缺乏一定的标准和规范化的容器来承载。 整体结构设计我们认为一个具有高并行研发能力、动态化和标准化规范化的移动应用应该由以下几个方面构成： |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| 页面：首先移动应用应该可以被拆解成若干个页面，每个页面相对解耦独立，同时每个页面都有一个 URL 进行唯一标识。 路由：这些页面将会通过路由机制有机的串联起来，页面之间的关系是通过路由来进行调度的。常见的移动应用路由包括导航栏、tab 切换等。 设备能力：以各种 API 或服务的方式提供出来，供页面自由使用。 这样的话，在构建一个完整的移动应用之前，先确定你的应用有多少页面，每个页面分别是什么 URL，页面之间的关联和跳转逻辑是怎样的，然后梳理整个移动应用需要的所有 API 和服务。 然后通过 Weex 创建不同的页面，并分别进行开发、调试和发布。 相关链接 页面结构 如果你已经有一个做好的移动应用，只想用 Weex 开发其中的一部分页面甚至仅仅其中的一两个页面，这对 Weex 来说完全不是问题。Weex 只是一个 SDK，对整体的移动应用架构不会产生任何侵入性。并且完全可以和纯 native 界面或 hybrid 页面共存。 如果需要 WeexSDK 额外的组件、模块或其它功能，可以通过 Weex 的扩展机制进行扩展。这部分工作需要 native 的研发知识，但是随着 Weex 组件和模块的丰富以及业务迭代的深入，这部分成本会承下降和收敛的趋势。 相关链接 如何扩展 iOS 如何扩展 Android","type":"guide"},{"title":"工作原理","path":"cn/guide/intro/how-it-works.html","permalink":"https://weex.apache.org/cn/guide/intro/how-it-works.html","text":"工作原理整体架构Weex 表面上是一个客户端技术，但实际上它串联起了从本地开发环境到云端部署和分发的整个链路。开发者首先可以在本地像撰写 web 页面一样撰写一个 app 的页面，然后编译成一段 JavaScript 代码，形成 Weex 的一个 JS bundle；在云端，开发者可以把生成的 JS bundle 部署上去，然后通过网络请求或预下发的方式传递到用户的移动应用客户端；在移动应用客户端里，WeexSDK 会准备好一个 JavaScript 引擎，并且在用户打开一个 Weex 页面时执行相应的 JS bundle，并在执行过程中产生各种命令发送到 native 端进行的界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践；同时，如果用户没有安装移动应用，他仍然可以在浏览器里打开一个相同的 web 页面，这个页面是使用相同的页面源代码，通过浏览器里的 JavaScript 引擎运行起来的。 本地开发环境Weex 的本地开发环境基于 web 开发体验而设计，web 开发者可以通过自己熟悉的 HTML/CSS/JavaScript 技术和语法实现移动应用的界面。同时 Weex 也对 Vue.js 这一非常优秀的前端框架做了官方的支持。 除此之外，Weex 的工程设计也是 web 开发者非常熟悉的，首先 web 开发者可以使用自己熟悉的 npm 进行依赖管理；其次 web 开发者在通过项目脚手架初始化工程、开发、调试、质量控制等各个环节，都可以参考 web 开发已有的最佳实践。 和如今 web 开发的最佳实践一样，Weex 会把一个页面的源代码全部编译打包成一个 JS bundle，在浏览器中，我们需要把这个 JS bundle 作为一段 &lt;script&gt; 载入网页，在客户端里，我们把这段 JS bundle 载入本地，并通过 WeexSDK 直接执行。 相关阅读 Weex 和 web 平台的差异 Vue 2.x 在 Weex 和 web 中的差异 快速上手 使用 Devtools 云端部署和分发Weex 的 JS bundle 可以作为 web 开发中的一段静态资源进行部署和下发。几乎可以复用 HTML5 所有的工程体系和最佳实践。比如在本地开发环境通过部署工具将 JS bundle 部署到 CDN、通过 CMS 或搭建平台把业务数据和模块化的前端组件自动化拼接生成 JS bundle、通过服务端 JS bundle 的流量和日志统计页面的访问情况、通过 AppCache 或类似的方式对 JS bundle 在客户端进行缓存或预加载以降低网络通信的成本等。 客户端 JavaScript 引擎Weex 的 iOS 和 Android 客户端中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。我们在 iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核。无论是从性能还是稳定性方面都提供了强有力的保障。 为了让整个移动应用的资源利用得更好，我们在客户端提供的 JavaScript 引擎是单例的，即所有 JS bundle 公用一个 JavaScript 内核实例，同时对每个 JS bundle 在运行时进行了上下文的隔离，使得每个 JS bundle 都能够高效安全的工作。我们还把 Vue 2.0 这样的 JS Framework 做了预置，开发者不必把 JS Framework 打包在每个 JS bundle 里，从而大大减少了 JS bundle 的体积，也就进一步保障了页面打开的速度。 客户端渲染层Weex 目前提供了 iOS 和 Android 两个客户端的 native 渲染层。每个端都基于 DOM 模型设计并实现了标准的界面渲染接口供 JavaScript 引擎调用。并且结合 web 标准和 native 的特点和优势实现了一套统一的组件和模块。Weex 在性能方面的表现也是非常优异的，尤其是界面首屏加载时间、native 下长列表的资源开销和复用情况、CPU、内存、帧率 等关键指标。当然，尽管 Weex 官方已经提供了一组开发者最常用的组件和模块，但面对丰富多样的移动应用研发需求，团队也难免会力不从心，为此我们提供了灵活自由的横向扩展能力，开发者可以根据自身的情况定制属于自己的客户端组件和模块，进一步丰富 Weex 在客户端上的能力。 相关链接 Weex 的组件和模块跟 web 标准的区别 如何使用 iOS 如何使用 Android 如何扩展 iOS 如何扩展 Android 浏览器渲染Weex 除了提供 iOS 和 Android 的客户端渲染层之外，还基于 Vue 2.0 对官方的所有组件和模块进行了封装，开发者可以基于 Vue 2.0 用同一套源代码构建出在浏览器中相同效果的页面。并且同样可以横向扩展。 相关链接 如何使用 HTML5 如何扩展 HTML5","type":"guide"},{"title":"Weex 页面结构","path":"cn/guide/intro/page-architecture.html","permalink":"https://weex.apache.org/cn/guide/intro/page-architecture.html","text":"Weex 页面结构一个 Weex 页面就是一个相对独立解耦的移动应用界面，它不仅包括了界面展示、更包含了逻辑处理、设备能力使用、生命周期管理等部分。 界面DOM 模型Weex 页面通过类似 HTML DOM 的方式管理界面，首先页面会被分解为一个 DOM 树，，每个 DOM 结点都代表了一个相对独立的 native 视图的单元。然后不同的视图单元之间通过树形结构组合在了一起，构成一个完整的页面。 相关链接 Weex Native DOM APIs 组件Weex 支持文字、图片、视频等内容型组件，也支持 div、list、scroller 等容器型组件，还包括 slider、input、textarea、switch 等多种特殊的组件。Weex 的界面就是由这些组件以 DOM 树的方式构建出来的。 相关链接 Weex 组件列表 布局系统Weex 页面中的组件会按照一定的布局规范来进行排布，我们这里提供了 CSS 中的盒模型、flexbox 和 绝对/相对/固定/吸附布局这三大块布局模型。 盒模型：通过宽、高、边框、内外边距、边框等 CSS 属性描述一个组件本身的尺寸。 flexbox：通过 CSS 3 Flexbox 布局规范定义和描述组件之间的空间分布情况。 position：支持 CSS position 属性中的 absolute, relative, fixed, sticky 位置类型，其中 relative 是默认值。 功能Weex 提供了非常丰富的系统功能 API，包括弹出存储、网络、导航、弹对话框和 toast 等，开发者可以在 Weex 页面通过获取一个 native module 的方式引入并调用这些客户端功能 API。 相关链接 Weex 模块列表 生命周期每个 Weex 页面都有其自身的生命周期，页面从开始被创建到最后被销毁，会经历到整个过程。这是通过对 Weex 页面的创建和销毁，在路由中通过 SDK 自行定义并实现的。","type":"guide"},{"title":"使用 Vue 开发 Weex 页面","path":"cn/guide/intro/using-vue.html","permalink":"https://weex.apache.org/cn/guide/intro/using-vue.html","text":"使用 Vue 开发 Weex 页面Vue in WeexVue.js 是 Evan You 开发的渐进式 JavaScript 框架，在易用性、灵活性和性能等方面都非常优秀。开发者能够通过撰写 *.vue 文件，基于 &lt;template&gt;, &lt;style&gt;, &lt;script&gt; 快速构建组件化的 web 应用。 Vue.js 在 2016 年 10 月正式发布了 2.0 版本，该版本加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript；同时 Virtual-DOM 也使得 Vue 2.x 渲染成原生 UI 成为了可能。 目前 Weex 与 Vue 正在展开官方合作，并将 Vue 2.x 作为内置的前端框架，Vue 也因此具备了开发原生应用的能力。 相关链接 Weex 快速上手 Vue 介绍 Weex 工作原理 Vue 2.x 在 Weex 中的特色功能流式渲染在 Weex 中，我们可以通过 &lt;foo append=&quot;tree|node&quot;&gt; 的方式定义页面首次渲染时的渲染颗粒度，这让开发者有机会根据界面的复杂度和业务需求对首次渲染过程进行定制。append=&quot;tree&quot; 表示整个结点包括其所有子结点全部生成完毕之后，才会一次性渲染到界面上；而 append=&quot;node&quot; 则表示该结点会先渲染在界面上作为一个容器，其子结点会稍后做进一步渲染。 表单控件绑定在 Weex 中，我们针对 &lt;input&gt; 和 &lt;textarea&gt; 这两个表单控件提供了和 web 体验相同的 v-model 指令。通过 &lt;input v-model=&quot;message&quot;&gt; 或 &lt;textarea v-model=&quot;message&quot;&gt;，开发者可以把数据 message 的值自动展示在文本框上，同时用户修改了文本框的值的时候，数据 message 会自动被更新。 多页面上下文隔离如 Weex 工作原理文中所述，所有 Weex 的 JS bundle 公用一个 JavaScript 内核实例。所以如何能够让多个 JS bundle 中使用的 Vue 是完全隔离的，并且其中一个页面对 Vue 进行扩展或改写不会影响到其它页面就变成了一个问题，通过 Weex 和 Vue 双方的协作，这一问题已经得以解决。大家可以放心使用。 &lt;transition&gt; 过渡状态Weex 支持了 Vue 2.x 中经典的 &lt;transition&gt; 写法，开发者可以通过 &lt;transition&gt; 轻松定义一个界面在两种状态中的过渡方式。 注意事项Vue.js 最初是为 Web 设计的，虽然可以基于 Weex 开发移动应用，但是 Web 开发和原生开发毕竟不同，在功能和开发体验上都有一些差异，这些差异从本质上讲是原生开发平台和 Web 平台之间的差异，Weex 正在努力缩小这个差异的范围。 参考文章《Vue 2.x 在 Weex 和 Web 中的差异》了解存在差异的原因和细节。 使用其他 Vue 的工具库Vue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 关于 Vuex 和 vue-router 的使用方法，可以参考《在 Weex 项目中使用 Vuex 和 vue-router》。 我们基于 Weex 和 Vue 开发了一个的完整项目 weex-hackernews ，引入了包含 Vue 2.x 的 WeexSDK，创建了三端的项目和基本的编译配置。在项目中使用了 Vuex 和 vue-router ，能够实现同一份代码，在 iOS、Android、Web 下都能完整地工作。","type":"guide"},{"title":"Web 开发体验","path":"cn/guide/intro/web-dev-experience.html","permalink":"https://weex.apache.org/cn/guide/intro/web-dev-experience.html","text":"Web 开发体验什么是 Web 开发体验Weex 的开发体验和 web 的开发体验是非常接近的，它通过 HTML 或基于 HTML 模板来描述界面的结构和内容，通过 CSS 的方式描述界面的展现形式，用 JavaScript 来描述用户行为和业务逻辑。同时有完整的工程机制，如创建、开发、调试、部署。 为什么选择 Web 开发体验我们选择基于 Web 开发体验有以下几方面原因： 今天在技术社区有大量的 web 开发者，Weex 可以赋能更多的 web 开发者构建高性能和高体验的移动应用。 Web 开发本身具有非常强的高效率和灵活性，这和 Weex 想解决的移动端动态性问题不谋而合。 Web 标准和开发体验是很多顶尖而优秀的科技公司共同讨论和建设的结果，本身的设计和理念都有极高的品质保障，同时 Weex 也希望可以借此机会努力为标准贡献一点自己的微薄之力。 Web 是一种标准化的技术，标准本身就是一种力量，基于标准、尊重标准、贴近标准都意味着拥有更多的可能性。 Web 今天的生态和社区是非常繁荣的，有很多成熟的工具、库、工程体系、最佳实践可以使用、引入和借鉴。 Weex 对 Web 标准的支持情况怎么样？我们从以下几个方面进行介绍和梳理： HTML 标签：目前 Weex 支持了基本的容器 (div)、文本 (text)、图片 (image)、视频 (video) 等组件，HTML 中几乎所有的块级标签都可以通过容器组件进行自定义模拟，inline 的标签则可以通过文本组件进行自定义模拟，另外 Weex 还支持了 input/textarea 这样的表单型组件。 CSS：Weex 支持了部分常用的 CSS 属性、值类型和单位，并且会根据用户反馈和在 web 中的使用频度陆续支持更多。 JavaScript：目前 Weex 提供了一套简化版的 DOM APIs，用来操作原生界面，同时 Weex 在陆续支持更多的 W3C Device APIs。 在框架方面，Weex 官方支持了 Vue 2.0，以及相关的 vuex, vue-router 等，同时开发者可以直接使用各种第三方 JavaScript 工具库。 在工程方面，Weex 推荐 npm 包管理工具，也推荐用 webpack 进行 JS bundle 打包，并提供了 weex-devtool 开发工具，让开发者可以像调试 Chrome 一样调试 Weex 原生应用，同时 Weex 的页面发布系统、客户端缓存机制都尊重目前 Web 的最佳实践。 相关链接 Weex 和 web 标准的差异 使用 Vue.js 使用 Devtools","type":"guide"},{"title":"一次撰写，多端运行","path":"cn/guide/intro/write-once.html","permalink":"https://weex.apache.org/cn/guide/intro/write-once.html","text":"一次撰写，多端运行Weex 提供了多端一致的技术方案。 首先 web 开发体验在各端当中是相同的。包括语法设计和工程链路。 其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。 Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。 我们这样设计基于以下几点设想： 今天绝大多数的移动应用，虽然要同时出现在不同的移动操作系统平台上，但是要解决的问题和用户的需求是相同或非常接近的。Weex 希望提供的是一个快速直接统一描述业务的通用方式，为业务和产品需求直接服务。 针对各大操作系统平台差异的现状，我们倾向于通过以下两方面来解决这一问题 把不同端的样式和行为设计并描述成为相同的 API，这样上层的业务逻辑是同一份，但是在不同端上可以做到不一样的展现效果。 通过横向扩展的方式在不同的端上扩展不一样的功能、特性或表现形式。 各端不一致的业务描述也是难免的，我们通过提供更多更丰富的环境变量来帮助开发者在同一套代码里高效适配不同的设备场景。 我们相信标准和规范的力量 部分功能特性由于 native 特性的关系，会略有不同，我们会在相应的组件、模块、API 文档中做相应的描述和提示。","type":"guide"},{"title":"拓展 JS framework","path":"cn/references/advanced/extend-jsfm.html","permalink":"https://weex.apache.org/cn/references/advanced/extend-jsfm.html","text":"定制自己的 JS Framework这部分扩展能力还在讨论尝试中，可能随时会有调整，请留意。 Weex 希望能够尊重尽可能多的开发者的使用习惯，所以除了 Weex 官方支持的 Vue 2.0 之外，开发者还可以定制并横向扩展自己的或自己喜欢的 JS Framework。完整一套 JS Framework 的定制和扩展需要以下几个步骤： 首先你要有一套完整的 JS Framework。 了解 Weex 的 JS 引擎的特性支持情况。 适配 Weex 的 native DOM APIs。 适配 Weex 的初始化入口和多实例管理机制。 在 Weex JS runtime 的 framework 配置中加入自己的 JS Framework 然后打包。 基于该 JS Framework 撰写 JS bundle，并加入特定的前缀注释，以便 Weex JS runtime 能够正确识别。 Weex JS 引擎的特性支持情况 在 iOS 下，Weex 使用的是系统自带的 JavaScriptCore，所以 ES 支持情况取决于操作系统的版本。目前保守判断，ES5 的特性市面上主流的 iOS 设备都是可以完美支持的，但是 ES6+ 的特性存在一定的碎片化。 在 Android 下，Weex 使用的是 UC 提供的 v8 内核，出于体积、性能和稳定性的考虑，我们使用的并不是最新版本的 v8 内核，同样的保守判断，ES5 特性能够全部支持，包括严格模式、Object.freeze 等。 Weex JS 引擎不支持 HTML DOM APIs 和 HTML5 JS APIs，这包括 document, setTimeout 等。 在此基础上，我们加入了 Promise 的 polyfill，以及 console 的 polyfill。 额外的，为了尽可能的确保 JS 引擎的长效内存管理，我们对一个通用的全局对象进行了 Object.freeze() 冻结操作，这包括： Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype 适配 Weex 的初始化入口和多实例管理机制开发者提供的 JS Framework 最终需要包装成一个 CommonJS 包，并且这个包需要对外暴露以下方法： 框架初始化 init(config) config Document Element Comment TaskSender CallbackManager 该方法会把 Weex 提供的 Native DOM 类和两个辅助类放到 config 参数中，并允许框架本身完成初始化。 小提示：同时，框架作者也能够通过在框架初始化时传入不同的 config 来进行框架的测试或环境模拟。 参数格式介绍 TaskSender: wip… CallbackManager: wip… 注册可用的 native 组件和模块 registerComponents(components) registerModules(modules) 这两个方法会在框架初始化之后立刻调用，这样框架就能够知道当前的客户端支持哪些组件和模块，在一些特殊逻辑或必要的情况下，有机会为框架本身提供参考信息。 参数格式介绍 components: Array: 描述组件的数组，每一项包括： type: string: 组件名称，比如 div。 methods: string[]: 可选项，该组件支持的方法名称列表，这些方法可以遵循 Weex 的 native DOM APIs 的组件方法调用方式。 modules: Object: 描述一系列模块的散列表，每一项的 key 是模块名，每一项的值是一个数组，数组里的每一项描述了一个该模块中的一个方法，该方法的信息包括： name: string: 方法名 args: string[]: 参数个数和类型描述 例如： registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) 多实例生命周期管理 createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) 每个 Weex 页面都有被创建、被销毁两个必经阶段，同时在 Weex 页面运行过程中，native 有机会主动向 Weex 页面发送消息，不同的框架可以根据自己框架的设计对这样的消息有自己的理解和设计实现。 参数格式介绍 instanceId: string: 该 Weex 页面的唯一 id，由 native 产生。 code: string: 该 Weex 页面的 JS bundle 的代码，通过 native 传入。 config: Object?: 该 Weex 页面的配置信息，比如代表该 bundle 地址的 bundleUrl，由 native 配置产生，和 JS bundle 本身的内容无关。 data: Object?: Native 有机会在创建一个 Weex 页面的时候，传入一份外部数据，JS 框架也有机会接此机会为相同的 JS bundle 配合不同的 data 生成不同的页面内容。 env: Object?: 当前 Weex 页面的相关环境信息，各字段的含义： info: Object: 框架 info 信息，详见之后的 “JS Bundle 格式要求”。 config: Object: 等同该方法的第三个参数 config。 callbacks: CallbackManager: 该 Weex 页面唯一的 CallbackManager 实例。 created: number: 该 Weex 页面的创建时间毫秒数。 framework: string: 该 Weex 页面基于的框架名，等同于 info.framework。 Native 通信 receiveTasks(instanceId, tasks) Native 除了通过 refreshInstance 方法向 JS 框架层发送消息之外，更多的会通过 receiveTasks 发送用户事件或方法回调给 JS 框架。 比如用户点击了一个按钮，native 就会发送一个 fireEvent 类型的任务给 JS 框架，然后 JS 框架再处理相应的事件逻辑。这部分工作机制和 native DOM 接口中的 addEvent 的设计有关。 再比如用户发起了一个 fetch 网络请求，当请求在 native 端完成时，会以一个 callback 类型的任务发给 JS 框架。由于 native 无法传递 JavaScript 中的 function，所以实际上知会发送一个 callbackId 给 JS 框架。这部分工作机制和之前出现过的 CallbackManager 的设计有关。 辅助方法 getRoot(instanceId): JSON 该方法可以返回文档主体结点的完整 JSON 描述，开发者可以以此查看到完整的 native DOM 树，具体返回值的格式和 native DOM 接口中的 toJSON() 方法返回值格式一致。此功能多用作开发者工具扩展。 在 WeexSDK 中配置 JS Framework准备好你的 JS Framework 代码// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; 注册一个 JS Frameworkimport * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; 然后打包 JS runtime，集成到 WeexSDK 中。 JS Bundle 格式要求框架 info 你需要保障基于该 JS Framework 的 JS Bundle 在文件开头带有如下格式的注释，我们称其为框架 info： // &#123; \"framework\": \"Vue\" &#125;... 这样 Weex JS 引擎就会识别出这个 JS bundle 需要用 Vue 框架来解析。并分发给 Vue 框架处理。同理，Weex 支持同时多种框架在一个移动应用中共存并各自解析基于不同框架的 JS bundle。","type":"references"},{"title":"Android 扩展","path":"cn/references/advanced/extend-to-android.html","permalink":"https://weex.apache.org/cn/references/advanced/extend-to-android.html","text":"Android 扩展Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展 Module 扩展必须继承 WXModule 类。 扩展方法必须加上 @WXModuleAnno 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule &#123; @WXModuleAnno(runOnUIThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;点击我测试&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('myModule').printLog(\"我是一个测试!\"); &#125; &#125; &#125;&lt;/script&gt; 支持 synchronous/asynchronous 回调你可以添加 @JSMethod(uiThread = false或true) 注释来选择 moudle 的回调模式。请参见以下示例： // as sync-callback mode@JSMethod (uiThread = false)public void testSyncCall()&#123; WXLogUtils.d(\"WXComponentSyncTest : Thread.currentThread().getName());&#125;// as async-callback mode@JSMethod (uiThread = true)public void testAsyncCall()&#123; WXLogUtils.e(\"WXComponentASynTest : Thread.currentThread().getName() );&#125; Component 扩展 Component 扩展类必须集成 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richtext&quot;,RichText.class); 示例如下: public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; Adapter扩展图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; 组件方法支持从WeexSDK 0.9.5开始，你可以定义组件方法 在组件中如下声明一个组件方法 @JSMethodpublic void focus()&#123; //method implementation&#125; 注册组之后，你可以在weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39; SDK混淆规则若要在APP中使用混淆，请在相应的配置文件中添加如下规则： -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;","type":"references"},{"title":"HTML5 扩展","path":"cn/references/advanced/extend-to-html5.html","permalink":"https://weex.apache.org/cn/references/advanced/extend-to-html5.html","text":"如何扩展 Weex Web 端的组件和模块Weex 本身提供了很多内置组件和模块，也具备横向扩展的能力，允许开发者自行扩展和定制。需要注意的是，Weex 是一个跨平台的解决方案，扩展其内置组件或模块，需要在三端（Android、iOS、Web）中都有相应的实现。 Weex 将内核切换成 Vue 2.x 之后，在 Web 端扩展 Vue 组件将变得更加容易。 扩展 Web 组件Vue.js 本身就是一个独立的前端框架，在浏览器中完全能够不基于 Weex 容器渲染。因此，针对 Weex 平台扩展 Vue.js 的 Web 端组件，和直接使用 Vue.js 开发一个 Web 组件是一样的。具体的组件编写方法可以参考其官方文档：组件 ，另外建议使用 .vue 格式的文件编写组件，使用方法参考：单文件组件。 扩展组件示例以扩展 &lt;sidebar&gt; 为例，首先应该编写组件自身的逻辑： &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; 然后在使用之前，全局注册 &lt;sidebar&gt; 组件： import Vue from 'vue'import Sidebar from './path/to/sidebar.vue'// 全局注册 sidebar 组件Vue.component('sidebar', Sidebar) 在扩展 Weex 组件时，如果只使用了 Weex 提供的内置组件，并且使用的都是 Weex 支持的样式，那么就和普通的自定义组件无异，不需要 Native 端再有相应的实现。 如果你定制组件时不得不用到目前 Weex 不支持的标签和样式，在这种情况下才是真正的“扩展”了 Weex 的组件，你还需要在 Android 和 iOS 中有相应的实现，不然会导致渲染异常。 扩展 Web 模块除了通用组件以外，Weex 还有提供了通用的模块，可以方便的调用原生 API。通常来说，注册 Weex 模块要求三端都得有相应的实现，否则会影响其正常的使用。 注册模块如果你引入了 weex-vue-render 这个库，那么在全局能获取到 weex 这个变量，其中提供了 registerModule 方法可以注册模块。 API 格式 registerModule name: {String} 必选，模块名称。 define: {Object} 必选，模块的定义。 注册模块示例下边的代码注册了一个名为 guide 的模块： weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) 使用模块在 weex 上提供了 require 方法用于获取已注册的模块，直接传递模块名即可： // 获取模块const guide = weex.requireModule('guide')// 可以直接调用模块中的方法guide.greeting()guide.farewell() 上述写法在 Native 环境中依然有效，只不过模块中的方法是由 Native 提供的。","type":"references"},{"title":"iOS 扩展","path":"cn/references/advanced/extend-to-ios.html","permalink":"https://weex.apache.org/cn/references/advanced/extend-to-ios.html","text":"注意Weex 所有暴露给 JS 的内置 module 或 component API 都是安全和可控的， 它们不会去访问系统的私有 API ，也不会去做任何 runtime 上的 hack 更不会去改变应用原有的功能定位。 如果需要扩展自定义的 module 或者 component ，一定注意不要将 OC 的 runtime 暴露给 JS ， 不要将一些诸如 dlopen()， dlsym()， respondsToSelector:，performSelector:，method_exchangeImplementations() 的动态和不可控的方法暴露给JS， 也不要将系统的私有API暴露给JS Module 扩展swift 扩展 module Weex SDK 只提供渲染，而不是其他的能力，如果你需要 像网络，图片，URL跳转这些特性，需要自己动手实现他们例如，如果你想实现一个url地址跳转函数，你可以按照如下步骤实现一个 Module 自定义module的步骤 自定义的module类 必须实现 WXModuleProtocol 必须添加宏WX_EXPORT_METHOD, 它可以被weex识别，它的参数是 JavaScript调用 module指定方法的参数 添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上 Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行 Weex 的参数可以是 String 或者Map Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end 暴露同步方法v0.10+如果你想要暴露同步的native方法给JS， 即JS可以直接拿到Native的返回值。 你可以使用WX_EXPORT_METHOD_SYNC 宏。 native 代码: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString)) - (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js 代码: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" 除了string, 你也可以返回 number/array/dictionary 类型. 注意: 暴露的同步方法只能在 JS 线程执行，请不要做太多同步的工作导致JS执行阻塞。 注意: Vue 2.0 还未支持这个特性，最早会在 0.12 版本支持 注册 module通过调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; 使用自己的 module这里的 require 里面的 event 就是在 上一步调用 registerModule: 注册 module 时候的 name var eventModule = weex.requireModule('event'); eventModule.openURL('url',function(ret) &#123; nativeLog(ret);&#125;); Weex SDK 没有 图片下载，navigation 操作的能力，请大家自己实现这些 protocol WXImgLoaderProtocolweexSDK 没有图片下载的能力，需要实现 WXImgLoaderProtocol, 参考下面的例子 WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/*** @abstract Creates a image download handler with a given URL* @param imageUrl The URL of the image to download* @param imageFrame The frame of the image you want to set* @param options : The options to be used for this download* @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished.*/-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end 实现上述协议 @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end handler注册你可以通过WXSDKEngine 中的 registerHandler:withProtocol注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] Components 扩展虽然 WeexSDK 中有很多的 native 的 Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫 native 的组件，想包装一下，导入到 Weex 中，因此我们提供了让开发者实现自己的 native Component。下面将以 WeexSDK 中已经存在的 Component：image 为例子，介绍一下如何构建一个 native Component。假设你已经了解 iOS 开发 注册 Component注册一个 component 比较简单，调用 WXSDKEngine 中的 registerComponent:withClass: 方法，传入组件的标签名称，还有对应的 class 然后你可以创建一个 WXImageComponent 表示 image 组件的实现。在 .we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性现在我们要做一些让 image component 更加强大的事情。既然作为一个图片的 component，那它应该要有源，给他加上一个 src 的属性，同时给它加上一个 resize 的属性（可以配置的有 contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component 中所有的 style，attribute，events 都会被传递到 Component 的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute 中拿到的值的类型都是 id，我们可以用转换方法把它转换到任何值。Weex SDK 提供了一些基础的转换方法，可以参考 WXConvert 类，或者你可以添加自己的转换函数。 Hooking 渲染生命周期native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 在 image component 的例子里面，如果我们需要我们自己的 image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123;return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。作为一个 image component，我们需要拿到服务器图片，而且把它设置进 image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在 view 已经被创建而且加载了时候 Weex SDK 会调用到，而且 viewDidLoad 这个方法是你做额外初始化工作比如改变 content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变 image 的 src，也可以 hook updateAttributes: 方法来做属性更新操作，当 updateAttributes: 或者 updateStyles: 被调用的时候， component 的 view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 现在你可以用在任何 .we 文件里面使用 &lt;image&gt;，而且可以加上 image 的属性。 &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; component 方法WeexSDK 0.9.5 之后支持了在 js 中直接调用 component 的方法，这里提供一个例子 自定义一个 WXMyCompoenent 的组件 @implementation WXMyComponentWX_EXPORT_METHOD(@selector(focus)) // 暴露该方法给js- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self;&#125;- (void)focus&#123; NSLog(@&quot;you got it&quot;);&#125;@end 注册组件 [WXSDKEngine registerComponent:@&quot;mycomponent&quot; withClass:[WXMyComponent class]] 在 weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"集成 Devtools 到 Android","path":"cn/references/advanced/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/cn/references/advanced/integrate-devtool-to-android.html","text":"集成 Devtools 到 AndroidWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入添加依赖可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:$&#123;version&#125;'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容 weex sdk weex inspector Debugger Server 0.13+ 0.12+ 0.2.39+ 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 添加 Debug 模式开关控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用`WXSDKEngine.reload()。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含 DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试前置工作如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get Started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识Devtools 组件介绍Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。 注入自定义WebSocket Client目前Inspector以反射的方式动态调用了okhttp-ws库中的相关代码，可以兼容的okhttp与okhttp-ws版本为： okhttp, okhttp-ws 2.7.5版本以下 okhttp3, okhttp3-ws 3.5版本以下 如果客户端中集成的版本与上述版本不匹配，则可以使用WeexInspector.overrideWebSocketClient方法来注入自定义的WebSocket实现，示例：public class CustomWebSocketClient implements IWebSocketClient &#123; private WebSocket ws; @Override public boolean isOpen() &#123; return ws != null; &#125; @Override public void connect(String wsAddress, final WSListener listener) &#123; OkHttpClient okHttpClient = new OkHttpClient(); okHttpClient.setConnectTimeout(5, TimeUnit.SECONDS); okHttpClient.setReadTimeout(5, TimeUnit.SECONDS); okHttpClient.setWriteTimeout(5, TimeUnit.SECONDS); Request request = new Request.Builder().url(wsAddress).build(); WebSocketCall webSocketCall = WebSocketCall.create(okHttpClient, request); webSocketCall.enqueue(new WebSocketListener() &#123; @Override public void onOpen(WebSocket webSocket, Request request, Response response) throws IOException &#123; ws = webSocket; listener.onOpen(); &#125; @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException &#123; if (WebSocket.PayloadType.TEXT == type) &#123; listener.onMessage(payload.readUtf8()); &#125; &#125; @Override public void onPong(Buffer payload) &#123; //ignore &#125; @Override public void onClose(int code, String reason) &#123; listener.onClose(); &#125; @Override public void onFailure(IOException e) &#123; listener.onFailure(e); &#125; &#125;); &#125; @Override public void close() &#123; if (ws != null) &#123; try &#123; ws.close(CloseCodes.NORMAL_CLOSURE, \"Normal closure\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void sendMessage(int requestId, String message) &#123; if (ws != null) &#123; try &#123; ws.sendMessage(WebSocket.PayloadType.TEXT, new Buffer().writeString(message, Charset.defaultCharset())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","type":"references"},{"title":"集成 Devtools 到 iOS","path":"cn/references/advanced/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/cn/references/advanced/integrate-devtool-to-ios.html","text":"集成 Devtools 到 iOSWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入添加依赖方法一：cocoapods 依赖在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， 目前有如下几个版本： 0.7.0, 0.6.1, 0.1.1, 0.1.0 [master repo] 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 推荐在DEBUG模式下依赖。 方法二：github 源码依赖 拉取最新的WXDevtool代码。 按照如下图示：直接拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网 App 研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能如果按照方法一接入：podfile 的方式，添加头文件包含： #import &lt;TBWXDevtool/WXDevtool.h&gt; 如果按照方法二接入：源码依赖的方式，添加头文件包含： #import &quot;WXDevtool.h&quot;``` 查看 WXDevtool 头文件如下： ```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */ + (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end``` `setDebug`：参数为 `YES` 时，直接开启 debug 模式，反之关闭，使用场景如下所述在你自己的程序中添加如下代码：```object-c [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能 为什么需要页面刷新功能？ 如下图所示，当点击 debugger 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debugger 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 具体实现可参考 playground WXDemoViewController.m 文件 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 使用如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 日志级别控制 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0, Error = ErrorWarning = Error | Warning,Info = Warning | Info,Log = Log | Info,Debug = Log | Debug, All = NSUIntegerMax 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"references"},{"title":"<a>","path":"cn/references/components/a.html","permalink":"https://weex.apache.org/cn/references/components/a.html","text":"&lt;a&gt;&lt;a&gt; 组件定义了指向某个页面的一个超链接. 此组件的作用和用法与HTML5中的 &lt;a&gt; 非常类似，区别在于 Weex 的 &lt;a&gt; 组件不能直接在里面添加文本（字符串），如果要展示文本，应该添加 &lt;text&gt; 组件。 子组件此组件支持除了自己外的所有 Weex 组件作为子组件。 特性 href {string}：定义了超链接的 URL。 样式&lt;a&gt; 支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式。 事件&lt;a&gt; 支持所有通用事件。 click注意：我们不能保证 click 事件和 href 跳转的执行顺序。建议不要使用 click 事件来处理 href 跳转前的逻辑处理。 longpress appear disappear 查看 通用事件。 约束 不能直接在 &lt;a&gt; 中添加文本。 请不要为 &lt;a&gt; 添加 click 事件。我们不能确保 click 事件和 href 跳转的执行顺序。 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a class=\"button\" href=\"http://dotwe.org/raw/dist/3e0e40f9ddad79f98cd236753965ffd8.js\"&gt; &lt;text class=\"text\"&gt;Jump&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; width: 450px; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5 &#125; .text &#123; font-size: 60px; color: #666666; text-align: center; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<cell>","path":"cn/references/components/cell.html","permalink":"https://weex.apache.org/cn/references/components/cell.html","text":"&lt;cell&gt;用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; 组件的子组件, 这是为了优化滚动时的性能。 子组件支持所有 Weex 的组件作为它的子组件。 属性 keep-scroll-position {boolean}: v0.11+ List 插入数据后是否保持上次滚动的位置 样式注意： 由于 &lt;cell&gt; 本身是一个容器，其布局由 &lt;list&gt; 进行管理，你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应，指定 margin 样式也不起作用。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<div>","path":"cn/references/components/div.html","permalink":"https://weex.apache.org/cn/references/components/div.html","text":"&lt;div&gt;&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70px; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 在 native 中不可滚动，即使显式设置高度也一样。 错误示例 示例&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<image>","path":"cn/references/components/image.html","permalink":"https://weex.apache.org/cn/references/components/image.html","text":"&lt;image&gt;&lt;image&gt; 组件用于渲染图片，并且它不能包含任何子组件。新版 Vue 2.0 中不支持用 &lt;img&gt; 作简写。 需要注意的是，需要明确指定 width 和 height，否则图片无法显示。 简单例子： &lt;template&gt; &lt;div&gt; &lt;image style=\"width: 560px;height: 560px;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 子组件&lt;image&gt; 组件不支持任何子组件，因此不要尝试在 &lt;image&gt; 组件中添加任何组件。如果需要实现 background-image 的效果，可以使用 &lt;image&gt; 组件和 position 定位来现实，如下面代码。 &lt;template&gt; &lt;div&gt; &lt;image style=\"width:750px; height:750px;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/image&gt; &lt;div class=\"title\"&gt; &lt;text style=\"font-size:50px; color: #ff0000\"&gt;你好，image&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .title&#123; position:absolute; top:50; left:10; &#125;&lt;/style&gt; 体验一下 特性&lt;image&gt; 组件，包含 src 和 resize 两个重要特性。 src {string}：定义图片链接，目前图片暂不支持本地图片。 resize {string}：可以控制图片的拉伸状态，值行为和 W3C 标准一致。 可选值为： stretch：默认值，指定图片按照容器拉伸，有可能使图片产生形变。 cover：指定图片可以被调整到容器，以使图片完全覆盖背景区域，图片有可能被剪裁。 contain：指定可以不用考虑容器的大小，把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 例子： placeholder: v0.9+ &lt;string&gt; 当源图片下载中时显示一张占位图。 体验一下 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 load: v0.8+：当图片加载完成时触发。目前在 Android、iOS 上支持，H5 暂不支持。示例 事件对象 success: 当图片成功加载时为true，否则为false size: 图片的原始尺寸，包含两个参数：naturalWidth 代表图片的原始宽度像素值，naturalHeight 代表图片的原始高度值。这两个参数的默认值都为0 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 需要指定宽高； 不支持子组件。 示例&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .page-head &#123; width: 750px; height: 200px; &#125; .title-bg &#123; width: 750px; height: 200px; &#125; .title-box &#123; width: 750px; height: 200px; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32px; font-weight: bold; &#125; .article &#123; padding: 20px; &#125; .paragraph&#123; margin-bottom: 15px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<input>","path":"cn/references/components/input.html","permalink":"https://weex.apache.org/cn/references/components/input.html","text":"&lt;input&gt;Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 &lt;text&gt;， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 &lt;input&gt; 或 change 来代替 click 事件。 子组件不支持子组件。 特性 type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，password，url，email，tel ，number 。每个 type 值都符合 W3C 标准。 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 return-key-type {string}：v0.11键盘返回键的类型,支持 defalut;go;next;search;send,done。 样式 placeholder-color {color}：placeholder 字符颜色。默认值是 #999999 伪类v0.9.5+: input 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 return: 键盘点击返回键。 事件中 event 对象属性： returnKeyType: 事件发生时的返回键类型。 value: 触发事件的组件的文本； 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 Methods focus() v0.9+ focus() 方法用于将 input 组件聚焦。 blur() v0.9+ blur() 方法用于从 input 组件中移除焦点并关闭软键盘（如果它具有焦点）。 setSelectionRange(selectionStart,selectionEnd) v0.11+设置文本选区 selectionStart {number}：设置文本选区的起始点 selectionEnd {number}：设置文本选区的起终点 getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+设置文本选区 selectionStart {number}：获取文本选区的起始点 selectionEnd {number}：获取文本选区的起终点约束 目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<list>","path":"cn/references/components/list.html","permalink":"https://weex.apache.org/cn/references/components/list.html","text":"&lt;list&gt;&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 子组件&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 特性 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 体验一下 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 约束 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<indicator>","path":"cn/references/components/indicator.html","permalink":"https://weex.apache.org/cn/references/components/indicator.html","text":"&lt;indicator&gt;&lt;indicator&gt; 组件用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件&lt;indicator&gt; 组件没有任何子组件。 样式&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：设置项的颜色，可以是颜色的名称，例如 red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-selected-color {color}：被选中时的颜色，可以是颜色的名称，red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-size {number}：元素的个数。 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束 不支持子组件。 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"4500\" @change=\"onchange\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;img.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .title &#123; position: absolute; top: 20px; left: 20px; padding-left: 20px; width: 200px; color: #FFFFFF; font-size: 36px; line-height: 60px; background-color: rgba(0, 0, 0, 0.3); &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125; .indicator &#123; width: 700px; height: 700px; item-color: green; item-selected-color: red; item-size: 50px; position: absolute; top: 200px; left: 200px; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; title: 'item A', src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item B', src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item C', src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;, methods: &#123; onchange (event) &#123; console.log('changed:', event.index) &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<loading>","path":"cn/references/components/loading.html","permalink":"https://weex.apache.org/cn/references/components/loading.html","text":"&lt;loading&gt;v0.6.1+ &lt;loading&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供上拉加载功能。用法与特性与 &lt;refresh&gt; 类似， 是 &lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loading：加载时被触发。 约束 &lt;loading&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 如果需要 &lt;loading&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 loading 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;loading class=\"loading\" @loading=\"onloading\" :display=\"showLoading\"&gt; &lt;text class=\"indicator\"&gt;Loading ...&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; showLoading: 'hide', lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onloading (event) &#123; modal.toast(&#123; message: 'loading', duration: 1 &#125;) this.showLoading = 'show' setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; this.showLoading = 'hide' &#125;, 1500) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125; .loading &#123; justify-content: center; &#125; .indicator &#123; color: #888888; font-size: 42px; padding-top: 20px; padding-bottom: 20px; text-align: center; &#125;&lt;/style&gt; Try it","type":"references"},{"title":"<refresh>","path":"cn/references/components/refresh.html","permalink":"https://weex.apache.org/cn/references/components/refresh.html","text":"&lt;refresh&gt;v0.6.1+ &lt;refresh&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供下拉加载功能。用法与特性与 &lt;loading&gt; 类似，&lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，&lt;refresh&gt; 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 refresh： 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发。 pullingdownv0.6.1+: 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发，可以从事件的参数对象中获取 dy,pullingDistance, viewHeight, type dy: 前后两次回调滑动距离的差值pullingDistance: 下拉的距离viewHeight: refreshView 高度type: &quot;pullingdown&quot; 常数字符串 约束 &lt;refresh&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，refresh 事件仍会被触发。 如果需要 &lt;refresh&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 refresh 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;refresh class=\"refresh\" @refresh=\"onrefresh\" @pullingdown=\"onpullingdown\" :display=\"refreshing ? 'show' : 'hide'\"&gt; &lt;text class=\"indicator\"&gt;Refreshing ...&lt;/text&gt; &lt;/refresh&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; refreshing: false, lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onrefresh (event) &#123; console.log('is refreshing') modal.toast(&#123; message: 'refresh', duration: 1 &#125;) this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, onpullingdown (event) &#123; console.log('is onpulling down') modal.toast(&#123; message: 'pulling down', duration: 1 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .indicator &#123; color: #888888; font-size: 42px; text-align: center; &#125; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<slider>","path":"cn/references/components/slider.html","permalink":"https://weex.apache.org/cn/references/components/slider.html","text":"&lt;slider&gt;&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性 auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 infinite {boolean}：循环播放，可选值为 true/false，默认的是 true。 offset-x-accuracy {number}0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间Slider Page至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。体验一下事件中 event 对象属性： offsetXRatio {number}：表示当前页面的偏移比例，取值范围为[-1, 1]，负值表示向左侧滚动，正值向右。例如，-0.2表示当前item有20%的区域被滚动到slider左侧边界以外，0.3表示当前item有30%的区域被滚动到slider右侧边界以外。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<switch>","path":"cn/references/components/switch.html","permalink":"https://weex.apache.org/cn/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ &lt;switch&gt; 是 Weex 的内置组件，用来创建与 iOS 一致样式的按钮。例如，在 iPhone 中的设置应用中的飞行模式按钮就是一个 switch 按钮。 子组件&lt;switch&gt; 组件不支持任何子组件。 特性 checked {boolean}：默认值为 false，表明按钮是否开启 is on or not. disabled {boolean}：默认值为 false，表明是否激活按钮 样式值得注意的是，在这个组件上，有些样式组件属性不能使用，它们是： width height min-width min-height margin padding border 注意： 如果 &lt;switch&gt; 的容器没有设置为 align-items：flex-start，则 Android 中的开关将被拉伸。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;normal&lt;/text&gt; &lt;switch&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;checked&lt;/text&gt; &lt;switch checked=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;disabled&lt;/text&gt; &lt;switch disabled=\"true\" checked=\"true\"&gt;&lt;/switch&gt; &lt;switch disabled=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;onchange&lt;/text&gt; &lt;switch @change=\"onchange\"&gt;&lt;/switch&gt; &lt;text class=\"info\"&gt;&#123;&#123;checked&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; checked: false &#125; &#125;, methods: &#123; onchange (event) &#123; console.log(`onchage, value: $&#123;event.value&#125;`) this.checked = event.value &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .example &#123; flex-direction: row; justify-content: flex-start; margin-top: 60px; &#125; .label &#123; font-size: 40px; line-height: 60px; width: 350px; color: #666; text-align: right; margin-right: 20px; &#125; .info &#123; font-size: 30px; line-height: 60px; color: #BBB; margin-left: 10px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<waterfall>","path":"cn/references/components/waterfall.html","permalink":"https://weex.apache.org/cn/references/components/waterfall.html","text":"waterfallv0.11.0+ 提供瀑布流布局的组件 子组件注意: 和list一样, waterfall 只支持特定类型的组件: cell, header, refresh, loading 和 fixed-position 组件. cell: 瀑布流中的每个元素 header: 主要用于表示横跨多列的元素，可以通过css的position属性设置为sticky 特性 column-width : 描述瀑布流每一列的列宽 auto: 意味着列宽是被其他属性所决定的(比如 column-count) &lt;length&gt;: 最佳列宽，实际的列宽可能会更宽(需要填充剩余的空间)， 或者更窄(如果剩余空间比列宽还要小)。 该值必须大于0 column-count: 描述瀑布流的列数 auto: 意味着列数是被其他属性所决定的(比如 column-width) &lt;integer&gt;: 最佳列数，column-width 和 column-count 都指定非0值， 则 column-count 代表最大列数。 column-gap: 列与列的间隙. 如果指定了 normal ，则对应 32. 其他支持的属性参见 List Component Attributes 样式通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 API滚动到列表某个指定项是常见需求，&lt;waterfall&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt; 或者 &lt;header&gt;。通过 dom module 访问，更多信息可参考 dom module 。 示例参见 playground waterfall example","type":"references"},{"title":"<scroller>","path":"cn/references/components/scroller.html","permalink":"https://weex.apache.org/cn/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性 show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 scroll-direction定义了 scroller 的滚动方向，flex-direction 定义了 scroller 的布局方向，两个方向必须一致。 scroll-direction 的默认值是 vertical, flex-direction 的默认值是 row。 当需要一个水平方向的 scroller 时，使用 scroll-direction:horizontal 和 flex-direction: row。 当需要一个竖直方向的 scroller 时，使用 scroll-direction:vertical 和 flex-direction: column。由于这两个值均是默认值，当需要一个竖直方向的 scroller 时，这两个值可以不设置。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 该属性已废弃，请使用resetLoadmore()函数实现重置loadmore的操作。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 参见 scroll event demo。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 约束不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<text>","path":"cn/references/components/text.html","permalink":"https://weex.apache.org/cn/references/components/text.html","text":"&lt;text&gt;&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 子组件此组件不支持子组件。 特性 value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式 lines {number}: 指定文本行数。默认值是 0 代表不限制行数。 text styles: 查看 文本样式 支持 color 样式. 支持 font-size 样式. iOS默认值：32，Android：不同设备不同，H5 默认值：32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 。line-height 在 iOS 中与 H5 和 Android 中不同， 文本值将放置在框的底部。 不支持 flex-direction, justify-content, align-items 这些为子节点设置的属性，并且&lt;text&gt;没有子节点。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 iconfont支持版本:v0.12.0 支持ttf和woff字体格式的自定义字体, 可以通过调用 dom module 里面的 addRule方法, 构建自定义的font-family使用 &lt;template&gt; &lt;div style='flex-direction:row;margin-top:50px'&gt; &lt;text style='font-family:iconfont4;font-size:50;color:green'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:50;'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&amp;#xe61d;&amp;#xe714;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:blue'&gt;&amp;#xe711;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:green'&gt;&amp;#xe71c;&amp;#xe60b;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; mounted: function() &#123; var domModule = weex.requireModule('dom'); //目前支持ttf、woff文件，不支持svg、eot类型,moreItem at http://www.iconfont.cn/ domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\" &#125;); &#125;&#125;&lt;/script&gt; try it 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex 是一套简单易用的跨平台开发方案，能以 Web 的开发体验构建高性能、可扩展的原生应用。Vue 是一个轻量并且功能强大的渐进式前端框架。&lt;/text&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex is an cross-platform development solution that builds high-performance, scalable native applications with a Web development experience. Vue is a lightweight and powerful progressive front-end framework. &lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .panel &#123; width: 600px; margin-left: 75px; border-width: 2px; border-style: solid; border-color: #BBB; padding-top: 15px; padding-bottom: 15px; padding-left: 15px; padding-right: 15px; margin-bottom: 30px; &#125; .text &#123; lines: 3; color: #666666; font-size: 32px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<web>","path":"cn/references/components/web.html","permalink":"https://weex.apache.org/cn/references/components/web.html","text":"&lt;web&gt;v0.5+ 使用 &lt;web&gt; 组件在 Weex 页面中嵌入一张网页内容。src 属性用来指定资源地址。你也可以使用 webview module 来控制 web 的行为，比如前进、后退和重载。可以在这里查看 webview module。 子组件不支持子组件。 特性 src {string}：此特性指定嵌入的 web 页面 url。 样式 通用样式：不支持部分盒模型样式，支持列表如下： width 组件的宽度，默认值是0。这个样式定义必须指定数值。 height 组件的高度，默认值是0。这个样式定义必须指定数值。 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 pagestart: &lt;web&gt; 组件开始加载时发送此事件消息。 pagefinish: &lt;web&gt; 组件完成加载时发送此事件消息。 error: \b如果 &lt;web&gt; 组件加载出现错误，会发送此事件消息。 通用事件 支持以下通用事件： appear disappear 查看 通用事件 注意： 不支持 click 事件。 示例我们用一个简易浏览器示例，来展示如何使用 &lt;web&gt; 组件和 webview module。 查看 webview module。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<textarea>","path":"cn/references/components/textarea.html","permalink":"https://weex.apache.org/cn/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件textarea 组件不支持子组件。 特性 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：表示是否在页面加载时控件自动获得输入焦点。 rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式 伪类v0.9.5+: textarea 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"cn/references/components/video.html","permalink":"https://weex.apache.org/cn/references/components/video.html","text":"&lt;video&gt;v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件 &lt;text&gt; 是唯一合法的子组件。 特性 src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"Weex 和 Vue 2.x 的语法差异","path":"cn/references/migration/difference.html","permalink":"https://weex.apache.org/cn/references/migration/difference.html","text":"Weex 和 Vue 2.x 的语法差异Overview Weex Vue 生命周期 ready: function() {} mounted: function() {} 条件指令 if=&quot;{{!foo}}&quot; v-if=&quot;!foo&quot; 循环指令 repeat=&quot;{{item in list}}&quot; v-for=&quot;item in list&quot; 样式类名 class=&quot;btn btn-{{type}}&quot; :class=&quot;[&#39;btn&#39;, &#39;btn-&#39; + type]&quot; 内联样式 style=&quot;color:{{textColor}}&quot; :style=&quot;{ color: textColor }&quot; 事件绑定 onclick=&quot;handler&quot; @click=&quot;handler&quot; 原生事件 onclick=&quot;xxx&quot; @click.native=&quot;xxx&quot; 数据绑定 src=&quot;{{rightItemSrc}}&quot; :src=&quot;rightItemSrc&quot; 内容/槽 &lt;content&gt;&lt;/content&gt; &lt;slot&gt;&lt;/slot&gt; 数据初始化 data: { value: &#39;x&#39; } data: function() { return { value: &#39;x&#39; } } 标签 ID id=&quot;xxx&quot; ref=&quot;xxx&quot; 获取节点 this.$el(&#39;xxx&#39;) this.$refs.xxx ReferenceSee the source code of weex-vue-migration for more details: template-rewriter script-rewriter LifeCycle Hooks 生命周期钩子 weex vue Description init beforeCreate 组件实例刚刚被创建，组件属性如data计算之前 created created 组件实例创建完成，属性已绑定，但DOM还未生成 beforeMount 模板编译/挂载之前 ready mounted 模板编译/挂载之后 beforeUpdate 组件更新之前 updated 组件更新之后 activated forkeep-alive, 组件被激活时调用 deactivated forkeep-alive, 组件被移除时调用 beforeDestroy 组件被销毁前调用 destroyed destroyed 组件被销毁后调用 Data Binding 数据绑定在weex中，使用{{…}}在&lt;template&gt;中绑定在&lt;script&gt;里定义的数据；在vue中，需要在要绑定的属性前加 : 。如以下示例。 类名 weex &lt;div class=\"btn btn-&#123;&#123;type&#125;&#125;\"&gt;&lt;/div&gt; vue &lt;div :class=\"['btn', 'btn-' + type]\"&gt;&lt;/div&gt; 样式绑定 weex &lt;div style=\"color:&#123;&#123;textColor&#125;&#125;\"&gt;&lt;/div&gt; vue &lt;div :style=\"&#123;color: textColor&#125;\"&gt;&lt;/div&gt; if指令 weex &lt;image src=\"...\" if=\"&#123;&#123;shown&#125;&#125;\"&gt;&lt;/image&gt; or &lt;image src=\"...\" if=\"shown\"&gt;&lt;/image&gt; vue &lt;image src=\"...\" v-if=\"shown\"&gt;&lt;/image&gt; 循环指令 weex: repeat $index为索引 &lt;div repeat=\"&#123;&#123;list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;&lt;/text&gt;&lt;div&gt; or &lt;div repeat=\"&#123;&#123;v in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;, &#123;&#123;v.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; 对象参数的顺序 &lt;div repeat=\"&#123;&#123;(key, value) in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;key + 1&#125;&#125;, &#123;&#123;value.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; track-by &lt;div repeat=\"&#123;&#123;item in items&#125;&#125;\" track-by=\"item.id\" class=\"&#123;&#123;gender&#125;&#125;\"&gt;&lt;/div&gt; vue: v-for 移除$index索引 对象参数的改变：改为(value, key), 与通用的对象迭代器保持一致 &lt;div repeat=\"&#123;&#123;(value, key) in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;key + 1&#125;&#125;, &#123;&#123;value.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; track-by 替换为v-bind &lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; 初始化数据 weex data: &#123; value: 'x' &#125; vue props: &#123; value: &#123; default: 'x' &#125; &#125; 动态数据 data: function () &#123; return &#123; value: 'x' &#125; &#125; 围绕DOM的实例方法 获取节点 weex: this.$el(&#39;xxx&#39;) &lt;template&gt; &lt;container&gt; &lt;text id=\"top\"&gt;Top&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; methods: &#123; toTop: function () &#123; var top = this.$el('top') &#125; &#125;&#125;&lt;/script&gt; vue this.$refs.xxx ​ 事件 事件绑定 weex &lt;div onclick=\"handler\"&gt;&lt;/div&gt; vue &lt;div @click=\"handler\"&gt;&lt;/div&gt; 事件触发 weex: dispatch和broadcast this.$dispatch() this.$broadcast() vue: emit this.$emit() 注：Weex 的 $dispatch 与组件无关，在任意组件中都可以通过 $on 捕获到，Vue 的$emit 用于触发组件(标签)的自定义事件。 原生事件 weex onclick=\"xxx\" vue @click.native=\"xxx\"","type":"references"},{"title":"如何将原有 Weex 项目改造成 Vue 版本","path":"cn/references/migration/migration-from-weex.html","permalink":"https://weex.apache.org/cn/references/migration/migration-from-weex.html","text":"如何将原有 Weex 项目改造成 Vue 版本Weex 本身有一套语法规则，和 Vue 本身很相似，现在 Weex 与 Vue 有了官方合作，支持将 Vue 2.x 作为内置的前端框架，我们也推荐大家使用 Vue 2.x 的语法开发原生应用。对于现存旧版的 .we 文件，建议大家将其改造成 Vue 版本。 要解决的问题 将内核切换成 Vue 之后，原先基于 Weex 语法开发的项目将如何过渡到 Vue ？ 首先需要明确一点：Weex 原有的前端框架也会继续存在于 WeexSDK 中，依然支持 .we 文件格式的写法。 此外，由于 .we 和 .vue 文件的格式本身就比较接近，所以迁移成本比较小，建议大家将现有 .we 格式的文件都转换成 .vue 格式。我们也推出了相应的工具和方法辅助迁移，在内部也有大量的成功实践，下边将重点介绍一下将 .we 文件转成 .vue 文件的方法。 第一步，借助工具实现语法转换首先介绍一个工具： weex-vue-migration ，它可以自动将 .we 文件转为 .vue 文件，绝大多数的模板语法都能自动转换，语法差异如下： Weex Vue 生命周期 ready: function() {} mounted: function() {} 条件指令 if=&quot;{{!foo}}&quot; v-if=&quot;!foo&quot; 循环指令 repeat=&quot;{{item in list}}&quot; v-for=&quot;item in list&quot; 样式类名 class=&quot;btn btn-{{type}}&quot; :class=&quot;[&#39;btn&#39;, &#39;btn-&#39; + type]&quot; 内联样式 style=&quot;color:{{textColor}}&quot; :style=&quot;{ color: textColor }&quot; 事件绑定 onclick=&quot;handler&quot; @click=&quot;handler&quot; 原生事件 onclick=&quot;xxx&quot; @click.native=&quot;xxx&quot; 数据绑定 src=&quot;{{rightItemSrc}}&quot; :src=&quot;rightItemSrc&quot; 内容/槽 &lt;content&gt;&lt;/content&gt; &lt;slot&gt;&lt;/slot&gt; 数据初始化 data: { value: &#39;x&#39; } data: function() { return { value: &#39;x&#39; } } 标签 ID id=&quot;xxx&quot; ref=&quot;xxx&quot; 获取节点 this.$el(&#39;xxx&#39;) this.$refs.xxx 想要了解更多语法差异的细节，可以参考这篇文章：《Weex 和 Vue 2.x 的语法差异》 。 使用方法首先安装工具： npm install weex-vue-migration -g 转换文件： weex-vue-migrate demo.we 转换成功后，将会在当前目录下生成 demo.vue 文件，控制台将会有如下输出： [Success]: Migrate demo.we =&gt; demo.vue in 33msMigration finished in 0.035s 除了逐个转换 .we 文件以外，weex-vue-migration 还支持批量转换整个目录，参考其说明文档可以了解更详细的使用方法。 注意事项转换工具将不再支持 Weex 中废弃的语法，如果代码中有如下写法，建议先手动修改再做转换。 忽略 require(&#39;@weex-components&#39;) 语句，可以通过 npm 包的方式引入外部组件。 无法转换 repeat=&quot;list&quot; 写法，仅支持 repeat=&quot;item in list&quot; 格式。 不支持转换 &lt;script type=&quot;config&quot;&gt;&lt;/script&gt;，目前 Vue 中不支持原有的降级配置。 第二步，手动调整代码细节模板和样式的转换都可以借助工具轻易转换过来，&lt;script&gt; 中基本的语法也可以转换；但是由于 javascript 的写法比较灵活，仅仅使用工具做转换，并不一定能完美过渡。工具只能处理语法但是理解不了代码中的逻辑，在 Weex 和 Vue 的框架特性存在一些差异，有些差异还是需要手动修改才可以生效。 提示：在代码中使用的“黑科技”越多，项目就越难以转换。 样式单位在 .we 文件写样式时，开发者通常都不写长度单位，默认会被视为 px。在新的 Vue 版本的 Web 渲染器中，&lt;style&gt; 中的样式将会直接转化成 CSS class，如果不写单位、浏览器将无法正确识别，会导致在 Web 端无法正常渲染。Native 环境中不受影响。 尽管不影响 Native 页面的渲染，也建议给样式长度加上单位 px。 旧框架中的内置属性 vm._app vm._app.differ vm._app.doc vm._app.updateActions() 事件派发机制 $dispatch 、$broadcast 、$call 方法已经废弃。 $emit 行为不一致。 可以使用 Vuex 管理数据状态。 直接操作 Virtual-DOMWeex 和 Vue 中的 Virtual-DOM 格式并不相同，如果你使用了 this.$el(&#39;id&#39;) 获取了某个组件的 element 之后，又修改了其中的某些属性或者调用了某些方法，这些操作在 Vue 中很难找到直接的对应写法。 从另一个角度讲，我们也非常不建议在 Weex 或 Vue 项目中直接操作 Virtual-DOM，这些写法都应该修改。 调整开发环境和工具在文件转换完成后，还需要重新调整一下开发环境。 文件的编译weex-loader 同时支持编译 .we 和 .vue 文件，如果你使用的是 webpack 来配置编译环境，将不需要做任何改变就能直接编译 .vue 文件。 需要注意的是，Vue 本身就是一个独立的前端框架，使用 Vue 编写的项目在 Web 上完全可以不依赖 Weex 容器运行。在这种情况下，需要配置基于 vue-loader 的编译脚本生成适用于 Web 平台 js 文件；然后引入 Vue 格式的 Weex 组件库就可以在 Web 中。 辅助工具Weex 提供了 weex-toolkit 的脚手架工具来辅助开发和调试、weex-pack 实现打包原生应用；同样在 Vue 中也有 vue-cli 脚手架工具。Weex 和 Vue 的工具互相做了适配，建议在创建项目和开发 Vue 项目的时候使用 vue-cli ，在调试时使用 weex-toolkit，在打包原生应用时使用 weex-pack 。","type":"references"},{"title":"animation","path":"cn/references/modules/animation.html","permalink":"https://weex.apache.org/cn/references/modules/animation.html","text":"animation 动画流畅且有意义的动画是一个十分有效的提升移动应用用户体验的手段，animation 模块被用于在组件上执行动画。动画可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 APItransition(el, options, callback)参数 el {Element}：将要执行动画的元素，例如指定动画的元素 ref 属性为 test , 可以通过调用 this.refs.test 来获取元素的引用。 options {Object}：描述动画过程的对象。 options.duration {number}：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 options.delay {number}：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 options.timingFunction {string}：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 示例 linear 动画从头到尾的速度是相同的 ease-in 动画速度由慢到快 ease-out 动画速度由快到慢 ease-in-out 动画先加速到达中间点后减速到达终点 cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. options.styles {Object}：设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 示例 width 动画执行后应用到组件上的宽度值 length 无 height 动画执行后应用到组件上的高度值 length 无 backgroundColor 动画执行后应用到组件上的背景颜色 string none opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 transform属性的合法值: 名称 描述 值类型 默认值 示例 translate/translateX/translateY 指定元素要移动到的位置 像素值或百分比 无 rotate 指定元素将被旋转的角度，单位是度 number 无 scale/scaleX/scaleY 按比例放大或缩小元素 number 无 callback {Function}：动画执行完毕之后的回调 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div ref=\"test\" @click=\"move\" class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const animation = weex.requireModule('animation') const modal = weex.requireModule('modal') export default &#123; methods: &#123; move () &#123; var testEl = this.$refs.test; animation.transition(testEl, &#123; styles: &#123; color: '#FF0000', transform: 'translate(250px, 100px)', transformOrigin: 'center center' &#125;, duration: 800, //ms timingFunction: 'ease', delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; width: 250px; height: 250px; background-color: #DDD; &#125;&lt;/style&gt; try it","type":"references"},{"title":"clipboard","path":"cn/references/modules/clipboard.html","permalink":"https://weex.apache.org/cn/references/modules/clipboard.html","text":"clipboard 剪切板v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。但是现在我们可以通过简单的调用 clipboard.getString() 接口来获取短信内容了。 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 APIgetString(callback)从系统粘贴板读取内容。 参数 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 setString(text)将一段文本复制到剪切板，相当于手动复制文本。 参数 text {string}：要复制到剪切板的字符串。 Example&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"cn/references/modules/dom.html","permalink":"https://weex.apache.org/cn/references/modules/dom.html","text":"dom包含如下可以更新 dom 树的 dom API。 这部分API是通过把 virtual-dom 的消息发送到 native 渲染器来做到的。 开发者在日常开发中，唯一可在 .vue 文件中使用的是 scrollToElement。你也可以调用 $scrollTo 方法来使用它 这个页面提及的其他的 API，只在 callNative 进程中的 native 渲染器用。（关于 callNative 进程的进一步介绍，可以在 How it works中的 JS Framework 部分看到 ） APIscrollToElement(node, options)让页面滚动到那个对应的节点，这个API只能在 &lt;scroller&gt; 和 &lt;list&gt; 组件中用。 这个API也能通过调用VM的方法 $scrollTo 来使用（已弃用） 要在你的 .vue 文件中使用这个 API，可以使用 weex.requireModule(&#39;dom&#39;).scrollToElement。 参数 node {Node}：你要滚动到的那个节点 options {Object}：如下选项 offset {number}：一个到其可见位置的偏移距离，默认是 0 animated {boolean} 0.10+：是否需要附带滚动动画，默认是true 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; /*justify-content: space-around;*/ justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it getComponentRect(ref, callback) v0.9.4+通过标签的 ref 获得其布局信息，返回的信息在 callBack 中，格式参考如下： &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; 如果想要获取到 Weex 容器的布局信息，可以指定 ref=&#39;viewport&#39;，调用例子如下： &lt;template&gt; &lt;div class=\"wrapper\" style='margin-top:200px'&gt; &lt;div ref=\"box\" class=\"box\"&gt; &lt;text class=\"info\"&gt;Width: &#123;&#123;size.width&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Height: &#123;&#123;size.height&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Top: &#123;&#123;size.top&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Bottom: &#123;&#123;size.bottom&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Left: &#123;&#123;size.left&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Right: &#123;&#123;size.right&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"info btn\" @click='click()'&gt;&#123;&#123;this.tip&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; const dom = weex.requireModule('dom') function round(size) &#123; var roundSize = &#123; 'width': Math.round(size.width), 'height': Math.round(size.height), 'top': Math.round(size.top), 'bottom': Math.round(size.bottom), 'left': Math.round(size.left), 'right': Math.round(size.right) &#125; return roundSize &#125; export default &#123; data () &#123; return &#123; size: &#123; width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 &#125;, ref:\"viewport\", tip:\"get box rect\" &#125; &#125;, mounted () &#123; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125;, methods:&#123; click:function() &#123; if (this.ref === 'viewport') &#123; this.ref = this.$refs.box; this.tip = \"get viewport rect\" &#125; else &#123; this.ref = 'viewport' this.tip = \"get box rect\" &#125; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .btn &#123; margin-top:20px; border-width:2px; border-style: solid; border-radius:10px; width:300px; margin-left:170px; padding-left:35px; border-color: rgb(162, 217, 192); &#125; .btn:active &#123; background-color: #8fbc8f;22border-color: gray; &#125; .box &#123; align-items:center; margin-left: 150px; width: 350px; height: 400px; background-color: #DDD; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .info &#123; font-size: 40px; top:30px; margin-left:20px; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; color: #41B883; &#125;&lt;/style&gt; try it addRule支持版本:v0.12.0 addRule是可以为dom 添加一条规则，目前支持自定义字体fontFace规则，构建自定义的font-family，可以在text使用 fontFacevar domModule = weex.requireModule('dom');domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;); try it 其他dom 还有一些底层接口用于创建 Weex 实例时调用，比如 createBody、updateAttrs 等，但并未开放供外部使用。","type":"references"},{"title":"globalEvent","path":"cn/references/modules/globalevent.html","permalink":"https://weex.apache.org/cn/references/modules/globalevent.html","text":"全局事件0.8 globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 AndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)注册全局事件。 参数 eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)取消事件监听。 参数 eventName {string}：需要取消的事件名称。 示例var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"modal","path":"cn/references/modules/modal.html","permalink":"https://weex.apache.org/cn/references/modules/modal.html","text":"modal 模态modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 APItoast(options)toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数 options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） Android: 如果时间长度大于3s，将使用一个被称为LONG的系统变量, 否则使用SHORT这个系统变量 iOS: 持续的时间同Duration相同。 alert(options, callback)警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数 options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 confirm(options, callback)确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数 options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 prompt(options, callback)提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数 options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下 result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"showToast\"&gt;Toast&lt;/text&gt; &lt;text class=\"button\" @click=\"showAlert\"&gt;Alert&lt;/text&gt; &lt;text class=\"button\" @click=\"showConfirm\"&gt;Confirm&lt;/text&gt; &lt;text class=\"button\" @click=\"showPrompt\"&gt;Prompt&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') export default &#123; methods: &#123; showToast (event) &#123; console.log('will show toast') modal.toast(&#123; message: 'This is a toast', duration: 0.3 &#125;) &#125;, showAlert (event) &#123; console.log('will show alert') modal.alert(&#123; message: 'This is a alert', duration: 0.3 &#125;, function (value) &#123; console.log('alert callback', value) &#125;) &#125;, showConfirm (event) &#123; console.log('will show confirm') modal.confirm(&#123; message: 'Do you confirm ?', duration: 0.3 &#125;, function (value) &#123; console.log('confirm callback', value) &#125;) &#125;, showPrompt (event) &#123; console.log('will show prompt') modal.prompt(&#123; message: 'This is a prompt', duration: 0.3 &#125;, function (value) &#123; console.log('prompt callback', value) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"navigator","path":"cn/references/modules/navigator.html","permalink":"https://weex.apache.org/cn/references/modules/navigator.html","text":"navigator 导航控制v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 APIpush(options, callback)把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数 options {Object}：选项参数 url {stirng}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 pop(options, callback)把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数 options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"storage","path":"cn/references/modules/storage.html","permalink":"https://weex.apache.org/cn/references/modules/storage.html","text":"storage 本地存储v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 APIstorage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数 key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)传入键名返回对应的键值 参数 key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined removeItem(key, callback)传入一个键名将会删除本地存储中对应的键值 参数 key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 length(callback)返回本地存储的数据中所有存储项数量的整数 参数 callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 getAllKeys(callback)返回一个包含全部已存储项键名的数组 参数 callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it 其它参考 W3school: html5 localStorage storage 模块完整的 Demo","type":"references"},{"title":"stream","path":"cn/references/modules/stream.html","permalink":"https://weex.apache.org/cn/references/modules/stream.html","text":"stream概述以下为 stream 相关的 API，用于实现网络请求。 APIfetch(options, callback[,progressCallback])发起网络请求 参数 options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：响应类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 注意 默认 Content-Type 是 ‘application/x-www-form-urlencoded’。 如果你需要通过 POST json ， 你需要将 Content-Type 设为 ‘application/json’。 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Weex Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;weexStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Vue Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;vueStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var stream = weex.requireModule('stream') export default &#123; data () &#123; return &#123; weexStar: 'unknown', vueStar: 'unknown' &#125; &#125;, methods: &#123; getStarCount (repo, callback) &#123; return stream.fetch(&#123; method: 'GET', type: 'json', url: 'https://api.github.com/repos/' + repo &#125;, callback) &#125; &#125;, created () &#123; this.getStarCount('alibaba/weex', res =&gt; &#123; this.weexStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) this.getStarCount('vuejs/vue', res =&gt; &#123; this.vueStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; &#125; .title &#123; font-size: 45px; color: #888888; &#125; .count &#123; font-size: 45px; font-weight: bold; margin-left: 12px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"WebSocket","path":"cn/references/modules/websocket.html","permalink":"https://weex.apache.org/cn/references/modules/websocket.html","text":"WebSocketv0.12+ SummaryWebSockets 是一种先进的技术, 这使得在用户的 H5/iOS/Android 和一个服务器之间打开一个的交互式通信会话成为可能, 有了这个 API，你可以向服务器发送消息, 并接收事件驱动的响应, 无需轮询服务器的响应 注意： iOS和h5提供 WebSockets 的 protocol 默认实现，安卓使用需要提供自定义 adapter 实现，source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; 集成例子参考weex playground APIWebSocket(url, protocol)创建 WebSockets，并连接服务器 Arguments url {string}: 表示要连接的 URL; protocol {string}: WebSockets 协议 send(data)通过WebSocket连接向服务器发送数据 Arguments data{string}:要发送到服务器的数据 close(code,reason)关闭 WebSockets 的链接 Arguments code {number}: 关闭连接的状态号. reason {string}: 关闭的原因 onopen(options)链接打开的监听 Arguments options {object}: 一个空的对象 onmessage(options)消息事件的监听器 Arguments options {object}: 服务器返回的消息对象 data {string}: 监听器接收的到的消息 onclose(options)关闭事件的监听器 Arguments options {object}: 监听器接收到的对象 code {number}: 服务器返回关闭的状态码 reason {string}: 服务器返回的关闭原因 wasClean {boolen}: 是否完全关闭. onerror(options)错误事件的监听器 Arguments options {object}: 错误信息的事件 data {string}: 监听器接收到的信息 Example&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"使用 Vuex 和 vue-router","path":"cn/references/vue/difference-of-vuex.html","permalink":"https://weex.apache.org/cn/references/vue/difference-of-vuex.html","text":"使用 Vuex 和 vue-routerVue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 我们基于 Weex 和 Vue 开发了一个的完整项目 weex-hackernews ，在项目中使用了 Vuex 和 vue-router ，能够实现同一份代码，在 iOS、Android、Web 下都能完整地工作。 使用 Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具库，可以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 由于在 Vuex 本身就是平台无关的，有较强的移植能力，完全可以在 Weex 中正常地使用 Vuex ，阅读其官方文档可以了解详细的使用方法。 Vuex 也集成到了其官方调试工具 devtools extension中，提供了诸如 time-travel 调试、状态快照导入导出等高级调试功能。这些工具在 Web 平台中可以一如既往地工作。 使用 vue-routervue-router 是专为 Vue.js 开发的便于实现单页应用的工具库，能够以声明式的方法编写页面的导航和跳转信息。 由于 Weex 的运行环境不只是浏览器，通常是以移动端原生环境为主，然而在 Android 和 iOS 中都没有浏览器的 History API，也不存在 DOM，因此如果想在 Weex 环境中使用 vue-router ，有些功能受到了限制，使用时应该注意。 路由模式vue-router 提供了三种运行模式： hash: 使用 URL hash 值来作路由。默认模式。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 配置方法是在定义路由时，传递 mode 属性： new Router(&#123; mode: 'abstract', // ...&#125;) 从三种模式的介绍中也可以看出来，Weex 环境中只支持使用 abstract 模式。不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以在使用时只要不写 mode 配置即可。默认 vue-router 会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 编程式导航vue-router 中使用 &lt;router-link&gt; 创建导航链接，不过在其中使用了基于 DOM 事件的一些特性，在 Weex 原生环境中并不能很好的工作。在 Weex 中，你必须使用编程式导航来编写页面跳转逻辑。 编程式导航其实就是通过主动调用 router 实例上的 push 方法实现跳转。 使用 &lt;router-link&gt; 的代码示例： &lt;!-- 只能在 Web 中使用，Native 环境不支持！ --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在 Weex 中，需要写成这个样子： &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"Vue 2.x 在 Weex 和 Web 中的差异","path":"cn/references/vue/difference-with-web.html","permalink":"https://weex.apache.org/cn/references/vue/difference-with-web.html","text":"Vue.js 在 Weex 和 Web 中的差异平台差异Vue.js 最初是为 Web 平台设计的，虽然可以基于 Weex 开发原生应用，但是 Web 开发和原生开发毕竟不同，在功能和开发体验上都有一些差异，这些差异从本质上讲是原生开发平台和 Web 平台之间的差异，可以通过《Weex 和 Web 平台的差异》了解更多细节和原因。 由于运行平台存在差异，Weex 不支持 Vue.js 中与 DOM 相关的功能： 不支持事件冒泡和捕获机制，.prevent 、.capture 、.stop 、.self 等事件修饰符在原生环境中无意义。 键盘事件的 .{keyCode | keyAlias} 修饰符在原生环境中无意义。(参考 Vue 相关文档) 无需自行调用 vm.$mount，默认会将入口组件挂载到原生应用的视图中。 不支持 v-html 和 v-text 指令。 功能差异仅引入了 Vue RuntimeVue 除了提供默认的完整包以外，还提供一个更小巧的 vue.runtime.js，在这个文件中移除了模板编译的相关操作，Weex 中也仅引入 Vue Runtime 的功能，这样做除了可以减少代码体积以外，还能减少运行期编译模板的负担，提升性能。 具体的差异有： 定义组件时不支持使用 template 属性。 不支持使用 x-templates。 不支持使用 Vue.compile。 隔离多页面的作用域Weex 在原生端使用的是“多页”的实现，不同的 js bundle 将会在不同的原生页面中执行；也就是说，不同的 js bundle 之间将不同共享 js 变量。即使是 Vue 这个变量，在不同页面中也对应了不同的引用。 基于这个特性，Vue 中全局功能将只在当前页面内生效： Vue.config Vue.component Vue.directive Vue.filter Vue.mixin Vue.use 注：以上接口的功能并未受影响，只是其生效范围将会限制在同一页面内。 样式差异Web 中的 CSS 非常的灵活，积累了特别多的属性，支持多种布局方法；这是其优势，也是浏览器性能优化的一个瓶颈。 Weex 中的样式是由原生渲染器解析的，出于性能和功能复杂度的考虑，Weex 对 CSS 的特性做了一些取舍，使其更符合最佳实践。 单类名选择器和作用域Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。 /* 支持单个类名选择器 */.one-class &#123; font-size: 36px;&#125;/* 不支持关系选择器 */.parent &gt; .child &#123; padding-top: 10px;&#125;/* 不支持属性选择器，不支持 `v-cloak` 指令 */[v-cloak] &#123; color: #FF6600;&#125; 这个只是对样式定义的限制，不影响样式类名的使用，在标签中可以添加多个样式类名，如： &lt;template&gt; &lt;div class=\"one two three\"&gt;&lt;div&gt;&lt;/template&gt; 组件级别的作用域在 Weex 中，写在组件 &lt;style&gt; 里的样式只能用在当前组件中，默认是 scoped 作用域。为了保持和 Native 的一致性，建议在 .vue 文件中写样式时，加上 scoped 属性，即： &lt;style scoped&gt;。 支持的样式属性Weex 支持的样式特性是 CSS 的子集，并且会不断扩充；在实现过程中我们参考了 CSS 属性在浏览器中的使用频率，优先实现其中频率最高的一些属性。 Weex 支持了基本的盒模型和 flexbox 布局，以及其他常用样式，详情可参考Weex 通用样式文档。 在编写样式时，还应该注意一下几点： 不需要写样式前缀。 Weex 不支持 display: none;，因此也不支持 v-show 指令。 为了优化样式解析的效率，样式属性暂不支持简写，涉及一下属性： border 、border-(top|bottom|left|right) margin padding flex 编译环境的差异在 Weex 中使用 Vue.js ，你所需要关注的运行平台除了 Web 之外还有 Android 和 iOS ，在开发和编译环境上还有一些不同点。针对 Web 和原生平台，将 Vue 项目源文件编译成目标文件，有两种不同的方式： 针对 Web 平台，和普通 Vue 2.X 项目一样，可以使用任意官方推荐的方式编译源文件，如 Webpack + vue-loader 或者 Browserify + vueify 。 针对 Android 和 iOS 平台，我们提供了 weex-loader 工具支持编译 .vue 格式的单文件组件；也就是说，目前只能使用 Webpack + weex-loader 来生成原生端可用的 js bundle。 使用 weex-loaderweex-loader 是 Webpack 的一个加载器，使用方法参考其官方文档。需要提醒的是，如果 Webpack 配置的入口文件是个 .vue 格式的文件的话，还需要额外传递 entry 参数，通常设置为 true，表示将当前组件作为入口组件。为了能正常匹配 .vue 文件，Webpack 配置文件中 weex-loader 的匹配规则也需要有所调整。 module.exports = &#123; // 针对 .vue 文件要添加 entry 参数 entry: './path/to/App.vue?entry=true', // 其他配置项 ... module: &#123; loaders: [&#123; // 匹配包含了 entry 参数的 .vue 文件路径 test: /\\.vue(\\?[^?]+)?$/, loaders: ['weex-loader'] &#125;] &#125;,&#125; 如果使用 .js 文件作为 Webpack 配置的入口文件，则不需要额外配置这些参数，我们推荐使用 Javascript 文件作为编译的入口文件。 搭建原生开发环境Weex 项目生成的是原生应用，学习一些开发原生应用的基础知识，会对你开发 Weex 项目很有帮助。参考《集成 Weex 到已有应用》了解更多信息。","type":"references"},{"title":"如何创建一个 Weex 项目","path":"cn/v-0.10/advanced/create-a-weex-project.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/create-a-weex-project.html","text":"如何创建一个 Weex 项目对于前端开发者来说开发一个 app 是不容易的，既然 Weex 能以 web 的开发体验构建高性能、可扩展的 native 应用，那我们怎么利用 Weex 简单高效的开发一个 native 应用呢？Weex 替你考虑了这件事。在本章中，我们将学习如何使用 Weexpack 工具快速生成一个全新的 Weex 项目。 根据你的操作系统的不同，步骤也略有差异，如果你从未接触过 native 开发，请慢慢来，遇到问题随时查阅 FAQ。 首先，不论任何平台，我们都需要 node.js 和 Weexpack。在本节中，默认你已经安装好了 node.js 和 npm，如有疑问，可参考上一章 如何在本地开发 Weex 页面。 Weexpack 是 Weex 新一代的工程开发套件，它允许开发者通过简单的命令，创建 weex 工程项目，将项目运行在不同的开发平台上。未来，我们考虑会将其集成在 weex-toolkits 上，但目前仍需要单独安装。好在安装 Weexpack 非常简单，可以直接使用 npm 安装： npm install weexpack -g 或者用 cnpm： cnpm install weexpack -g 接下来的步骤会有一些复杂和区别，根据开发平台的不同，我们提供了快速导航便于阅读： iOS Android iOSMac 是唯一可以开发 iOS 应用的平台，因此创建 iOS 项目只支持 mac。对于 iOS，你需要安装 Xcode 和 CocoaPods 。 安装 Xcode 最简单的方法是到 Mac App Store。Xcode 体积较大，下载请耐心等待。 安装好 Xcode 后，你需要运行 Xcode，使 Xcode 自动安装开发者工具和确认使用协议。 之后你还需要安装 CocoaPods 。CocoaPods 是 Xcode 项目的类库管理工具，可以使用如下命令安装： $ sudo gem install cocoapods 如果执行该命令无反应，很可能是 gem source 问题，你可以切换为淘宝 gem source： $ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ sudo gem install cocoapods 如有问题，可参考 CocoaPods 官方文档 创建项目然后，就可以使用 weexpack 创建 weex 工程了： $ weexpack init appName weexpack 会自动新建以 appName 命名的目录，并将项目模板拉取到该目录。 最终形成如下目录结构： -&gt; /appName.|—— .gitignore|—— README.md|—— package.json|-- android.config.json|-- ios.config.json|—— webpack.config.js|—— /src| |—— index.we|—— /html5| |—— index.html|—— /ios| |—— /playground| |—— /sdk| |—— /WXDevtool|—— /android| |—— /playground| |—— /appframework 其中： webpack.config.js 是 webpack 配置文件，用于生成 .we 文件的 JSBunlde ios.config.json 是 iOS 项目配置文件 android.config.json 是 Android 项目配置文件 /src 目录放置 Weex 页面 /html5 是 H5 端入口文件 /ios 放置 iOS 项目 /android 放置 Android 项目 紧接着，进入目录，并且安装依赖： $ cd appName &amp;&amp; npm install 至此，项目模版创建完成，接下来我们可以自定义我们的 APP 信息并打包运行。 运行与打包如果一切正常，你可以使用 weexpack 打包或模拟器运行了： 模拟器运行 $ weexpack run ios 构建 ipa 包： $ weexpack build ios 构建包的过程中，将会提示让您输入 CodeSign（证书）、Profile(provisioning profile)、AppId，只有输入真实的这些信息才能成功打包。 其余如AppName，和入口 weex bundle 文件可以编辑项目目录下的 ios.config.json 配置。 打完包成功之后，可以在 /playground/build/ipa_build/ 目录下获取 ipa 文件。 注：证书需要预先安装到 keychain 中，在 keychain 中点击右键获取证书 id（证书名称）、provisioning profile 文件（*mobileprovision）需要获取 UUID，进入目录可以看到 mobileprovision_UUID.sh 文件，此文件可以获取到 UUID。 mobileprovision_UUID.sh 用法如下： $ ./mobileprovision_UUID.sh *mobileprovision 参数（*mobileprovision）为 provisioning profile 文件路径 注：run 与 build 部分涉及 pod 的依赖安装问题。 首先要安装 cocoapods ，具体安装步骤可查看这里，建议安装 0.39.0 版本。 为了加快 CLI 执行速度，weexpack 创建的工程默认安装了需要的依赖库。但是命令执行依然会更新需要升级的依赖库。 如果出现这种错误提示 unable to find a specification for &#39;WeexSDK&#39; 这种错误，说明你本地没有更新 cocoapods master 仓库，运行 pod repo update ，此时运行 pod search WeexSDK： 说明 master repo 更新成功。以上是以 WeexSDK 为例，其他库类似。 如果出现这种错误 error: The sandbox is not in sync with the Podfile.lock. Run &#39;pod install&#39; or update your CocoaPods installation. 进入 playground 目录（podfile 文件所在目录）按提示执行。 更多 pod 使用细节请移步cocoapods mobileprovision，参数（*mobileprovision）为 provisioning profile 文件路径。 Android在 Mac 平台开发 Android 首先需要下载 Android Studio（你可能需要翻墙才能访问）。Android Studio 为我们提供了 Android SDK 及 AVD（模拟器）以便我们快速运行 Android 项目。 下载完成后运行 Android Studio，任意新建一个 Android 项目，在第二步中选择 Android 5.1，然后点击 next 完成项目创建，如图所示： 待 Android Studio 打开后，在顶部菜单栏选择 Tools -&gt; Android -&gt; AVD Manager，安装 Android 模拟器： 之后，打开模拟器运行 Android。 注意： 必须保持模拟器运行。 保证 Android build-tool 的版本为 23.0。【可以在 Android Studio 的 SDK Manager 里查看是否已安装这个版本，如果没有可选择安装这一版本】。 配置环境变量因为 Android Studio 安装的 SDK 不会自动配置环境变量（你自己安装的 SDK 同样不会）。所以需要您自己手动配置 Android_HOME 环境变量和 PATH 如果是 Android Studio 安装的 SDK 安装路径可已在 SDK manager 里找到（打开 SDK manager 的方式请参照图2） Windows 下请参照 window 下如何设置 ANDROID 环境变量 Linux/Mac 下只需编辑 .bash_profile 增加 PATH 即可： vim ~/.bash_profile 然后添加下列代码进去（路径替换为你的真实路径） export ANDROID_HOME=/xxx/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools 然后保存退出（:wq）。再执行下列命令： source ~/.bash_profile 创建项目然后，就可以使用 weexpack 创建 weex 工程了： $ weexpack init appName weexpack 会自动新建以 appName 命名的目录，并将项目模板拉取到该目录。 最终形成如下目录结构： -&gt; /appName.|—— .gitignore|—— README.md|—— package.json|-- android.config.json|-- ios.config.json|—— webpack.config.js|—— /src| |—— index.we|—— /html5| |—— index.html|—— /ios| |—— /playground| |—— /sdk| |—— /WXDevtool|—— /android| |—— /playground| |—— /appframework 其中： webpack.config.js 是 webpack 配置文件，用于生成 .we 文件的 JSBunlde ios.config.json 是 iOS 项目配置文件 android.config.json 是 Android 项目配置文件 /src 目录放置 Weex 页面 /html5 是 H5 端入口文件 /ios 放置 iOS 项目 /android 放置 Android 项目 紧接着，进入目录，并且安装依赖： $ cd appName &amp;&amp; npm install 至此，项目模版创建完成，接下来我们可以自定义我们的 APP 信息并打包运行。 运行与打包如果一切正常，你可以使用 weexpack 打包或模拟器运行了： Android 的打包和构建是一体的 ： $ weexpack run android 同样的你可以更改项目目录下的android.config.json AppName: 应用名 AppId: application_id 包名 SplashText: 欢迎页上面的文字 WeexBundle: 指定的 weex bundle 文件（支持文件名和 url 的形式） 指定文件名则以本地文件的方式加载 bundle，指定 url 则以远程的方式加载 JSBundle。如果以本地方式指定 bundle .we 文件请放到 src 目录。","type":"advanced"},{"title":"自定义 native 组件","path":"cn/v-0.10/advanced/customize-a-native-component.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/customize-a-native-component.html","text":"如何自定义 native 组件？Weex 已经包含了最关键的平台组件，例如 ScrollView, ListView, Text, Imageview 等等。当然，这些组件并不能完全满足你的需求。另外，那些在你的工程中常用的大量原生 UI 组件，可能需要被简单地集合到 Weex 中。幸运的是，通过任意已存在的组件来创建你的自定义组件是一件很方便的事。 Android步骤：1.自定义组件必须继承自 WXComponent 或者 WXContainer ；2.weex SDK 可以识别 @WXComponentProp (name = value(value 是 attr 或者 dsl style))；3.方法必须是 public 的；4.组件类不能是一个内部类；5.自定义组件不能被 ProGuard 之类的工具混淆；6.组件方法在 UI 线程被调用，因此不要在里面进行耗时的操作；7.Weex 的参数类型可以是 int, double, float, String, Map, List 和实现了 WXObject 接口的自定义类； 参考以下例子： `package com.taobao.weex.ui.component;// ……public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject node, WXVContainer parent, String instanceId, boolean lazy) &#123; super(instance, node, parent, instanceId, lazy); &#125; @Override protected void initView() &#123; //TODO:your own code …… &#125; @Override public WXFrameLayout getView() &#123; //TODO:your own code ……… &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; 必须注册组件： WXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); iOS虽然 WeexSDK 中有很多的 native 的 Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫 native 的组件，想包装一下，导入到 Weex 中，因此我们提供了让开发者实现自己的 native Component。下面将以 WeexSDK 中已经存在的 Component：image 为例子，介绍一下如何构建一个 native Component。假设你已经了解 iOS 开发 注册 Component注册一个 component 比较简单，调用 WXSDKEngine 中的 registerComponent:withClass: 方法，传入组件的标签名称，还有对应的 class 然后你可以创建一个 WXImageComponent 表示 image 组件的实现。在 .we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性现在我们要做一些让 image component 更加强大的事情。既然作为一个图片的 component，那它应该要有源，给他加上一个 src 的属性，同时给它加上一个 resize 的属性（可以配置的有 contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component 中所有的 style，attribute，events 都会被传递到 Component 的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute 中拿到的值的类型都是 id，我们可以用转换方法把它转换到任何值。Weex SDK 提供了一些基础的转换方法，可以参考 WXConvert 类，或者你可以添加自己的转换函数。 Hooking 渲染生命周期native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 在 image component 的例子里面，如果我们需要我们自己的 image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123;return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。作为一个 image component，我们需要拿到服务器图片，而且把它设置进 image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在 view 已经被创建而且加载了时候 Weex SDK 会调用到，而且 viewDidLoad 这个方法是你做额外初始化工作比如改变 content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变 image 的 src，也可以 hook updateAttributes: 方法来做属性更新操作，当 updateAttributes: 或者 updateStyles: 被调用的时候， component 的 view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 现在你可以用在任何 .we 文件里面使用 &lt;image&gt;，而且可以加上 image 的属性。 &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt;","type":"advanced"},{"title":"自定义 native API","path":"cn/v-0.10/advanced/cuszomize-native-apis.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/cuszomize-native-apis.html","text":"如何自定义 native API？Weex 的 SDK 只提供了页面渲染的能力，但是一些其它操作，比如网络请求、图片加载、重定向等功能需要你自己去实现，这个例子讲述了如何用原生代码去扩展 Weex 的功能。 关于 URLHelper 的例子新建一个 WXModulepublic class URLHelperModule extends WXModule&#123; private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\"; @WXModuleAnno public void openURL(String url)&#123; if (TextUtils.isEmpty(url)) &#123; return; &#125; StringBuilder builder=new StringBuilder(\"http:\"); builder.append(url); Uri uri = Uri.parse(builder.toString()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.addCategory(WEEX_CATEGORY); mWXSDKInstance.getContext().startActivity(intent); &#125;&#125; 这里要注意 @WXModuleAnno 这个注解，它表示了你把这个方法暴露给 JavaScript。 public class URLHelperModule extends WXModule&#123; @WXModuleAnno public void openURL(String url,String callbackId)&#123; //... //callback to javascript Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(\"ts\", System.currentTimeMillis()); WXBridgeManager.getInstance().callback(mWXSDKInstance.getInstanceId(), callbackId, result); &#125;&#125; 把module注册到WXSDKEngine：try &#123; WXSDKEngine.registerModule(\"myURL\", URLHelperModule.class); //'myURL' is the name you'll use in javascript &#125; catch (WXException e) &#123; WXLogUtils.e(e.getMessage()); &#125; 在 JavaScript 中使用 eventModule：let URLHelper = require('@weex-module/myURL');//same as you registeredURLHelper.openURL(\"http://www.taobao.com\",function(ts)&#123; console.log(\"url is open at \"+ts);&#125;); 一些注意事项： 定义一个 components 需要继承 WXModule 不要忘记添加 @WXModuleAnno 注解，不然 Weex 没法识别这个方法 定义的方法必须是 `public 的 module 类一定不能是内部类 你定义的 components 不能被混淆，不然会找不到 Module 中的方法会在 UI 线程中被调用，所以一定不要做一些耗时操作 Moudle 中的方法参数类型可以为 int，double，float，String，Map，List，以及实现 WXObject 接口的类。","type":"advanced"},{"title":"Android 扩展","path":"cn/v-0.10/advanced/extend-to-android.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/extend-to-android.html","text":"Android 扩展Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展 Module 扩展必须继承 WXModule 类。 扩展方法必须加上 @WXModuleAnno 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule &#123; @WXModuleAnno(runOnUIThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;点击我测试&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; require('@weex-module/myModule').printLog(\"我是一个测试!\"); &#125; &#125; &#125;&lt;/script&gt; Component 扩展 Component 扩展类必须集成 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richtext&quot;,RichText.class); 示例如下: public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; Adapter扩展图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; 组件方法支持从WeexSDK 0.9.5开始，你可以定义组件方法 在组件中如下声明一个组件方法 @JSMethodpublic void focus()&#123;//method implementation&#125; 注册组之后，你可以在weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39;","type":"advanced"},{"title":"weex-html5 扩展","path":"cn/v-0.10/advanced/extend-to-html5.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/extend-to-html5.html","text":"扩展 weex-html5简介Weex 是一个高可扩展性的跨平台动态化开发方案，你可以在现有组件基础上定制自己需要的三端组件。你可以为 Weex API 模块添加新的方法，或者创建新的 API 模块和新的加载器。按照以下几个步骤扩展你的组件，API 或者加载器。 首先要明确的是，组件和 API 模块是基于 Weex 的扩展，但是独立于 Weex，组件的定义本身是不需要依赖于 Weex 的，这样有助于组件的分散化管理，去除中心化依赖。 其次，当你扩展一个组件，你需要同时扩展三端的组件（android, ios 和 web 端），毕竟 Weex 是一个重视三端一致体验的跨平台移动框架。你可以一个端一个端的扩展，也可以召唤其他端上的开发者来共同完成你在其他端上的组件（你总是可以在社区找到对某个功能有共同需求的开发者）。这里有一些在 android 端和 ios 端做扩展的文档可以参考。 你应该将你的扩展发布到 Weex 开发者可以方便找到和使用的渠道，比如 npm。我们推荐你将你开发的组件发布到 npm 供其他 Weex 开发者使用。 最重要的是，你的组件的命名需要遵守 Weex 组件命名规范：以 weex- 开头作为组件的前缀，并且以 -&lt;platform&gt; 做为结尾后缀，除非你发布的包是三端的实现都包含在内的。这里有个 &lt;weex-hello-web&gt; 的例子作为参考，这里注册了一个简单的自定义的组件。 创建新组件步骤: 在你的组件实现中必须继承 Weex.Component 这个类, 并选择性的重写其中的一些方法。 你的组件的 exports 需要暴露一个 init 方法，并在其中使用 Weex.registerComponent 注册你的组件。 这里用一个例子展示如何扩展一个新的组件 看这个组件扩展的代码( web 端上的组件)： const attr = &#123; // ...&#125;const style = &#123; // ...&#125;const event = &#123; // ...&#125;// 每个扩展组件都需要实现一个init方法，Weex会通过这方法进行安装和注册.function init (Weex) &#123; const Component = Weex.Component const extend = Weex.utils.extend // 组件的构造函数 function Hello (data) &#123; Component.call(this, data) &#125; // prototype继承 Hello.prototype = Object.create(Component.prototype) extend(Hello.prototype, proto) // 配置属性、样式以及事件 extend(Hello.prototype, &#123; attr &#125;) extend(Hello.prototype, &#123; style: extend(Object.create(Component.prototype.style), style) &#125;) extend(Hello.prototype, &#123; event &#125;) Weex.registerComponent('weex-hello', Hello)&#125;// 暴露init方法接口.export default &#123; init &#125; 上述代码摘引自 weex-hello-web/src/index.js 这个demo重写了基类 Component中的create方法。你也可以选择重写Component中的一些其他方法来定制组件的行为。典型的方法包括： create: 创建组件的节点，在方法体中return这个节点. createChildren 创建子节点. insertBefore 在某个子节点之前插入一个新的子节点. appendChild 在子节点列表的最后加上一个节点. removeChild 移除一个子节点. 进阶：更多关于组件定制和扩展的细节和代码展示，可以参考 weex 主仓库的代码，这里的组件基本上都是通过上述方式进行定义的。 重要的一点，注册组件的关键方法是 Weex.registerComponent，如示例里的 weex-hello 组件的注册： Weex.registerComponent('weex-hello', Hello) 上述代码引自 weex-hello-web/src/index.js 在某个需要使用该组件的weex项目中使用 Weex.install 方法安装该组件： // import the original weex-html5.import weex from 'weex-html5'import hello from 'weex-hello-web'// install the component.weex.install(hello) 上述代码引自 weex_extend_demo/src/main.js 在你的 .we 文件中直接使用这个组件： &lt;template&gt; &lt;div&gt; &lt;weex-hello class=\"hello\" style=\"txt-color:#fff;bg-color:green\" value=\"WEEX\" onclick=\"handleClick\"&gt; &lt;/weex-hello&gt; &lt;/div&gt;&lt;/template&gt; 上述代码引自weex_extend_demo/demo/index.we 扩展API你可以扩展新的 API 模块，或者为某个已有的模块添加新的 API. 比如，你可以添加一个 API 模块叫做 user，在里面添加一些用户登录登出处理的 API，比如 login, logout 等等。你可以通过 require(&#39;@weex-module/moduleName)[methodName](arg1, arg2, ...) (Module APIs) 的方式调用你的 API. 步骤: 实现你的 API module. 在你的 API 安装模块里暴露一个 init 方法，并在这个方法里面使用 Weex.registerAPIModules 注册你的 API module. 这里用一个例子展示如何扩展一个新的 API 模块 创建一个文件 user.js，在其中定义登录登出 login/logout 方法. const user = &#123; // 定义用户登录方法. login (callbackId) &#123; login.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;, // 定义用户登出方法. logout (callbackId) &#123; logout.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;&#125;// 定义user模块的元 (meta) 信息.const meta = &#123; user: [&#123; name: 'login', args: ['function'] &#125;, &#123; name: 'logout', args: ['function'] &#125;]&#125;export default &#123; init (Weex) &#123; // 注册这个模块，最后一个参数是模块的元信息. Weex.registerApiModule('user', user, meta) &#125;&#125; 这个简单的 user helper 模块就实现好了，可以发布到 npm 上，我们可以给这个模块取个名字，比如说 weex-user-helper。 在你的新的 Weex 项目里安装这个模块: import Weex from 'weex-html5'import user from 'weex-user-helper'Weex.install(user) 安装了这个模块，你就可以在 DSL 代码里引用这个模块干点事情了: &lt;template&gt; &lt;div&gt; &lt;div class=\"btn\" onclick=\"handleClick\"&gt; &lt;text&gt;LOGIN&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var userHelper = require('@weex-module/user') module.exports = &#123; methods: &#123; handleClick: function () &#123; userHelper.login(function () &#123; // ... do sth. in callback. &#125;) &#125; &#125; &#125;&lt;/script&gt; 定制加载器loaderLoader仅用于weex-html5 (web端)加载dsl打包出来的bundle代码，native平台有其他的加载机制 已有的加载器包括 xhr, jsonp 和 source. 你可以使用 weex.registerLoader 注册一个新的加载器。例如，你有一个获取 Weex bundle 的服务 myServe.getWeexBundle , 通过这个服务可以加载 weex bundle，为此你可以定义一个加载器： function loadByMyServe(pageId, callback) &#123; myServe.getWeexBundle(pageId).then(function (bundle) &#123; callback(bundle) &#125;).catch(function(err) &#123; callback(err) &#125;)&#125;// 暴露init方法用于Weex安装此加载器.export default &#123; init (Weex) &#123; Weex.registerLoader('myserve', loadByMyServe) &#125;&#125; 在你的 weex-html5 项目的启动文件里安装并使用这个加载器： import Weex from 'weex-html5'// 或者import from './myserve.js'，不管是import一个npm模块还是import一个文件.import loader from 'myLoader'Weex.install(loader)// 在init方法里使用这个加载器加载bundle文件.(function () &#123; function getUrlParam (key) &#123; const reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') const match = location.search.match(reg) return match &amp;&amp; match[1] &#125; const page = getUrlParam('page') || 'examples/build/index.js' Weex.init(&#123; appId: location.href, loader: 'myserve', // 使用刚才定义的loader类型 source: page, rootId: 'weex' &#125;)&#125;)(); 以上是 Weex 带来的扩展性里比较主要的一部分，更多实现细节可以在 weex 项目代码库以及 weex 的开源社区里找到。","type":"advanced"},{"title":"数据绑定原理","path":"cn/v-0.10/advanced/how-data-binding-works.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/how-data-binding-works.html","text":"数据绑定实现原理Weex 的 JS Framework 是一个 MVVM，即 Model-View-ViewModel 框架。他会自动监听数据的变化，并通过 {{字段名}} 的语法把数据和视图中所展示的内容自动绑定起来。当数据被改写的时候，视图会自动根据数据的变化而发生相应的变化。 比如下面这个例子，&lt;text&gt; 的内容被绑定在了 notes 数据字段上： &lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;notes&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;template&gt;&lt;script&gt; module.exports = &#123; data: &#123; notes: 'Hello' &#125; &#125;&lt;/script&gt; Weex 的 JS Framework 会首先对 data 里的数据进行监听，这样未来的数据变化都能够被监听到。然后我们会编译整个 &lt;template&gt; 标签里的内容。当我们找到 &lt;text&gt; 标签里的 {{notes}} 时，JS Framework 会跟踪 data.notes 的变化并在其发生变化时触发一个句柄，将 &lt;text&gt; 的内容设置为 data.notes 最新的值。这样的话开发者就不必手动关心数据和视图之间的数据同步问题了。 在这个基础上我们还设计了一些特殊的语法： &lt;foo if=&quot;...&quot;&gt; 代表一个条件监听，当其值为 true 时，&lt;foo&gt; 元素将会被创建和载入，反之则不会被创建或被移除掉。 &lt;foo repeat=&quot;...&quot;&gt; 代表一个列表监听，第一次加载的时候 &lt;foo&gt; 元素会被按照数组里的数据逐条 clone 并赋值。而当有列表项增加、移动或移除时，视图层也会自动触发相应的改变，并且智能优化至最小变更策略 &lt;foo if=&quot;...&quot; repeat=&quot;...&quot;&gt; 两个特殊语法共用时，将会优先展开 repeat 然后逐条判断 if。 相比于一些 virtual-DOM 的 diff 计算机制，我们会直接对数据进行 diff，而且只会 diff 由于用户操作或数据操作发生改变的那部分数据和视图，这是一种更小范围的计算方式。尤其在追求轻量快速的移动端界面上，这种更新机制更加显得具有优势。","type":"advanced"},{"title":"iOS 扩展","path":"cn/v-0.10/advanced/extend-to-ios.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/extend-to-ios.html","text":"iOS 扩展Module 扩展swift 扩展 module Weex SDK 只提供渲染，而不是其他的能力，如果你需要 像网络，图片，URL跳转这些特性，需要自己动手实现他们例如，如果你想实现一个url地址跳转函数，你可以按照如下步骤实现一个 Module 自定义module的步骤 自定义的module类 必须实现 WXModuleProtocol 必须添加宏WX_EXPORT_METHOD, 它可以被weex识别，它的参数是 JavaScript调用 module指定方法的参数 添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上 Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行 Weex 的参数可以是 String 或者Map Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end Register the module通过调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; 使用自己的module 这里的 require 里面的event 就是在 上一步调用registerModule: 注册module 时候的name var eventModule = require('@weex-module/event'); eventModule.openURL('url',function(ret) &#123; nativeLog(ret);&#125;); Weex SDK没有 图片下载，navigation 操作的能力，请大家自己实现这些 protocol handler 扩展 WXImgLoaderProtocol weexSDK 没有提供图片下载的能力，需要实现 WXImgLoaderProtocol,参考下面的例子 WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished.*/-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end 实现上述协议 @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end handler注册 你可以通过WXSDKEngine 中的 registerHandler:withProtocol注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] Component 扩展 虽然WeexSDK中有提供内置的一些Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫native的组件，想包装一下，导入到Weex中，因此我们提供了让开发者实现自己的native Component 下面将以WeexSDK 中已经存在的 Component：image为例子，介绍一下如何构建一个native Component. 假设你已经了解IOS开发 注册 Component注册一个component比较简单，调用 WXSDKEngine 中的 registerComponent:withClass:方法，传入组件的标签名称，还有对应的class然后你可以创建一个 WXImageComponent 表示image组件的实现 在.we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性现在我们要做一些让image component更加强大的事情。既然作为一个图片的component，那它应该要有源，给他加上一个 src的属性，同时给它加上一个resize的属性（可以配置的有contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component中所有的style，attribute，events都会被传递到 Component的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute中拿到的值的类型都是id,我们可以用转换方法把它转换到任何值。Weex SDK提供了一些基础的转换方法，可以参考 WXConvert类，或者你可以添加自己的转换函数 Hooking 渲染生命周期 native 的component 是由Weex管理的，weex 创建，布局，渲染，销毁。weex的component生命周期都是可以hook的，你可以在这些生命周期中去做自己的事情 | 方法 | 描述 || :-: | — || initWithRef:type:… | 用给定的属性初始化一个component. || layoutDidFinish | 在component完成布局时候会调用. || loadView | 创建component管理的view. || viewWillLoad | 在component的view加载之前会调用. || viewDidLoad | 在component的view加载完之后调用. || viewWillUnload | 在component的view被释放之前调用. || viewDidUnload | 在component的view被释放之后调用. || updateStyles: | 在component的style更新时候调用. || updateAttributes: | 在component的attribute更新时候调用. || addEvent: | 给component添加event的时候调用. || removeEvent: | 在event移除的时候调用. | 在image component的例子里面，如果我们需要我们自己的image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。 作为一个image component，我们需要拿到服务器图片，而且把它设置进image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在view已经被创建而且加载了时候weex SDK会调用到，而且viewDidLoad这个方法是你做额外初始化工作比如改变content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变image的src,也可以hook updateAttributes:方法来做属性更新操作，当updateAttributes:或者 updateStyles:被调用的时候， component的view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去Hook，当布局完成时候，像layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法 现在你可以用在任何 .we文件里面使用 &lt;image&gt;，而且可以加上 image的属性 &lt;image style=&quot;your-custom-style&quot; src=&quot;image-remote-source&quot; resize=&quot;contain/cover/stretch&quot;&gt;&lt;/image&gt; component 方法WeexSDK 0.9.5 之后支持了在js中直接调用component的方法，这里提供一个例子， 自定义一个WXMyCompoenent 的组件 @implementation WXMyComponentWX_EXPORT_METHOD(@selector(focus)) // 暴露该方法给js- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self;&#125;- (void)focus&#123; NSLog(@&quot;you got it&quot;);&#125;@end 注册组件 [WXSDKEngine registerComponent:@&quot;mycomponent&quot; withClass:[WXMyComponent class]] 在weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt; &lt;/template&gt; &lt;script&gt; module.exports = { created: function() { this.$el('mycomponent').focus(); } } &lt;/script&gt;","type":"advanced"},{"title":"集成 Devtools 到 Android","path":"cn/v-0.10/advanced/integrate-devtools-to-android.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/integrate-devtools-to-android.html","text":"集成 Devtools 到 AndroidWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入添加依赖可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:0.8.0.0'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;0.8.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容 weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 添加 Debug 模式开关控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 和来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用`WXSDKEngine.reload()。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试前置工作如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 本地开发）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识Devtools 组件介绍Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。","type":"advanced"},{"title":"集成 Devtools 到 iOS","path":"cn/v-0.10/advanced/integrate-devtools-to-ios.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/integrate-devtools-to-ios.html","text":"集成 Devtools 到 iOSWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入添加依赖方法一：cocoapods 依赖在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， 目前有如下几个版本： 0.7.0, 0.6.1, 0.1.1, 0.1.0 [master repo] 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 推荐在DEBUG模式下依赖。 方法二：github 源码依赖 拉取最新的WXDevtool代码。 按照如下图示：直接拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网App研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能如果按照方法一接入：podfile 的方式，添加头文件包含： #import &lt;TBWXDevtool/WXDevtool.h&gt; 如果按照方法二接入：源码依赖的方式，添加头文件包含： #import &quot;WXDevtool.h&quot;``` 查看 WXDevtool 头文件如下： ```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */ + (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end``` `setDebug`：参数为 `YES` 时，直接开启 debug 模式，反之关闭，使用场景如下所述在你自己的程序中添加如下代码：```object-c [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能 为什么需要页面刷新功能？ 如下图所示，当点击 debug 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debug 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 具体实现可参考 playground WXDemoViewController.m 文件 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 使用如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 本地开发）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 日志级别控制 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0, Error = ErrorWarning = Error | Warning,Info = Warning | Info,Log = Log | Info,Debug = Log | Debug, All = NSUIntegerMax 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"advanced"},{"title":"集成到 web","path":"cn/v-0.10/advanced/integrate-to-html5.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/integrate-to-html5.html","text":"项目中引入 html5 版 Weex简介Weex 是一个跨平台可扩展的动态化移动框架，能够真正帮助开发者实现’一次开发，到处运行’。由 Weex 提供的相关工具进行打包好的 bundle 文件可以运行在 android, ios 以及 web（这里我们也称之为html5）平台的渲染器上。Weex HTML5 是一个专用于在移动端 webview 以及各种现代浏览器上渲染 weex 文件的渲染器。 获取 Weex HTML5使用 npm 安装最新版本的 Weex HTML5，并在你的项目中 require 进来。 从 npm 安装请确保通过 npm install 或者 npm update 获取 Weex HTML5 的最新版本 npm 包。更多关于 npm 的信息情查阅 npm 官方网站。 npm install weex-html5 通过 require 引入 weex-html5: var weex = require('weex-html5') 注意: 介于 Weex 目前仍处于开源内测阶段，还没有完全开放源代码，因此 weex-jsframework 可能还没有在 npm 上发布。当前版本的 weex-html5 包含了 weex-jsframework，你只需要 require weex-html5 即可暂时在 web 平台上运行 weex 代码。建议关注 Weex 的后续版本发布并做必要的引用方式调整。 初始化 Weex你可以通过 Weex 暴露的 API init 来初始化一个 Weex 实例。这个方法需要传递一些配置信息已确定一些环境变量等信息，这些配置信息介绍如下： appId: Weex 实例的 id，可以是任意字符串或者数字，并注意不要重复. source: 请求的 Weex bundle 文件地址，或者 Weex bundle 文件代码本身，取决于下面的 loader 配置. loader: 加载器类型，用于加载 weex bundle，值可以是 ‘xhr’, ‘jsonp’ 或者 ‘source’. xhr: 通过 XMLHttpRequest 加载 source(即 weex bundle 的 url 地址). jsonp: 通过 JSONP 加载 weex bundle. source: 直接接受 weex bundle 的代码作为参数. rootId: root 容器的 id，默认容器 id 是 ‘weex’. 以下是一个 Weex 初始化的示例: function weexInit() &#123; function getUrlParam (key) &#123; var reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') var match = location.search.match(reg) return match &amp;&amp; match[1] &#125; var loader = getUrlParam('loader') || 'xhr' var page = getUrlParam('page') // 需要指定一个jsonp回调函数名称，如果没有则用默认值'weexJsonpCallback' var JSONP_CALLBACK_NAME = 'weexJsonpCallback' window.weex.init(&#123; jsonpCallback: JSONP_CALLBACK_NAME, appId: location.href, source: page, loader: loader, rootId: 'weex' &#125;)&#125;weexInit()","type":"advanced"},{"title":"集成到 Android","path":"cn/v-0.10/advanced/integrate-to-android.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/integrate-to-android.html","text":"WEEX SDK 集成到 Android 工程注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio) 下载源码 git clone https://github.com/alibaba/weex 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录WXSample地址https://github.com/xkli/WXSample.git","type":"advanced"},{"title":"集成到 iOS","path":"cn/v-0.10/advanced/integrate-to-ios.html","permalink":"https://weex.apache.org/cn/v-0.10/advanced/integrate-to-ios.html","text":"Weex SDK 集成到 iOScocoaPods 引入 Weex iOS SDK到工程可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature cocoaPods集成 假设你已经完成了安装iOS 开发环境 和 CocoaPods 从 github 上 clone 一份代码 git clone https://github.com/alibaba/weex.git 把 WeexSDK 导入到你已有的项目，如果没有，可以参考新建项目拷贝 ios/sdk 下面目录到你的项目目录，在添加依赖之前，确保项目目录有 Podfile，如果没有，创建一个，用文本编辑器打开，添加如下依赖 如果使用正式版本如 0.6.1 的，就不需要做 拷贝 ios/sdk 这个操作，直接引用 cocoaPods 的 master repo 上就可以，这个需要在 Podfile 最前面添加 source &apos;https://github.com/CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos; # pod &apos;WeexSDK&apos;, &apos;0.6.1&apos;end 在命令行（terminal）中，切换到当前目录，运行 pod install, 过一会，项目的 .workspace 结尾的文件就被创建出来，到这步，依赖已经添加完了 初始化 Weex 环境在 AppDelegate.m 文件中做初始化操作，一般会在 didFinishLaunchingWithOptions 方法中如下添加 //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel: WXLogLevelAll]; 渲染 weex InstanceWeex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; [_instance renderWithURL:self.url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如renderWithURL,onCreate,onFailed等，可以参见 WXSDKInstance.h的 声明 销毁 Weex Instance 在 viewController 的 dealloc 阶段 销毁掉 weex instance， 释放内存，避免造成内存泄露 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework到工程 参考此处直接导入weexSDK","type":"advanced"},{"title":"如何在本地开发 Weex 页面","path":"cn/v-0.10/guide/develop-on-your-local-machine.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/develop-on-your-local-machine.html","text":"如何在本地开发 Weex 页面使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本章会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖首先，你需要 Node.js 和 weex-toolkit。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.3.1$ npm -v3.10.3 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 $ npm install -g weex-toolkit ``` 国内开发者可以考虑使用淘宝的 npm 镜像 —— [cnpm](https://npm.taobao.org/) 安装 weex-toolkit```bash$ npm install -g cnpm$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第2步：创建文件现在可以开始编写代码了。首先，我们创建一个 .we 文件（Weex 程序的文件后缀（扩展名）是 .we）。 打开空白的 hello.we 文件，输入三个标签，内容为： &lt;template&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; ``` 我们在 [Get started](./index.md) 里已经介绍过 Weex 基本的代码结构：`&lt;template&gt;`、`&lt;style&gt;`、`&lt;script&gt;` 分别对应于 Web 中的 HTML，CSS（`&lt;style&gt;` 标签），JavaScript（`&lt;script&gt;` 标签）。其实，上面的代码就是最简单的 Weex 程序。但是 `.we` 文件是不能直接运行的，这时候需要使用刚才安装好的 weex-toolkit。weex-toolkit 会编译 `.we` 文件，并且创建静态服务器。这里，使用 `weex hello.we` 命令编译该程序。```bash$ weex hello.we 这时，命令行会做几件事： 编译 .we 文件； 启动热加载服务； 启动静态服务器； 拉起浏览器，访问 http://127.0.0.1:8081/weex_tmp/h5_render/?hot-reload_controller&amp;page=hello.js&amp;loader=xhr 这时候，已经可以在浏览器预览 Weex 页面了。不过此时页面是空白的，因为 .we 文件中没有任何实质的内容。 第3步：添加内容修改 weex.we 文件，向 &lt;template&gt; 标签中添加内容。具体代码如下： &lt;template&gt; &lt;div&gt; &lt;text&gt;Hello world&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 保存代码后，浏览器会自动刷新页面，这时会看到浏览器显示了 “Hello world”。 第4步：添加样式现在，对已有的文本内容进行样式修饰。这里将文本颜色设置为红色，字体大小为 50 像素。具体代码如下： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\" style=\"color: #FF0000;\"&gt;Hello world&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text&#123; font-size: 50; &#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 这时候，浏览器已经重新载入了页面。其实，是weex-toolkit开启了热加载。可以看到红色的 “Hello world”。 注意：Weex 支持通过 style 标签来设定样式，也支持内联样式风格。 对于数值，无需添加任何单位（包括 px、em、rem 等），这是建议的写法。如需了解有哪些通用的样式，可以参考 通用样式。 第5步：预览已经在浏览器中看到了刚才的代码效果，为了验证三端是否一致，我们还需 Playground App 验证。 这里，我们需要为 weex hello.we 增加 --qr 参数，表示生成二维码。 $ weex hello.we --qr 然后，使用 Playground 扫码即可。 第6步：调试weex-toolkit 已经集成了 Debugger，只需要使用如下命令即可开启 Debugger 开关调试 hello.we： $ weex debug hello.we 我们输入以上命令开启，会自动打开浏览器，页面上有两个二维码，第一个是 Debugger Server，第二个是 .we 文件的地址。我们在 Playground 中先扫第一个，此时浏览器会进入一个新的页面，请你选择你需要的调试模式： Debugger：将会打开 js debugger 页面，您可以通过 debugger 页面调试 js（诸如打断点 查看js log 和查看调用堆栈等信息）； Inspector：将会打开 inspector 页面，您可以通过这个页面查看 Weex 页面的 element 属性结构，包含高亮元素，展示样式表，以及显示 native 的 log。同时可以打开一个远程的手机镜像，便于查看界面。另外调试方块中的 ElementMode 可以用来选择 element 树显示原始的 native 组件树还是显示面向前端同学的 DSL （HTML）组件树。 选择一种模式后会新开窗口进入调试页面，这时我们再扫第二个二维码即可进入我们想要调试的页面进行调试了。 接下来做什么？到目前为止，你已经可以在 dotWe 或者本地开发 Weex 页面。接下来你可以去学习 Weex 语法 和 开发手册 了解 Weex 更多特性。这些语法和特性，你完全可以用 Playground 运行起来。 如果你已经熟悉 Weex 开发，你应该考虑如何让你的 App 也支持 Weex 页面，或者，怎样用 Weex 开发一个全新的 App 呢？带着这些问题，你可以阅读 开发进阶。","type":"guide"},{"title":"ViewModel APIs","path":"cn/v-0.10/references/api.html","permalink":"https://weex.apache.org/cn/v-0.10/references/api.html","text":"接口你可以在组件的方法中通过 this （Vm）上下文访问这些 API。 例子： &lt;script&gt;module.exports = &#123; methods: &#123; somemethod: function() &#123; this.$vm('someId'); &#125; &#125;&#125;&lt;/script&gt; $(id)不建议使用，请使用 $vm 代替。 $el(id)返回对应 id 的元素对象的引用。 Arguments id (string): 唯一标识符。Returns (Element): 一个元素对象的引用。Tips id 只能保证是当前（页面）组件中是唯一的，如果你需要寻找父组件或子组件，你可以利用组件间的通信模式实现。 延伸阅读： id，Communicate Between Components$vm(id) 返回对应 id 的 vm 对象引用。 Arguments id (String): 唯一标识符。Returns vm (Vm): 一个 Vm 对象引用。Tips id 只能保证是当前（页面）组件中是唯一的，如果你需要寻找父组件或子组件，你可以利用组件间的通信模式实现。 延伸阅读： id，Communicate Between Components$getConfig() 获取当前全局环境变量和配置信息。 Returns config (object): 配置对象； bundleUrl (string): bundle 的 url； debug (boolean): 是否是调试模式； env (object): 环境对象； weexVersion (string): Weex sdk 版本； appName (string): 应用名字； appVersion (string): 应用版本； platform (string): 平台信息，是 iOS、Android 还是 Web； osVersion (string): 系统版本； deviceModel (string): 设备型号 （仅原生应用）； deviceWidth (number): 设备宽度，默认为 750； deviceHeight (number): 设备高度。$call(module, method, …args) 不建议使用，请使用 require(&#39;@weex-module/module&#39;)[method](...args) 代替。查看更多信息：modules。","type":"references"},{"title":"事件冒泡","path":"cn/v-0.10/references/bubble.html","permalink":"https://weex.apache.org/cn/v-0.10/references/bubble.html","text":"事件冒泡 v0.13+Weex 1.0 实现了 W3C 标准的事件冒泡机制。 使用&lt;template&gt; &lt;div class=\"root\" onclick=\"rootClick\" bubble=\"true\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"outer\" onclick=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" onclick=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播，依次触发。 注意需要注意的是: 为了兼容之前的版本，Weex 默认不会开启事件冒泡机制。需要在根元素的属性上，添加 bubble=&quot;true&quot; 来开启冒泡机制。否则，将不会向上传播事件，保持与之前版本的效果相同。 stopPropagation在事件处理函数中，可以使用 e.stopPropagation() 方法，来阻止本次事件向上的传递过程。注意，e.stopPropagation() 与 bubble=&quot;true&quot; 不同，前者只会影响当前元素以及父元素的传播，不会影响子元素的传播；后者是为了版本兼容而增加的开关机制，会全局关闭或者开启冒泡机制，两者可以共同存在使用，如下： &lt;template&gt; &lt;div class=\"root\" onclick=\"rootClick\" bubble=\"true\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"outer\" onclick=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" onclick=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播到父元素被终止，不再继续往根元素传播。","type":"references"},{"title":"Weex 快查手册","path":"cn/v-0.10/references/cheatsheet.html","permalink":"https://weex.apache.org/cn/v-0.10/references/cheatsheet.html","text":"Weex 备忘录Native 组件 code { word-break: break-all; } 组件 特性 样式 事件 特殊父组件 子组件 &lt;div&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;text&gt; value box modelflexpositionbackground-coloropacitycolorfont-sizefont-stylefont-weighttext-decorationtext-aligntext-overflowline-height clickappeardisappear - text only &lt;image&gt; src box modelflexboxpositionbackground-coloropacityresize clickappeardisappear - (none) &lt;scroller&gt; show-scrollbarscroll-direction box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;list&gt; loadmoreoffset box modelflexboxpositionbackground-coloropacity clickappeardisappearloadmorerefreshloading - &lt;cell&gt;&lt;header&gt;&lt;refresh&gt;&lt;loading&gt; &lt;cell&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear &lt;list&gt; (any) &lt;slider&gt; auto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearchange - (any)&lt;indicator&gt; &lt;indicator&gt; - box modelflexboxpositionitem-coloritem-selected-coloritem-size clickappeardisappear &lt;slider&gt; (none) &lt;wxc-navpage&gt; heightbackground-colortitletitle-colorleft-item-titleleft-item-colorright-item-titleright-item-colorleft-item-srcright-item-src box modelflexboxpositionbackground-coloropacity clickappeardisappearnaviBar.leftItem.clicknaviBar.rightItem.click - (any) &lt;wxc-tabbar&gt; tab-items box modelflexboxpositionbackground-coloropacity tabBar.onClick - (none) &lt;embed&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappear - (none) &lt;web&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappearpagestartpagefinisherror - (none) &lt;video&gt; srcplay-statusauto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearstartpausefinishfail - (none) &lt;a&gt; href box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;input&gt; typevalueplaceholderdisabledautofocus box modelflexboxpositionbackground-coloropacityplaceholder-colorcolorfont-sizefont-stylefont-weighttext-align clickappeardisappear - (none) &lt;switch&gt; checked box modelflexboxpositionbackground-coloropacity appeardisappearinputchangefocusblur - (none) Native Modules module apis @weex-module/dom scrollToElement(node, { offset }) @weex-module/modal toast({ message, duration })alert({ message, okTitle }, callback)confirm({ message, okTitle, cancelTitle }, callback(result))prompt({ message, okTitle, cancelTitle }, callback(result, data)) @weex-module/stream fetch({ method, url, headers, type, body }, callback({ status, ok, statusText, data, headers }), progressCallback({ readyState, status, length, statusText, headers})) @weex-module/webview goBack(ref)goForward(ref)reload(ref) @weex-module/navigator push({ url, animated }, callback)pop({ animated }, callback) @weex-module/animation transition(node, { styles, duration, timingFunction, delay, transform-origin }, callback) 特殊的模版语法 &lt;foo x=&quot;abc&quot;&gt; &lt;foo style=&quot;name1: value1; name2: value2&quot;&gt; &lt;foo class=&quot;a b c&quot;&gt; &lt;foo onclick=&quot;methodName&quot;&gt; &lt;foo id=&quot;abc&quot;&gt; &lt;foo if=&quot;expr&quot;&gt; &lt;foo repeat=&quot;item in list&quot;&gt; &lt;foo repeat=&quot;(key,item) in list&quot;&gt; &lt;component type=&quot;foo&quot;&gt; ViewModel APIs this.$vm(el) this.$el(el) this.$getConfig() this.$emit(type, data) this.$dispatch(type, data) this.$broadcast(type, data) ViewModel Options data methods computed init, created, ready events 示例： module.exports = &#123; data: function () &#123; return &#123; x: 1, y: 2 &#125; &#125; methods: &#123; foo: function () &#123; console.log('foo') &#125; &#125;, computed: &#123; z: function () &#123; return this.x + this.y &#125; &#125;, events: &#123; custom: function (e) &#123; console.log(e) &#125; &#125;, init: function () &#123;&#125;, created: function () &#123;&#125;, ready: function () &#123;&#125;&#125;","type":"references"},{"title":"通用特性","path":"cn/v-0.10/references/common-attrs.html","permalink":"https://weex.apache.org/cn/v-0.10/references/common-attrs.html","text":"通用特性特性（attribute）与 HTML 中元素特性类似，提供了与 Weex 元素有关的其他附加信息。所有的元素都可以拥有特性, 特性总是在 Weex 元素的起始标签中定义，并总是以键值对的形式出现，例如：name=&quot;value&quot;。可以使用 Mustache 对特性值进行数据绑定。 Notes! Weex 遵循 HTML attribute 命名规范, 所以请 不要在特性中使用驼峰风格（CamelCase） , 使用-连接符的羊肉串风格（kebab-case） 才是更好的命名方式。 所有 Weex 元素都拥有以下特性： id为 &lt;template&gt; 内定义的元素指定一个唯一的 id，通过 this.$el(id) 可以容易地获取一个 Weex 元素的引用。更多信息可参考 Instance APIs &lt;template&gt; &lt;div id=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 style为元素定义行内样式。 &lt;div style=\"width: 200px; height: 200px; color: #ff0000;\"&gt;&lt;/div&gt;&lt;div style=\"padding: &#123;&#123;x&#125;&#125;; margin: 0\"&gt;&lt;/div&gt; class为元素定义一个或多个类名（引用样式表中的类）。 &lt;div class=\"button\"&gt;&lt;/div&gt;&lt;div class=\"button &#123;&#123;btnStatus&#125;&#125;\"&gt;&lt;/div&gt; repeat我们可以通过 repeat 特性根据一个数组进行渲染，迭代地生成当前标签的内容。repeat 特性有着 item in items 形式的特殊语法，其中，items 是数组数据，item 是数组元素迭代的别名。 &lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 if提供一个布尔值来决定是否显示当前标签。当值为 true 时，元素显示，为 false 时元素隐藏。 &lt;div if=\"true\"&gt;&lt;/div&gt;&lt;div if=\"&#123;&#123;opened&#125;&#125;\"&gt;&lt;/div&gt;&lt;div if=\"&#123;&#123;direction === 'row'&#125;&#125;\"&gt;&lt;/div&gt; appendappend 特性用于控制渲染次序。它的可选值为 tree 或 node，默认为 tree，不支持数据绑定。不同的值会执行不同的渲染过程： append=&quot;tree&quot; 是一次性渲染整个节点树，渲染更高效，但是如果页面太大容易造成较长时间的白屏。 append=&quot;node&quot; 所有节点逐个渲染，整体渲染速度略慢，但是用户体验好一些。 通过 node 和 tree 可以精细化地控制页面展示的逻辑和颗粒度，一般比较好的实践为首屏以内按 tree 解析，首屏以外按 node 解析。 &lt;div append=\"tree\"&gt;&lt;/div&gt;&lt;div append=\"node\"&gt;&lt;/div&gt; 事件处理 (on…)在 Weex 标签上注册事件处理器。以 on 加 事件名为 key，事件处理函数为 value。 &lt;template&gt; &lt;div class=\"btn\" onClick=\"alertMsg\"&gt;&lt;text&gt;Click me&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.btn &#123; justify-content: center; align-items: center; width: 200; height: 100; background-color: #ff0000; border-radius: 5; color: #ffffff;&#125;&lt;/style&gt;&lt;script&gt;var modal = require('@weex-module/modal')module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'click', okTitle: 'alert' &#125;, function() &#123; &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"颜色名称列表","path":"cn/v-0.10/references/color-names.html","permalink":"https://weex.apache.org/cn/v-0.10/references/color-names.html","text":"Weex 支持的所有颜色名称基础颜色关键词: 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词: 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"通用事件","path":"cn/v-0.10/references/common-event.html","permalink":"https://weex.apache.org/cn/v-0.10/references/common-event.html","text":"通用事件Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 示例点击按钮，将弹出弹框，再点击弹框 ×，关闭弹框。 &lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text class=\"btn\" onclick=\"openDialog\"&gt;Show Dialog&lt;/text&gt; &lt;/div&gt; &lt;div id=\"dialog\" class=\"dialog\" if=\"&#123;&#123;isShowDialog&#125;&#125;\"&gt; &lt;div class=\"dialog-backdrop\"&gt;&lt;/div&gt; &lt;div class=\"dialog-content\"&gt; &lt;div class=\"dialog-header\"&gt; &lt;text class=\"dialog-title\"&gt;&#123;&#123;dialogTitle&#125;&#125;&lt;/text&gt; &lt;text class=\"close\" onclick=\"closeDialog\"&gt;×&lt;/text&gt; &lt;/div&gt; &lt;div class=\"dialog-body\"&gt; &lt;text&gt;&#123;&#123;dialogBody&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.dialog-backdrop &#123; opacity: .5; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #000000;&#125;.dialog &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; justify-content: center; align-items: center;&#125;.dialog-content &#123; width: 450; background-color: #ffffff;&#125;.dialog-header &#123; padding: 20; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.dialog-body &#123; padding: 20;&#125;.close &#123; font-size: 50; position: absolute; right: 10; top: 10;&#125;.btn &#123; text-align: center; color: #ffffff; padding: 12; background-color: #3071a9; border-color: #285e8e; border-radius: 4;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; isShowDialog: false, dialogTitle: 'HELLO', dialogBody: 'Weex is best!' &#125;, methods: &#123; openDialog: function (e) &#123; this.isShowDialog = true &#125;, closeDialog: function (e) &#123; this.isShowDialog = false &#125; &#125; &#125;&lt;/script&gt; 体验一下 longpress如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 示例长按按钮，变换背景色。 &lt;template&gt; &lt;div style=\"width: 400; height: 200; background-color: &#123;&#123;bg&#125;&#125;; justify-content: center; align-items: center;\" onlongpress=\"&#123;&#123;update&#125;&#125;\"&gt; &lt;text style=\"font-size: 60\"&gt;Press me&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; bg: '#FF0000' &#125;, methods: &#123; update: function () &#123; this.bg = this.bg === '#FF0000' ? '#00FF00' : '#FF0000' &#125; &#125; &#125;&lt;/script&gt; 体验一下 Appear 事件如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象 type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down 示例当滚到最下方时，最后一个 item 出现，将会弹出弹框。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;viewappear&#125;&#125;\" onviewdisappear=\"&#123;&#123;viewdisappear&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\" onappear=\"alertMsg\" &gt; &lt;text&gt;I will alert a message when I appeared.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'I am appeared.', okTitle: 'Appear' &#125;, function() &#123; &#125;) &#125;, viewappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewappear') &#125;, viewdisappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewdisappear') &#125; &#125; &#125;&lt;/script&gt; 体验一下 Disappear 事件如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象 type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down 示例当向下滚动到第一个 item 消失后，将会弹出弹框。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;viewappear&#125;&#125;\" onviewdisappear=\"&#123;&#123;viewdisappear&#125;&#125;\"&gt; &lt;div class=\"item\" ondisappear=\"alertMsg\" &gt; &lt;text&gt;I will alert a message when I disappeared.&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'I am disappeared.', okTitle: 'Disappear' &#125;, function() &#123; &#125;) &#125;, viewappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewappear') &#125;, viewdisappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewdisappear') &#125; &#125; &#125;&lt;/script&gt; 体验一下 Page 事件注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象 type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例进出页面时，都会弹框提示。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;alertViewappearMsg&#125;&#125;\" onviewdisappear=\"&#123;&#123;alertViewdisappearMsg&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\" onappear=\"alertMsg\" &gt; &lt;text&gt;scroll 11&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertViewappearMsg: function () &#123; modal.alert(&#123; message: 'viewappear.', okTitle: 'viewappear' &#125;, function() &#123; &#125;) &#125;, alertViewdisappearMsg: function () &#123; modal.alert(&#123; message: 'viewdisappear.', okTitle: 'viewdisappear' &#125;, function() &#123; &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"通用样式","path":"cn/v-0.10/references/common-style.html","permalink":"https://weex.apache.org/cn/v-0.10/references/common-style.html","text":"通用样式所有 Weex 组件都支持以下通用样式规则。 盒模型 Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，单位可省略，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：目前在 &lt;image&gt; 和 &lt;text&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。 Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 示例：&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400; height: 200; margin-left: 20;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div repeat=\"(i, v) in list\" class=\"row\"&gt; &lt;div repeat=\"(k, text) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 体验一下 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200; height: 200; background-color: #fc0000; &#125;&lt;/style&gt; 体验一下 定位Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400; height: 400; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150; left: 150; background-color: #0055dd; &#125; .box3 &#123; top: 300; left: 300; background-color: #00ff49; &#125;&lt;/style&gt; 体验一下 其他基本样式 opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式如果对于样式写法需要更多上手参考，可参考 如何做出高性能长列表 如何布局 以及每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"references"},{"title":"ViewModel 选项","path":"cn/v-0.10/references/component-defs.html","permalink":"https://weex.apache.org/cn/v-0.10/references/component-defs.html","text":"组件定义定义组件是通过一组选项来描述一个组件。这组选项总是被赋值给 &lt;script&gt; 标签中的 module.exports 。 module.exports = &#123; // a set of options here&#125; 数据和方法module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, methods: &#123; doThis: function () &#123;...&#125;, doThat: function () &#123;...&#125; &#125;, ...&#125; data 选项是一个函数，它返回这个视图模型可监听的数据对象。而 methods 是一个映射，其中包含所有视图模型的方法。 每个 data 或 method 属性将被代理到视图模型实例中。所以，你能通过 this.x 读写数据，或者通过 this.doThis() 调用方法。 一个完整的例子： &lt;template&gt; &lt;div style=\"width: &#123;&#123;w&#125;&#125;; height: &#123;&#123;h&#125;&#125;; background-color: red;\" onclick=\"update\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;w: 750, h: 200&#125; &#125;, methods: &#123; update: function (e) &#123; this.h += 200 &#125; &#125; &#125;&lt;/script&gt; 事件module.exports = &#123; data: ..., methods: &#123; foo: function () &#123; ... this.$emit('customtype1', data) &#125; &#125;, events: &#123; customtype1: function (e) &#123; console.log(e.type, e.detail) &#125; &#125;, ...&#125; events 选项允许你在视图模型被创建时注册自定义事件。然后，它会监听这些类型的事件，并通过函数类型的值处理它们。 Weex 会把一个事件对象作为第一个参数传递给其绑定的事件，这个事件对象在 e.detail 中包含事件数据。 生命周期module.exports = &#123; data: ..., methods: ..., init: function () &#123; console.log('ViewModel constructor begins') &#125;, created: function () &#123; console.log('Data observation finished') &#125;, ready: function () &#123; console.log('Virtual DOM finished') &#125;, ...&#125; Weex 视图模型现在支持生命周期内的钩子函数，这些钩子函数能被写为组件选项： init: 在视图模型的构造函数开始调用时激活； created: 当视图模型监听默认数据，但还未编译模板时激活； ready: 当视图模型监听默认数据并且编译模板生成虚拟DOM后被激活。 注意：当 methods、events 或生命周期方法作为参数传递给别的函数时，务必确认函数执行时的上下文符合您的预期，例如： module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, ready: function () &#123; // `undefined` // 因为上下文发生了变化 this.foo(this.bar) // `1` // 正确绑定上下文之后可以得到预期的值 this.foo(this.bar.bind(this)) &#125;, methods: &#123; foo: function (fn) &#123; return fn() &#125;, bar: function () &#123; return this.x &#125; &#125;&#125;","type":"references"},{"title":"手势","path":"cn/v-0.10/references/gesture.html","permalink":"https://weex.apache.org/cn/v-0.10/references/gesture.html","text":"手势注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上设置 on 特性来监听手势即可。 手势类型目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三中类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedToucheschangedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 约束目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。 示例&lt;template&gt;2&lt;div ontouchstart=\"handleTouchstart\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;2methods: &#123;22handleTouchstart: function(eventProperties) &#123;222// handling with the Event Properties22&#125;2&#125;&#125;&lt;/script&gt; 如上面代码所示，一个 touchstart 事件会在触摸点与触摸面接触的时候触发。","type":"references"},{"title":"","path":"cn/v-0.10/references/replace.html","permalink":"https://weex.apache.org/cn/v-0.10/references/replace.html","text":"Replace optionThe replace option is boolean type. It determined whether this composed component will be replaced with the &lt;template&gt; content or just as a normal &lt;div&gt; element which include the &lt;template&gt; content. For example: &lt;element name=&quot;foo&quot;&gt; &lt;template&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; replace: false // by default &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;foo&gt;&lt;/foo&gt;&lt;/template&gt; will rendered as: &lt;div&gt; &lt;text&gt;Foo&lt;/text&gt;&lt;/div&gt; but: &lt;element name=&quot;foo&quot;&gt; &lt;template&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; replace: true &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;foo&gt;&lt;/foo&gt;&lt;/template&gt; will rendered as: &lt;text&gt;Foo&lt;/text&gt; So you can choose a way you need or like to manage your virtual DOM structure."},{"title":"特殊元素","path":"cn/v-0.10/references/special-element.html","permalink":"https://weex.apache.org/cn/v-0.10/references/special-element.html","text":"特殊元素&lt;content&gt;&lt;content&gt; 在编写组件模板时作为作为内容节点元素存在，使用时将被真正的元素替换。 替代写法: &lt;slot&gt;。 示例如示例中写法，&lt;content&gt; 节点被 &lt;text&gt; 替代。 &lt;element name=\"item\"&gt; &lt;template&gt; &lt;div&gt; &lt;content&gt;&lt;/content&gt; &lt;/div&gt; &lt;/template&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;item&gt; &lt;text&gt;Content Text&lt;/text&gt; &lt;/item&gt; &lt;/div&gt;&lt;/template&gt; 体验一下","type":"references"},{"title":"文本样式","path":"cn/v-0.10/references/text-style.html","permalink":"https://weex.apache.org/cn/v-0.10/references/text-style.html","text":"文本样式v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性 color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}：字体粗细程度。可选值 normal | bold，默认为 normal。 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考 颜色关键字列表。","type":"references"},{"title":"CSS 单位","path":"cn/v-0.10/references/units.html","permalink":"https://weex.apache.org/cn/v-0.10/references/units.html","text":"CSS 单位CSS color 单位支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。所以你也可以省略 px 单位后缀，直接写数字。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48; line-height: 64; &#125;.classB &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 注意：也可以将所有的 px length 值简化为一个数字。 CSS percentage 单位 (暂不支持)表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"references"},{"title":"Devtools for Android","path":"cn/v-0.10/tools/devtools-android.html","permalink":"https://weex.apache.org/cn/v-0.10/tools/devtools-android.html","text":"Devtools for Android Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page.At present The devtools consist of two part : Inspector and Debugger. If you want it work well, you must install a weex-devtool as debug server. InspectorInspector can be used to show your Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. DebuggerDebugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Install and launch devtools serverOpen your terminal then type npm install -g weex-toolkit and run.Launch it just type and run the command weex debug, then a Chrome web page will be opened. Use on an android device or emulatorTaste of first debug with playgroundIf you are a green hand to the debug of weex, we recommend you to try your first debug with playground, what you need to do is just launch the playground and scan the QR code shown in the debug page which wound opened if the devtools server have been launched. after you scan the QR code, the web page will list your connected devices. How Debugger WorksDevtools expands Chrome Debugging Protocol and the mechanism of communication between client and debug sever is based on JSON-RPC. Devtools ClientDevtools Client is integrated in App as aar, it connects to debug server through webscoket protocol with out permission check. I recommend you just packaged it in your debug version consider of the security mechanism. Devtools Debug ServerDevtools Debug Server is the center node of the communication, it connects to both app and chrome, acts as the turn server of debugging protocol messages and the manager of the js runtime. Chrome FrontEndChrome’s V8 engine acts as the javascript runtime, when debug mode is enabled, all the js code run on it. On the other side we also reuse most of the Chrome’s debugging user interface, such as set breakpoint, see call stack and so on. Enable devtools in your own appOf course you can reuse the code of playground to build your own app, that is the simplest way to let your app’s js code debuggable. On the other hand QR code is not necessary, if your review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. following those steps you can do the same thing. Gradle dependency on inspector.There are two choices to set the dependency, the Choice A is recommanded if you have no change to weex_sdk or inspector, while if you use your own custom weex_sdk or inspector Choice B is suitable. A - aar dependency from jcenter.dependencies &#123; compile &apos;com.taobao.android:weex_inspector:0.0.8.1&apos;&#125; I strongly recommend you use the latest version since both weex sdk and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. B - source code dependency. you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(&apos;:inspector&apos;)&#125; Version compatibility weex sdk weex inspector debug server 0.8.0.1+ 0.0.8.1 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 Initialize in your XXXApplication file. public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;/*&quot;DEBUG_SERVER_HOST&quot;*/); &#125; private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = &quot;ws://&quot; + host + &quot;:8088/debugProxy/native&quot;; &#125;&#125; Ship It! You must launch your bundle server firstly. In your weex dir, run command “./start”; Launch your remote debug server. Run command weex debug, chrome will open a web page show a simply guidance and QR code; Launch your app and make sure debug mode was enabled. You will see a device list in the chrome web page opened by last step, each device item have two button, Debugger and Inspector;There are two way to enable debug mode: scaning the QR code and handle the content just like the playground have done. init it in the XXXApplication by calling initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;), if you call initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;) after weex sdk inited, you need to call WXSDKEngine.reload() to refresh the runtime. Once you click the button Inspector chrome will open a page show the inspector view, on the other side, click the button Debugger chrome will open a new page to show the debug view; OPTIONS[OPTION] set your remote bundle server ip.For example, in the playground it is in the `IndexActivity.java`, you need to change the value of `DEFAULT_IP` in IndexActivity.java from `&quot;your_current_IP&quot;` to a server ip like `&quot;30.30.30.150&quot;`: private static final String DEFAULT_IP = &quot;30.30.30.150&quot;; // &quot;your_current_IP&quot;; [OPTION] enable network inspection.OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new OkHttpInterceptor()); Notice The network inspection only support OKHttpClient right now!!! If you want to use the network inspection to catch your bundle request, you must change your bundle server ip to the real server ip. Known Issues You can report issues and bugs here. We will reply as soon as possible.","type":"tools"},{"title":"Devtools for iOS","path":"cn/v-0.10/tools/devtools-ios.html","permalink":"https://weex.apache.org/cn/v-0.10/tools/devtools-ios.html","text":"Devtools for iOS通过Chrome开发者工具远程调试你的原生iOS app 启动weex-devtool： 安装和运行 weex-devtool $:npm install -g weex-devtool$:weex-devtool 它会启动chrome浏览器，展示wss ip 地址在chrome地址栏。 playground 安装 WXDevtool 安装依赖. $:pod install 使用 AppDelegate.m 头文件 #import &quot;WXDevTool.h&quot; 在App启动的时候初始化 inspector 注意: The inspector API 必须在weex初始化之前调用 (void)setDebug:(BOOL)isDebug; isDebug默认是NO，那么你打开的是inspect模式。假如设置isDebug为YES，那么打开debug模式和inspect模式。 (void)launchDevToolDebugWithUrl:(NSString *)url; wssip 是 展示在 chrome 地址栏的wss 地址. 打开 debug 模式 和 inspector 模式 eg：- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } 打开 inspect 模式, 移除 @selector(setDebug:) 或者 增加 [WXDevTool setDebug:NO] eg：- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } 编译和运行APP，chrome会显示你的设备，选择inspector。 支持不同级别的Log打印。 eg: #import “WXDevTool.h” PDLogE()/PDLogW() WXDevtool依赖 你的app必须链接下面的frameworks/dylibs libicucore.dylib CFNetwork.framework CoreData.framework Security.framework Foundation.framework","type":"tools"},{"title":"Devtools","path":"cn/v-0.10/tools/devtools.html","permalink":"https://weex.apache.org/cn/v-0.10/tools/devtools.html","text":"Devtoolsweex devtools是专门为weex定制的一款实现了Chrome Debugging Protocol的inspect/debug工具，能够帮助你快速查看app运行状态和调试weex中的Javascript代码，当前支持IOS和Android两个平台。 安装$ npm install -g weex-toolkit 用法 weex debug [options] [we_file|bundles_dir] 选项: -h, --help 显示帮助-V, --verbose 显示debug服务器运行时的各种log-v, --version 显示版本-p, --port [port] 设置debug服务器端口号 默认为8088-e, --entry [entry] debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码)-m, --mode [mode] 设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer 开启调试$weex debug 单纯启动一个调试服务器,并同时唤起chrome浏览器打开调试主页.这个调试主页上会有一个二维码,使用Playground App扫这个二维码可以开启Playground调试.开启调试后,设备列表中会出现您的设备,根据提示进行后续的调试操作 调试 we文件$weex debug your_weex.we 这个命令会将your_weex.we编译成bundlejs文件 部署到debug服务器并启动debug服务器如上述命令那样.打开的调试主页会多显示一个二维码,使用playground app扫这个码可以加载your_weex.we.(注意要先扫描开启调试的那个码)这个命令会自动检测your_weex.we文件变动,如果发现内容被修改则立即重新编译部署,并刷新debugger页面. 调试整个bundle/we文件夹$weex debug your/we/path -e index.we 这个命令会编译你指定目录下的所有的we文件,并把编译好的bundlejs部署到debug服务器,他们的地址会映射到 http://lcoalhost:8088/weex/ 下比如 your/we/path/index.we 可以通过http://lcoalhost:8088/weex/index.js访问your/we/path/demo/test.we 可以通过http://lcoalhost:8088/weex/demo/index.js -e参数可以指定一个入口的we文件,这个文件的地址会显示在调试主页上(作为二维码) 特性连接设备 Inspector Inspector 能够用来查看 Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View 等。 Element NetWork查看网络请求的总耗时和延时 查看网络请求的header和response 控制台 资源 Debugger 调试器用来调试weex中的js代码，能够设置断点、查看调用栈。 Breakpoint and CallStack 集成devtools Android 请参考文档 Weex devtools (Android), 其中有详细说明。 IOS 请参考文档 Weex devtools (IOS), 其中有详细说明。","type":"tools"},{"title":"Transormer (英)","path":"cn/v-0.10/tools/transformer.html","permalink":"https://weex.apache.org/cn/v-0.10/tools/transformer.html","text":"gulp-weex gulp plugin for weex transformer Usagevar gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) OptionsoldFormatwhether transform to old format. default: false. isEntrywhether is an entry module which has bootstrap(...). default: true.","type":"tools"},{"title":"Customize a native Component","path":"v-0.10/guide/how-to/customize-a-native-component.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/customize-a-native-component.html","text":"How to customize a native Component ?Weex has wrapped up the most critical platform components, such as ScrollView, ListView, Text, Imageview and so on. Certainly these components can not completely meet your need. And thousands of native UI components that always be using in our project may be required to integrate into Weex easily. Fortunately, it’s quite convenient to wrap up your own components that should be from any existing components. Step By Step Customized components must inherit from WXComponent or WXContainer; @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK; The access levels of method must be public; The component class can not be an inner class; Customized components should not be obfuscated by tools like ProGuard; Component methods will be invoked on the UI thread, so do not contain time-consuming operations here; Weex parameter’s type can be int, double, float, String, Map, List, self-defined class that implements WXObject interface; Refer to the following example:package com.taobao.weex.ui.component;……public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject node, WXVContainer parent, String instanceId, boolean lazy) &#123; super(instance, node, parent, instanceId, lazy); &#125; @Override protected void initView() &#123; //TODO:your own code …… &#125; @Override public WXFrameLayout getView() &#123; //TODO:your own code ……… &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; Component should be registeredWXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class);","type":"guide"},{"title":"Customize native APIs","path":"v-0.10/guide/how-to/cuszomize-native-apis.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/cuszomize-native-apis.html","text":"How to customize native APIs ?Weex SDK provides only rendering capability, rather than having other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement them yourselves.The example below will describe how to extend weex with native logic or ‘bridge’ your existed native code. A URLHelper ExampleCreate your own WXModule in native:public class URLHelperModule extends WXModule&#123;2private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\";2@WXModuleAnno2public void openURL(String url)&#123;22if (TextUtils.isEmpty(url)) &#123;222return;22&#125;22StringBuilder builder=new StringBuilder(\"http:\");22builder.append(url);22Uri uri = Uri.parse(builder.toString()); Intent intent = new Intent(Intent.ACTION_VIEW, uri);22intent.addCategory(WEEX_CATEGORY); mWXSDKInstance.getContext().startActivity(intent);2&#125;&#125; Notice the @WXModuleAnno, use this annotation to mark the methods you wanna expose to javascript.If your also want to callback to javascript, you should define a callbackId parameter to received ‘JS callback function id’: public class URLHelperModule extends WXModule&#123;22@WXModuleAnno2public void openURL(String url,String callbackId)&#123;22//...22//callback to javascript 22Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();22result.put(\"ts\", System.currentTimeMillis());22WXBridgeManager.getInstance().callback(mWXSDKInstance.getInstanceId(), callbackId, result);2&#125;&#125; Register your module to engine:try &#123;2 WXSDKEngine.registerModule(&quot;myURL&quot;, URLHelperModule.class);//&apos;myURL&apos; is the name you&apos;ll use in javascript2&#125; catch (WXException e) &#123;2 WXLogUtils.e(e.getMessage());2&#125; Now, you can use eventModule in javascript like this:let URLHelper = require('@weex-module/myURL');//same as you registeredURLHelper.openURL(\"http://www.taobao.com\",function(ts)&#123;2console.log(\"url is open at \"+ts);&#125;); Things you need to note: Customized components must inherit from WXModule; @WXModuleAnno annotation must be added, as it is the only way to be recognized by Weex; The access levels of method must be public; The module class also can not be an inner class; Customized components should not be obfuscated by tools like ProGuard; Module methods will be invoked on the UI thread, so do not put time-consuming operations there; Weex parameter’s type can be int, double, float, String, Map, List, self-defined class that implements WXObject interface;","type":"guide"},{"title":"Debug in html5 renderer","path":"v-0.10/guide/how-to/debug-with-html5.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/debug-with-html5.html","text":"How to debug in html5 renderer ?Since weex-html5 can run on a modern mobile browser, it’s naturally supported to debug weex-html5 code in browsers’ dev tools. Use browser’s devTools to iterate, debug and profile your weex-html5 app. Take chrome’s debug tool as a example: ElementsUse elements’ panel to inspect the layout and design of the weex-html5 page, and manipulate the DOM and CSS to do some experiment freely. ConsoleYou can use console.log to log information on console, but it’s highly recommended to use nativeLog instead, since nativeLog can run on a native platform based on a browser. The defect of nativeLog is that it’s not supported to trace it from the console to the source file which the nativeLog is called in, therefore in this situation you’d better use console.log, and you should make sure this code will not run on native platform (otherwise a exception or a crash will be caused). BreakpointsYou can set breakpoints to debug code. Breakpoints are one of the most effective way to debug code. Breakpoints enable you to pause script execution and then investigate the call stack variable values at that particular moment in time. Manual breakpoints are individual breakpoints that you set on a specific line of code. You can set these via Chrome DevTools GUI, or by inserting the debugger keyword in your code. Locate your bugGenerally speaking, there are three possible layer the bug could happen on: the renderer (weex-html5), the js-framework (weex-js-framework) and the transformer (gulp-weex). Here are some suggestions to locate your bug so that you can recognize which layer the bug is on: check the console for errors. In debug mode if there is a error happend there will be info about it on the console. in bridge/receiver.js, whether the callNative function is called. whether the supposed to be called API method is actually called and executed. whether the callJS method for event firing or callback executing is called. otherMore info about how to debug h5 pages on chrome devTools: chrome’s devTools docs","type":"guide"},{"title":"Preview in native","path":"v-0.10/guide/how-to/preview-in-playground-app.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/preview-in-playground-app.html","text":"How to preview weex code in sample-app ?Weex Sample Step By Step Clone Weex from github https://github.com/apache/incubator-weex/ Use Android Studio open Android Sample 。 run Sample project. into Sample homePage，you will see this picture Click the icon to the top right of the page to enter the two-dimensional code scanning useWeex-Toolkitmake .we to a QR code you will see the page rended by Weex","type":"guide"},{"title":"Require 3rd Party Libs","path":"v-0.10/guide/how-to/require-3rd-party-libs.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/require-3rd-party-libs.html","text":"How to require 3rd Party Libs ?In the paragraph Maintain Your Component Code, we learn that JavaScript code can be written in &lt;script&gt; tag in one component. But there must be some common functions or modules in your project, such as parsing url params, extending properties from some objects to another object and so on. It’s a bad practice to copy and paste them in each component, therefore there’s a urgent need of require. Weex provides CommonJS require syntax for developers. Let take extend for example. Require Local Js ModulesA basic implementation of extend is as follows, and it’s placed in directory path ./common/utils.js. function extend(dest, src) &#123; for (var key in src) &#123; dest[key] = src[key] &#125;&#125;exports.extend = extend In a .we file, extend can be used with the help of require: &lt;script&gt; var utils = require('./common/utils') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; utils.extend(obj1, obj2) // obj1 =&gt; &#123;a: 1, b: 2&#125;&lt;/script&gt; Require Installed Node ModulesBesides, underscore is a JavaScript library that provides a whole mess of useful functional programming helpers without extending any built-in objects. It implements a more robust version of extend. We can use underscore’s extend instead of the version implemented by ourselves. After installing underscore to the node_modules directory, we can require and use it. $ npm install underscore &lt;script&gt; var _ = require('underscore') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; var obj3 = &#123;c: 3&#125; var ret = _.extend(obj1, obj2, obj3) // ret =&gt; &#123;a: 1, b: 2, c: 3&#125;&lt;/script&gt;","type":"guide"},{"title":"Transform Code into Js Bundle","path":"v-0.10/guide/how-to/transform-code-into-js-bundle.html","permalink":"https://weex.apache.org/v-0.10/guide/how-to/transform-code-into-js-bundle.html","text":"Transform Code into Js BundleParagraphs Maintain Your Component Code and Require 3rd Party Libs show us how to write and organize weex code. However, Weex DSL code must be transformed to js bundle so that js framework can parse and execute it for iOS, Android and HTML5 portal. For more information, please refer to How It Works and JS Bundle Format. Now come back to the topic transform code into js bundle. There are several ways to achieve the goal. weex-toolkit$ npm install -g weex-toolkit transform a we file to JS Bundle$ weex your_best_weex.we -o . your_best_weex.we will be transform to JS Bundle file your_best_weex.js , saved in your current directory transform a we file to JS Bundle , watch this file ，auto run transformer if change happen.$ weex your_best_weex.we -o . --watch transform every we file in a directory$ weex we/file/storage/path -o outputpath every we file in we/file/storage/path will be transformed to JS Bundle , saved in outputpath path please access npmjs.com for more information about weex-toolkit. transformernpm install weex-transformer CLI ToolUsage: transformer [options] &lt;file...&gt;Options: -h, --help output usage information -V, --version output the version number -l, --oldFormat [value] whether to transform to old format (default: false) -e, --isEntry [value] whether is an entry module which has `bootstrap` (default: true) -o, --output [path] the output file dirname API transform(name, code, path, elements, config) var transformer = require('weex-transformer')var output = transformer.transform('foo', '/* code here */', '.', &#123;&#125;) params: name: string, current bundle name code: string, source code path: string optional, useful when find custom component in a certain path elements: object optional, existed custom component map config: object optional oldFormat: whether to transform to old format (default: false) isEntry: whether is an entry module which has bootstrap (default: true) returns: an object with keys result: string, all custom components define() and final bootstrap() logs: array, corresponding warning &amp; error logs gulp weex$ npm install gulp-weex var gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) Options: oldFormat: whether to transform to old format (default: false) isEntry: whether is an entry module which has bootstrap (default: true)","type":"guide"},{"title":"Communications","path":"v-0.10/guide/syntax/comm.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/comm.html","text":"Communicate Between ComponentsFor Child-Parent CommunicationChildren component can use this.$dispatch([String type], [Object detail]) method passing information to parent component. first argument meaning type of message , second argument is the message object. If any parent of the child component register the same type of listener using $on([String type], [Function callback]) method , the callback will be execute with one argument , the message object will be detail property of the the argument. eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; this.$dispatch('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;foo title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; this.$on('notify', function(e) &#123; // when &lt;foo&gt; image tag be clicked ,the function will be executing. // e.detail is `&#123;a: 1&#125;` &#125;) &#125; &#125;&lt;/script&gt; For Parent-Child CommunicationParent component can use this.$vm([String id]) get vm instance of child component. you can access child component information using the vm instance. &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; setTitle: function (t) &#123; this.title = t &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo id=\"fooEl\" title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; var foo = this.$vm('fooEl') foo.setTitle('...') foo.imageUrl = '...' &#125; &#125; &#125;&lt;/script&gt; Parent to Children (multi-child) CommunicationParent can using this.$broadcast([String type], [Object detail]) broadcast message to all of children. eg: &lt;we-element name=\"bar\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; var self = this this.$on('changeImage', function(e) &#123; self.imageUrl = e.detail.imageUrl &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;bar&gt;&lt;/bar&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '' &#125;, created: function() &#123; var self = this this.$on('changeTitle', function(e) &#123; self.title = e.detail.title &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$broadcast('changeTitle', &#123; title: '...' &#125;) this.$broadcast('changeImage', &#123; imageUrl: '...' &#125;) &#125; &#125; &#125;&lt;/script&gt; Siblings Communicationsiblings components can using common parent as bridge for passing information eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; methods: &#123; callbar: function () &#123; this.$dispatch('callbar', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"bar\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; created: function() &#123; this.$on('callbar', function(e) &#123; // e.detail.a &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; var self = this this.$on('callbar', function(e) &#123; self.$broadcast('callbar', e.detail) &#125;) &#125; &#125;&lt;/script&gt; At last, you can learn how to write config &amp; data for a Weex page.","type":"guide"},{"title":"Page Config & Data","path":"v-0.10/guide/syntax/config-n-data.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/config-n-data.html","text":"Page Config &amp; DataYou can write some instance config and data in some additional &lt;script&gt; at the top-level Weex component. the instance config could declare some meta informations like which sdk/client version it supports or “downgrade” to HTML5 renderer. This part would be extended more in the future. the instance data could set an external data which would be processed instead of the default top-level component data. They all make Weex files more extendable and configurable and works easy with other tools &amp; services like CMS system. &lt;!-- definition of sub components --&gt;&lt;element name=\"sub-component-a\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-b\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-c\"&gt;...&lt;/element&gt;&lt;!-- definition of top-level component --&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123;return &#123;x: 1, y: 2&#125;&#125; &#125;&lt;/script&gt;&lt;!-- instance config and data --&gt;&lt;script type=\"config\"&gt; &#123; downgrade: &#123; ios: &#123; os: '9', // all of 9.x.x app: '~5.3.2', framework: '^1.3', // all of 1.3.x deviceModel: ['AAAA', 'BBBB'] &#125;, android: &#123; os: '*', // all of version app: '^5', framework: '', deviceModel: '' &#125; &#125; &#125;&lt;/script&gt;&lt;script type=\"data\"&gt; &#123;y: 200&#125;&lt;/script&gt; Notice that these two additional &lt;script&gt; are both optinal and have type=&quot;config|data&quot; attribute and only works when it’s the top-level component of a Weex instance. So that’s all about Weex syntax. For more reading, please check out: how-tos articles and advanced topics.","type":"guide"},{"title":"Composed Component","path":"v-0.10/guide/syntax/composed-component.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/composed-component.html","text":"Composed ComponentIf some part of weex file is reused often, you could create a composed component represent these part. You can create a file named foo.we to define a composed component, the component name is just &lt;foo&gt;. &lt;!-- foo.we --&gt;&lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\" style=\"width:100;height:100;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: null, image: null &#125; &#125;&lt;/script&gt; The content of foo.we also consists of &lt;template&gt;, &lt;style&gt; and &lt;script&gt;. Once composed component been defined, you can use &lt;foo&gt; in a file which is in the same folder with foo.we. &lt;template&gt; &lt;foo title=\"...\" image=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt; Nesting ComponentsComposed component supports nesting. For example: &lt;!-- somepath/foo.we --&gt;&lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; // The key is required if you want this property observed // and could be updated from changing parent attribute title: null, image: null &#125; &#125;&lt;/script&gt; &lt;!-- somepath/foo-list.we --&gt;&lt;template&gt; &lt;container&gt; &lt;text&gt;&#123;&#123;description&#125;&#125;&lt;/text&gt; &lt;foo repeat=\"&#123;&#123;list&#125;&#125;\" title=\"&#123;&#123;text&#125;&#125;\" image=\"&#123;&#123;img&#125;&#125;\"&gt;&lt;/foo&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; description: '', // If no keys written here. There will be no data binding effect // from parent attribute \"list\". list: [] &#125; &#125;&lt;/script&gt; &lt;!-- somepath/main.we --&gt;&lt;template&gt; &lt;foo-list list=\"&#123;&#123;list&#125;&#125;\"&gt;&lt;/foo-list&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; The main.we uses &lt;foo-list&gt; from foo-list.we. And &lt;foo-list&gt; uses &lt;foo&gt; from foo.we. Notes Every composed component have an independent &lt;style&gt; work scope. If child component have id attribute, you can access the context of the child component by this.$vm(id) and find an element by this.$el(id). See more about find an element. Please refer to communicate between components for more communication issues. The keys must be existed in data options explicitly if you want to make the data observation work both through inside data changes and outside attribute changes. Next is how to find an element.","type":"guide"},{"title":"Data-Binding","path":"v-0.10/guide/syntax/data-binding.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/data-binding.html","text":"Data-BindingIn Weex, we use the mustache syntax {{...}} to bind data in &lt;template&gt; which are defined in &lt;script&gt;. Once data and template is bound, the data changes will influence the corresponding template content immediately and automatically. Binding data path&lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 48, title: 'Alibaba Weex Team' &#125; &#125;&lt;/script&gt; The code above will bind the title and size data field to template. We can also use . syntax to bind cascading data structure. Let’s look at the following code snippet: &lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;title.size&#125;&#125;\"&gt;&#123;&#123;title.value&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: &#123; size: 48, value: 'Alibaba Weex Team' &#125; &#125; &#125;&lt;/script&gt; In-template expressionInside data bindings, Weex supports simply javascript expressions, e.g. &lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125; &#125;&lt;/script&gt; The expression will be evaluated in the data scope of current context. NOTE: EACH BINDING CAN ONLY CONTAIN ONE SINGLE EXPRESSION Computed Properties0.5 According to simple operations, in-template expressions are very convenient. But if you want to put more logic into the template, you should use a computed property. e.g. &lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left:10px;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName &#125;, set: function(v) &#123; var s = v.split(' ') this.firstName = s[0] this.lastName = s[1] &#125; &#125; &#125;, methods: &#123; changeName: function() &#123; this.fullName = 'Terry King' &#125; &#125; &#125;&lt;/script&gt; Here we have declared a computed property fullName. The function we provided will be used as the getter function for concating firstName and lastName. Otherwise when you call changeName after click, the setter will be invoked and this.firstName and this.lastName will be updated accordingly. NOTE: data and methods can’t have duplicated fields. ‘Cause in the execution context – this, we can access both of them. Usage of some special attributes in Data-BindingStyles: style or classthe style of a component can be bind using the style attribute: &lt;template&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;; color: &#123;&#123;color&#125;&#125;; ...\"&gt;...&lt;/text&gt;&lt;/template&gt; while style can also get bound with class attribute, multiple classnames can be split by spaces: &lt;template&gt; &lt;container&gt; &lt;text class=\"&#123;&#123;size&#125;&#125;\"&gt;&lt;/text&gt; &lt;text class=\"title &#123;&#123;status&#125;&#125;\"&gt;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; here if and have empty value, then only class=&quot;title&quot; will be rendered. See more about style and class Event Handler: on...The event handler is an attribute which name has a prefix on.... The other part of attribute name is event type and the value is event handler name. We don’t need to add mustache around the method name or add parentheses to call it. &lt;template&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; toggle: function () &#123; // todo &#125; &#125; &#125;&lt;/script&gt; if &amp; repeatif attribute can control the display of a component by a truthy/falsy value. &lt;template&gt; &lt;container style=\"flex-direction: column;\"&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image src=\"...\" if=\"&#123;&#123;shown&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; We can also use repeat attribute to generate a list. NOTE: When you want to mutate an array in data. Something limitations existing below: When you directly set an item with the index (vm.items[0] = {};), it won’t trigger view update. So we have a prototype methods: $set(index, item). // same as `example1.items[0] = ...` but triggers view updateexample1.items.$set(0, &#123; childMsg: 'Changed!'&#125;) When you modify the length of the Array (vm.items.length = 0), it won’t trigger view update too. We recommend you just replace items with an empty array instead. // same as `example2.items.length = 0` but triggers view updateexample2.items = [] See more about display logic control staticstatic attribute can cancel the data binding, and the data changes will not be synchronized to UI. &lt;template&gt; &lt;div static&gt; &lt;text&gt;&#123;&#123; word &#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; ready: function() &#123; this.word = 'Data changes' &#125;, data: &#123; word: 'Hello, static' &#125; &#125;&lt;/script&gt; As shown above, after the static attribute is added, the rendering result will be Hello, static, which is equivalent to rendering a static node. The change of the data word in ready function will not be listened, so the text value will not change.static property is designed to reduce the long list or pure static page memory overhead. Be careful with it, as it will likely break your page logic. Next, let’s have a look at style and class.","type":"guide"},{"title":"Display Logic Control","path":"v-0.10/guide/syntax/display-logic.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/display-logic.html","text":"Display Logic ControlThere are two attributes for display logic control: if and repeat. We can create Weex page structure and effects more flexible with them. Notes: The display logic could’t apply on the root element within &lt;template&gt;, please don’t use if or repeat directive on it. ifif attribute can control the display of a component by a truthy/falsy value. If the value is truthy, then the component will generated, otherwise it will be removed. &lt;template&gt; &lt;container&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image src=\"...\" if=\"&#123;&#123;shown&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; repeatrepeat statement is just for array rendering. Every item in an array is also a structured data. This means in repeated component, you can bind their item properties directly. &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .male &#123;...&#125; .female &#123;...&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;gender: 'male', nickname: 'Li Lei', avatar: '...'&#125;, &#123;gender: 'female', nickname: 'Han Meimei', avatar: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; The origin data properties which not belongs to the array will also be bound: &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125; - &#123;&#123;group&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .male &#123;...&#125; .female &#123;...&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; group: '...', list: [ &#123;gender: 'male', nickname: 'Li Lei', avatar: '...'&#125;, &#123;gender: 'female', nickname: 'Han Meimei', avatar: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; An extension of repeat syntaxuse default $index for the index of array.e.g. &lt;div repeat=\"&#123;&#123;list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;&lt;/text&gt;&lt;div&gt; specify the key and value of array.e.g. &lt;div repeat=\"&#123;&#123;v in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;, &#123;&#123;v.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;div repeat=\"&#123;&#123;(k, v) in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;k + 1&#125;&#125;, &#123;&#123;v.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; use track-by to specify unique attributeBy default when replacing an array, repeat will cause the entire list to be re-rendered. However you can use track-by to specify an unique attribute as a hint, so that weex can reuse existing elements as much as possible. NOTE: DO NOT USE DATA-BINDING SYNTAX FOR track-by e.g. &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" track-by=\"nickname\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125; - &#123;&#123;group&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt; Later on, when you replace the array including an item of the same nickname, it knows it can reuse the existing scope and DOM elements associated with the same nickname. Omitted mustache wrapperParticularly for the if and repeat attribute, the mustache wrapper in values could be omitted: just the same as data-binding syntax. &lt;template&gt; &lt;container&gt; &lt;text if=\"shown\"&gt;Hello&lt;/text&gt; &lt;text if=\"&#123;&#123;shown&#125;&#125;\"&gt;Hello&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123;return &#123;shown: true&#125;&#125; &#125;&lt;/script&gt; The two &lt;text&gt; components are both displayed. Next is render logic control.","type":"guide"},{"title":"Events","path":"v-0.10/guide/syntax/events.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/events.html","text":"EventsWeex allow &lt;template&gt; to bind event type and handler on an Element. The attribute name is the event type with prefix on... and the attribute value is handler method name. For instance: onclick=&quot;handler&quot;. e.g. &lt;template&gt; &lt;image onclick=\"handler\" ...&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; handler: function (e) &#123; // TODO &#125; &#125; &#125;&lt;/script&gt; When user clicks the image , handler function which defined in &lt;script&gt; code will be executed. Inline HandlerBeside a handler method name, you can also call a handler inline. e.g.&lt;template&gt; &lt;image onclick=\"handler('arg1', $event)\" ...&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; handler: function (arg1, e) &#123; // TODO &#125; &#125; &#125;&lt;/script&gt; Event ObjectWhen an event handler called, it will receive an event object as the first argument. Every event object will contains following properties. type: event name, eg: click target: target Element of the event timestamp: time stamp that event triggered Next, let’s have a look at display logic control.","type":"guide"},{"title":"Find an Element","path":"v-0.10/guide/syntax/id.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/id.html","text":"Find an ElementIn Weex, we may set the id property for a particular element, just as unique identification of a particular element. id can be used by this.$el(id) to find an element with a certain id. Take the API scrollToElement() For example: &lt;template&gt; &lt;container&gt; &lt;text id=\"top\"&gt;Top&lt;/text&gt; &lt;container style=\"height: 10000; background-color: #999999;\"&gt; &lt;/container&gt; &lt;text onclick=\"back2Top\"&gt;Back to Top&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') module.exports = &#123; methods: &#123; back2Top: function () &#123; var top = this.$el('top') dom.scrollToElement(top) &#125; &#125; &#125;&lt;/script&gt; id can also work with repeat attribute See more about display logical control, and ensure repetitive elements with different id: &lt;template&gt; &lt;container&gt; &lt;image id=\"&#123;&#123;imgId&#125;&#125;\" src=\"&#123;&#123;imgUrl&#125;&#125;\" onclick=\"getImageId\" repeat=\"&#123;&#123;images&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; images: [ &#123;imgId: 1, imgUrl: '...'&#125;, &#123;imgId: 2, imgUrl: '...'&#125;, &#123;imgId: 3, imgUrl: '...'&#125;, ... ] &#125;, methods: &#123; getImageId: function(e) &#123; // get e.target.id &#125; &#125; &#125;&lt;/script&gt; Additionally, in the composed components, we can get the corresponding sub component through this.$vm(id) APIs. Next is how to send messages between composed components.","type":"guide"},{"title":"Style & Class","path":"v-0.10/guide/syntax/style-n-class.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/style-n-class.html","text":"Style &amp; ClassThe Basic SyntaxCSS style description can be viewed as a series of key-value pairs,each of which describes a particular style, such as the width and height of a component. .box &#123; width: 400; height: 50;&#125; The format of key-value pairs is prop-name: prop-value;. The key name is prop-name, the value name is prop-value. Usually,the key name and the value name follow Horizontal connection nomenclature, the value may be a number(the default units is px); The key and the value must be separated by :, between each key-value pairs must be separated by ;. The style description will appear on a weex page in two formats: Style attribute of &lt;template&gt; label Stylesheets of &lt;style&gt; label style attributeThe style written in the style label, for example: &lt;template&gt; &lt;container style=\"width: 400; height: 50;\"&gt; ... &lt;/container&gt;&lt;/template&gt; It is said that the width and height of &lt;container&gt; label is 400 pixels and 50 pixels respectively. the &lt;style&gt; tagFor example: &lt;style&gt; .wrapper &#123;width: 600;&#125; .title &#123;width: 400; height: 50;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt; The stylesheets contain multiple style rules, each style rule has only one class which is contained by its style selector, a pair of curly braces {...}, and the styles of the curly braces. For example: .title &#123; width: 400; height: 50;&#125; The above is a rule. Class attributeThe selectors of &lt;style&gt; label are matched with the class attribute of &lt;template&gt; label, we should use spaces to separate the class names. For example: &lt;template&gt; &lt;container class=\"wrapper\"&gt; &lt;text class=\"title\"&gt;...&lt;/text&gt; &lt;text class=\"title highlight\"&gt;...&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123;width: 600;&#125; .title &#123;width: 400; height: 50;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt; It means that the width of the outermost container is 600px, The inside of the two title text is 400 pixels wide 50 pixels high, the second piece of text is red. Notes In order to simplify the page design and the complete underlying implementation, the width of our default screen is unified to 750 pixels, different screens should be scaled with corresponding ratio. The CSS standard may support a lot of selectors, but now weex only support single-class selector. The CSS standard can support many types of length units, but now weex only support pixel, and the px unit could be ignored, you can write number directly. More details can be found in commmon styles. The styles of Weex cannot be inherited to children elements, this is different to the CSS standard, such as color and font-size. The CSS standard contains a lot of styles, but weex only sopport few styles which include layouts such as box model, flexbox, positions. And styles include font-size, color, etc. With Data-bindingPage data can be bound in style and class attribute. For example: &lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;fontSize&#125;&#125;;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large &#123;&#123;textClass&#125;&#125;\"&gt;Weex Team&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 32;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; fontSize: 32, textClass: 'highlight' &#125; &#125;&lt;/script&gt; Next, let’s have a look at events.","type":"guide"},{"title":"Render Logic Control","path":"v-0.10/guide/syntax/render-logic.html","permalink":"https://weex.apache.org/v-0.10/guide/syntax/render-logic.html","text":"Render Logic ControlappendAttribute append do not have data-binding. It won’t change the final rendering effect. But it determines whether this component should be rendered as a whole tree or a single node with child nodes appended after. append has two key attributes, tree and node, the usage is: &lt;template&gt; &lt;container&gt; &lt;container id=\"world\" append=\"tree\"&gt; &lt;text&gt;Hello World!&lt;/text&gt; &lt;/container&gt; &lt;container id=\"weex\" append=\"node\"&gt; &lt;text&gt;Hello Weex!&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt; In the code snippet above, the element with id ‘world’ will wait for all its children to be rendered then it will be rendered entirely, while the element with id ‘weex’ will only render itself to the page, then its child elements will be rendered to page one by one. The rendering result is obvious, The latter statement will render the element a bit faster on the first-paint, but the total time might be longger than append=&quot;tree&quot; case. By default, elements are rendered as node mode. Once an element is in tree rendering mode, its children elements will always be rendered in tree mode. Next we will introduce composed component.","type":"guide"},{"title":"<a>","path":"v-0.10/references/components/a.html","permalink":"https://weex.apache.org/v-0.10/references/components/a.html","text":"&lt;a&gt;a defines a hyperlink to a page in the web. Its purpose and syntax is very similar to in HTML5. Child ComponentsThis type of component supports all kinds of weex component as it’s child components except for its own kind. Attributes href: href attributes defines the URL of the hyperlink. Styles:common stylesCheck out the common styles Eventscommon eventsCheck out the common events NotesWe can’t guarantee the order of execution between onclick function and href. we recommend that do not use the click event in a. Examples&lt;template&gt; &lt;div&gt; &lt;a href=\"http://h5.m.taobao.com\"&gt; &lt;text&gt;Click me to see how 'A' element opens a new world.&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt; Try it Use Weex Playground App to Scan the QR image and view the example for ‘a’.","type":"references"},{"title":"<cell>","path":"v-0.10/references/components/cell.html","permalink":"https://weex.apache.org/v-0.10/references/components/cell.html","text":"&lt;cell&gt;SummaryThis component must be used as a subcomponent of a list component, which is for the performance optimizing during scrolling. Child ComponentsThis type of component supports all kinds of weex component as its child components. AttributesThere is no specific attribute for this component other than the common attributes. Notes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Exampleplease refer to List","type":"references"},{"title":"<div>","path":"v-0.10/references/components/div.html","permalink":"https://weex.apache.org/v-0.10/references/components/div.html","text":"&lt;div&gt;SummaryThe most fundamental component which is a contianer to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child ComponentsThis type of component supports all kinds of weex component as its child components including its own kind. AttributesThere is no specific attribute for this component other than the common attributes. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples&lt;div&gt; &lt;image src=\"...\"&gt;&lt;/image&gt; &lt;text&gt;...&lt;/text&gt;&lt;/div&gt;","type":"references"},{"title":"<image>","path":"v-0.10/references/components/image.html","permalink":"https://weex.apache.org/v-0.10/references/components/image.html","text":"&lt;image&gt;Summaryimage tag is used to render a specified picture, and it shouldn’t contain any child component. You can use img as alias. Notes: the styles of width and height should be specified, otherwise it won’t work. alias: &lt;img&gt; Child ComponentsThis component supports no child components. Attributes src: &lt;string&gt; image source url resize: v0.5+ &lt;string&gt; the ‘ScaleType’ of the component. The default value is stretch, if this attribute is not specified. Possible values are cover, contain, each of which has the same meaning with w3c standard. Other attributes please check out the common attributes. Styles width: &lt;length&gt; the width of the component. This style should be specified. height: &lt;length&gt; the height of the component. This style should be specifed. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples&lt;div&gt; &lt;image src=\"...\" &gt;&lt;/image&gt; &lt;text&gt;...&lt;/text&gt;&lt;/div&gt;","type":"references"},{"title":"<indicator>","path":"v-0.10/references/components/indicator.html","permalink":"https://weex.apache.org/v-0.10/references/components/indicator.html","text":"&lt;indicator&gt;SummaryThis component must be used as a subcomponent of a slider component. Child ComponentsThis component supports no child components. AttributesThere is no specific attribute for this component other than the common attributes. Styles item-color: &lt;colors&gt; This style attribute sets the normal item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-size: &lt;length&gt; The size of the indicator elements, which is an float attribute. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\"&gt; &lt;div class=\"slider-pages\" repeat=\"&#123;&#123;itemList&#125;&#125;\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123;width: 150; height: 150;&#125; .title &#123;flex: 1; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee;&#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<input>","path":"v-0.10/references/components/input.html","permalink":"https://weex.apache.org/v-0.10/references/components/input.html","text":"inputThe weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child ComponentsThis component supports no child components. Attributes type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, password, tel, email, url etc. each of which has the same meaning with \u001dW3C standard. value: the value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. maxlength: v0.7+ a number value to specify maxlength of input. Other attributes please check out the common attributes. Styles placeholder-color: the color of placeholder. Default value is ‘#999999’. text styles: checkout text styles support ‘color’ style. support ‘font-size’ style. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Events input: the value of an input character changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a ‘blur’ event. focus: a component has received focus. blur: a component has lost focus. common eventscheck out common events support ‘appear’ / ‘disappear’ event. Notesdoes not support the common-event ‘click’. Please listen to the ‘input’ or ‘change’ event instead. Parameters of events’ object for ‘input’ and ‘change’ events:’value’: the value of the component who dispatched this event.’timestamp’: the time stamp of the event. for ‘focus’ and ‘blur’ events:’timestamp’: the time stamp of the event. Example&lt;template&gt; &lt;div&gt; &lt;input type=\"text\" placeholder=\"Input Something\" class=\"input\" autofocus=\"true\" value=\"\" onchange=\"onchange\" oninput=\"oninput\" /&gt; &lt;text&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .input &#123; font-size: 60; height: 80; width: 400; &#125;&lt;/style&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; txtInput: '', txtChange: '' &#125;, methods: &#123; onchange: function(event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, oninput: function(event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125; &#125; &#125;;&lt;/script&gt; Try it Use Weex Playground App to Scan the QR image and view the example for ‘input’.","type":"references"},{"title":"<scroller>","path":"v-0.10/references/components/scroller.html","permalink":"https://weex.apache.org/v-0.10/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ A scroller is a component in vertical direction which can have multiple child components in one column. If total height of its child components exceed the height of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. example &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; items: [], triggered:false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onloadmore:function()&#123; if(!this.triggered)&#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123;'item':'onloadmore triggered' + i&#125;); &#125; &#125; this.triggered=true; &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsScroller supports all kinds of components, such as div, text, etc.And there are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. example &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; items: [], triggered:false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onloadmore:function()&#123; if(!this.triggered)&#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123;'item':'onloadmore triggered' + i&#125;); &#125; &#125; this.triggered=true; &#125; &#125;&#125;&lt;/script&gt; try it Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsonloadmore used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal.","type":"references"},{"title":"<list>","path":"v-0.10/references/components/list.html","permalink":"https://weex.apache.org/v-0.10/references/components/list.html","text":"Listv0.6.1+ The List component, which inherits from Scroller component, is a core component, and it provides the most popular features for using a list of items. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. example &lt;template&gt; &lt;list&gt; &lt;cell onappear=\"onappear($event, $index)\" ondisappear=\"ondisappear($event, $index)\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;] &#125;, methods:&#123; onappear: function (e, index) &#123; console.log('+++++', index) console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e, index) &#123; console.log('+++++', index) &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsNotes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsonloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events APIAll cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore eventloading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. scroller example list example RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; Try it","type":"references"},{"title":"<slider>","path":"v-0.10/references/components/slider.html","permalink":"https://weex.apache.org/v-0.10/references/components/slider.html","text":"&lt;slider&gt;SummaryA slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child ComponentsIt supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: &lt;number&gt; . This value determines the index of current shown slide. The default value is 0. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<refresh> & <loading>","path":"v-0.10/references/components/refresh-loading.html","permalink":"https://weex.apache.org/v-0.10/references/components/refresh-loading.html","text":"refresh &amp; loadingv0.6.1+ Loading ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. example `&lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/loading&gt; &lt;cell onappear=\"onappear($event, $index)\" ondisappear=\"ondisappear($event, $index)\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onappear: function (e, index) &#123; // console.log('+++++', index); // console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e, index) &#123; // console.log('+++++', index); &#125;, onloading:function(e)&#123; console.log('onloading...'); this.staffs.push(&#123;name:'onloading'&#125;) &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component.example Attributes display has value of show or hide. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components Events onloading triggered when loading Restrictions refresh/loading does not support remove action, Weex 0.9 will fix it. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. Refresh ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"1000\"&gt; &lt;refresh onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text id=\"refreshText\"&gt;&#123;&#123;refreshText&#125;&#125;&lt;/text&gt; &lt;/refresh&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text id=\"loadingText\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh', items: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 30; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onrefresh: function () &#123; var vm = this; vm.refreshDisplay = 'show' if (vm.items.length &gt; 50) &#123; vm.refreshText = \"no more data!\" vm.refreshDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.unshift(&#123;'item': 'test data ' + i&#125;); &#125; vm.refreshDisplay = 'hide' &#125;, onloading: function () &#123; var vm = this; vm.loadingDisplay = 'show' if (vm.items.length &gt; 30) &#123; vm.loadingText = \"no more data!\" vm.loadingDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.push(&#123;'item': 'test data ' + i&#125;); &#125; vm.loadingDisplay = 'hide' &#125;, onloadmore:function()&#123; console.log(\"into--[onloadmore]\") &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component.example Attributes display has value of show or hide, default value is show. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components Events onrefresh triggered when the scroller has been pulled down onpullingdown available on Android. triggered when the scroller has been pulled down. you can get dy, headerHeight, maxHeight from onpullingdowns event object. example example &lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;refresh onpullingdown='onpullingdown' onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell onappear=\"onappear\" ondisappear=\"ondisappear\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onappear: function (e) &#123; var index = e.target.attr.index // console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e) &#123; &#125;, onrefresh:function(e)&#123; this.refreshDisplay='show'; // this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;]; this.refreshDisplay='hide' // console.log(this.refreshDisplay); &#125;, onpullingdown:function(e)&#123; console.log('onpullingdown triggered.'); console.log('dy:'+e.dy); console.log('headerHeight:'+e.headerHeight); console.log('maxHeight:'+e.maxHeight); &#125; &#125; &#125;&lt;/script&gt; try it Restrictions refresh/loading does not support remove action, may support in Weex 0.9. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs.","type":"references"},{"title":"<switch>","path":"v-0.10/references/components/switch.html","permalink":"https://weex.apache.org/v-0.10/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ The weex builtin component switch is used to create and manage an IOS styled On/Off buttons, for example, the Airplane mode button in the Settings app is a switch button. example &lt;template&gt; &lt;div&gt; &lt;text&gt;muted:&lt;/text&gt; &lt;switch checked=\"true\" onclick='onclick' onchange='onchange' ondisappear='ondisappear' onappear='onappear'&gt;&lt;/switch&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; methods:&#123; onclick:function(e)&#123; console.log('onclick:' + e.timestamp); &#125;, onchange:function(e)&#123; console.log('onchage, value:' + e.value); &#125;, ondisappear:function(e)&#123; console.log('ondisappear, value:' + e.value); &#125;, onappear:function(e)&#123; console.log('onappear, value:' + e.value); &#125;, &#125; &#125;&lt;/script&gt; try it Child ComponentsThere are no child components for the switch component. Attributes checked &lt;boolean&gt; true|false, default value is false, indicating whether the button is on or not. disabled &lt;boolean&gt; true|false, default value is false, indicating whether the button is enable or not. Other attributes please check out the common attributes. StylesNotes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxs padding and padding-xxs border and border-xxs Notes: Specially the width and height related properties is not configurable and the size of this component is fixed to 100x60 (for the design width 750px). common styles: check out common styles for components Events onappear / ondisappear event. check out common events onclick: check out common events onchange: check out common events Parameters of events’ object for onchange event: value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event.","type":"references"},{"title":"<text>","path":"v-0.10/references/components/text.html","permalink":"https://weex.apache.org/v-0.10/references/components/text.html","text":"&lt;text&gt;The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Child ComponentsThis component supports no child components. Attributes value(string): text value of this component. This is equal to the content of ‘text’. examplevar textComponent = this.$el(&quot;textid&quot;);this.text = textComponent.attr.value; Styles lines: specify the text lines. Default value is 0 for unlimited. text styles: check out text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. line-height in iOS is different from h5 and Android, text value will be placed at bottom of line box. not support ‘flex-direction, ‘justify-content’, ‘align-items’ which is active for child nodes, and text has no child nodes. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Eventscommon eventscheck out common events support ‘click’ event. support ‘appear’ / ‘disappear’ event. Example&lt;template&gt; &lt;div&gt; &lt;text&gt;this is text content&lt;/text&gt; &lt;text value=\"this is text value\"&gt;&lt;/text&gt; &lt;text style=\"text\"&gt;&#123;&#123;price1&#125;&#125;&lt;/text&gt; &lt;text id=\"textid\" onclick=&#123;&#123;showtext&#125;&#125;&gt;this is gettext content&lt;/text&gt; &lt;text value=\"&#123;&#123;text&#125;&#125;\"&gt;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text &#123; font-size: 24; text-decoration: underline; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; price1: '99.99', price2: '88.88', text:'' &#125;, methods: &#123; showtext: function(event) &#123; var textComponent = this.$el(\"textid\"); this.text = textComponent.attr.value; &#125; &#125; &#125;;&lt;/script&gt; Try it","type":"references"},{"title":"<video>","path":"v-0.10/references/components/video.html","permalink":"https://weex.apache.org/v-0.10/references/components/video.html","text":"&lt;video&gt;v0.6.1+ The video component can be used to embed video content in a weex page. example &lt;template&gt; &lt;div&gt; &lt;text&gt;Big Eater!&lt;/text&gt; &lt;video onstart='onstart' onpause='onpause' onfinish='onfinish' onfail='onfail' auto-play=\"false\" play-status=\"pause\" src=\"&#123;&#123;src&#125;&#125;\" style=\"width:750;height:500;\"&gt;&lt;/video&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; data: &#123; src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125;, methods:&#123; onstart:function(e)&#123; console.log('onstart'); console.log(e); &#125;, onpause:function(e)&#123; console.log('onpause'); &#125;, onfinish:function(e)&#123; console.log('onfinish'); &#125;, onfail:function(e)&#123; console.log('onfail'); &#125;, &#125; &#125;&lt;/script&gt; try it Child Components text is the only valid type of child component. Attributes src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed.","type":"references"},{"title":"<textarea>","path":"v-0.10/references/components/textarea.html","permalink":"https://weex.apache.org/v-0.10/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ SummaryThe weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child ComponentsThis component supports no child components. attributes value: &lt;string&gt; the value of the control. placeholder: &lt;string&gt; a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: &lt;boolean&gt; a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: &lt;boolean&gt; a boolean attribute lets you specify that a form control should have input focus when the page loads. rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. Other attributes please check out the common attributes. Stylestext styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example&lt;div&gt; &lt;textarea autofocus=\"true\" placeholder=\"...\" value=\"I am a multiple input\"&gt; &lt;/textarea&gt;&lt;/div&gt;","type":"references"},{"title":"<web>","path":"v-0.10/references/components/web.html","permalink":"https://weex.apache.org/v-0.10/references/components/web.html","text":"&lt;web&gt;v0.5+ Use web component to display any web content in the weex page. The srcattribute is used to specify a special source. You also can use webview module to control some web operation such as goBack,goForward and reload. see webview module.For example,You can use web component and webview module to assemble a browser. Child ComponentsThis component supports no child components. Attributessrc(string): this attribute specifies the page source to load. Other attributes please check out the common attributes. Styleswidth(float): the width of the component, default value is 0. This style must be specified. height(float): the height of the component, default value is 0. This style must be specifed. common stylescheck out the common styles. support flexbox related stylessupport box model related stylessupport position related styles Eventspagestart: sent after the web component starts loading a page.pagefinish: sent after the web component finishes loading a page.error: sent if the web component failed to load a page. common eventssupport appear / disappear event. Check out common events Notesnot support click event. ExampleWe use a simple Browser Demo to show how to use web component and webview module. Check out webview module. &lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"...\" class=\"textStyle\" value=\"&#123;&#123;input_text&#125;&#125;\" oninput=\"input\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;wxc-button value=\"LoadURL\" class=\"buttonSytle\" size=\"small\" onclick=\"loadURL\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Backward\" class=\"buttonSytle\" size=\"small\" onclick=\"backforward\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Forward\" class=\"buttonSytle\" size=\"small\" onclick=\"forward\"&gt;&lt;/wxc-button&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; width:600; height: 825; background-color:#778899 ; &#125; .textStyle &#123; width:600; height: 50; background-color: #D3D3D3; &#125; .buttonSytle &#123; width:180; height: 50; font-size: 12; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; &#125; .webStyle &#123; width:600; height: 700; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview'); module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", input_text:\"https://www.tmall.com\" &#125;, methods: &#123; loadURL: function (e) &#123; var web_element = this.$el('webview'); var input = this.$el(\"urlInput\"); this.src = this.input_text; web_module.reload(web_element); &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); this.input_text = web_element.attr.src; &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); this.input_text = web_element.attr.src; &#125;, input:function (e) &#123; var input = this.$el(\"urlInput\"); this.input_text = input.attr.value; &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"<wxc-tabbar>","path":"v-0.10/references/components/wxc-tabbar.html","permalink":"https://weex.apache.org/v-0.10/references/components/wxc-tabbar.html","text":"&lt;wxc-tabbar&gt;The wxc-tabbar is a custom component, which belongs to the weex-components node package, implements a specialized component that corresponds to the radio-style selection. It displays tabs at the bottom of the window for switching between different tab pages. Usage: You can use this component by a require statement, require(&#39;weex-components&#39;);, in the script tag. e.g. &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); // Other javascript statements.&lt;/script&gt; Before requiring weex-components&#39;, you need to specify weex-components dependency in your project’s package.json file. e.g. \"dependencies\": &#123; \"weex-components\": \"^0.2.0\"&#125; Child Componentswxc-tabbar has no child components. Attributes selected-index : &lt;number&gt; default value is 0 selected-color: &lt;color&gt; The color of the title when it is selected. Default is red color. unselected-color: &lt;color&gt; The color of the title when it is unselected. Default is black color. tab-items This attribute accepts an array of tabitem objects, each of which corresponds to the tab pages. And the order of the items equals to the order of the tab pages onscreen. You can configure the appearance of tabbar by setting the tabitem object’s properties. Each tabitem properties are listed as below: index: &lt;integer&gt; This attribute is required, and it specifies the order of the item. title: &lt;string&gt; The item’s title. and it is optional. The tile will not be displayed if empty or not provided. titleColor: &lt;color&gt;The item’s titleColor. Default is black color. image: &lt;string&gt;The icon displayed when the tabitem is unselected. The image will not be displayed if empty or not provided. selectedImage : &lt;string&gt;The icon displayed when the tabitem is selected. The icon will not be displayed if empty or not provided. src : &lt;string&gt; The weex page for the tab page. visibility: &lt;string&gt;visible | hidden. This attribute specifies display status of the tab page. Default value is visible. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events tabBar.onClick: triggered when the tabitem is selected. You need to register the observer in ready or create block.e.g. &lt;template&amp;gt; &lt;div style=\"flex-direction: column;\"&amp;gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&amp;gt;&lt;/wxc-tabbar&amp;gt; &lt;/div&amp;gt;&lt;/template&amp;gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; &#125;, methods: &#123; ready: function (e) &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var index = e.detail.index; &#125;); &#125;, &#125; &#125;&lt;/script&gt; ExampleYou should checkout the playground’s tabbar example.","type":"references"},{"title":"<wxc-navpage>","path":"v-0.10/references/components/wxc-navpage.html","permalink":"https://weex.apache.org/v-0.10/references/components/wxc-navpage.html","text":"&lt;wxc-navpage&gt;SummaryThe “wxc-navpage” tag implements a specialized component that contains a navbar at the top of the window and an embed content page. You can customize the navbar as you like. In addition, you can use navigator module to control the page jump, see navigator module. Child ComponentsThis type of component supports all kinds of weex component as its child components. Attributes height: &lt;length&gt; The height of the navbar. Default value is 88. background-color: &lt;color&gt;The backgroudColor of the navbar. Default value is white. title: &lt;string&gt; The title of the navbar. title-color: &lt;color&gt;The color of the navbar title. Default value is black. left-item-title: &lt;string&gt; The title of the leftItem. left-item-color: &lt;color&gt; The color of the leftItem title. Default value is black. right-item-title: &lt;string&gt; The title of the rightItem. right-item-color: &lt;color&gt; The color of the rightItem title. Default value is black. left-item-src: &lt;string&gt; The imageURL of the leftItem you want to set. right-item-src: &lt;string&gt; The imageURL of the rightItem you want to set. Other attributes please check out the common attributes. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events naviBar.leftItem.click: triggered when the leftItem of navbar is clicked. You need to register the observer in ready or create block. naviBar.rightItem.click: triggered when the rightItem of navbar is clicked. You need to register the observer in ready or create block. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;wxc-navpage height=&#123;&#123;...&#125;&#125; background-color=\"...\" title=\"...\" title-color=\"...\" left-item-title=\"...\" left-item-color=\"...\" right-item-src=\"...\"&gt; &lt;content&gt; ...&lt;/content&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; created: function() &#123; this.$on('naviBar.rightItem.click',function(e)&#123; //handle your click event here. &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; //handle your click event here. &#125;); &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"dom","path":"v-0.10/references/modules/dom.html","permalink":"https://weex.apache.org/v-0.10/references/modules/dom.html","text":"domSummaryA series of dom apis that sending virtual-dom’s messages to the native renderer to update the dom tree. The only API for developers to use in a .we file is scrollToElement which you can use by calling the $scrollTo method. Other APIs mentioned on this page should only be used through the native renderer in the callNative process. APIscrollToElement(node, options)Scroll the page to the specified node. This API should only be used on the element in the scroller or list component. This API can be used by calling the VM’s method $scrollTo (deprecated). You can use require(&#39;@weex-module/dom&#39;).scrollToElement to call this API in your .we file. Arguments node(Node): an element that scrolled into the view. options(object): some options. offset(number): An offset to the visible position, default is 0. Examplevar dom = require('@weex-module/dom');dom.scrollToElement(this.$el('someId'), &#123;offset: 10&#125;); createBody(element)Create the body for the whole dom tree. Element type should only be the ones that can be used as roots (div, scroller and list). Arguments element(object): a object that specified the body node info like ref, type, children, etc. addElement(parentNode, element, index)Add a element into the dom tree. Arguments parentNode(Node): specify the element’s parent node. element(object): a object that specified the config info for the node to be added. index(number): insert the element to the specified position. removeElement(node)Remove a node in the dom tree. Arguments node(Node): the node to be removed. moveElement(node, parentNode, index)Move a exsited node into another parent (or the same parent) before the specified position. Arguments node(Node): the node to be moved. parentNode(Node): the parent node to move into. index(number):: according to the specified position index, will the node be inserted into. addEvent(node, type)Inform the renderer that there are listeners for a specified event type. Arguments node(Node): the node to be listened on. type(string): which type of events the node should be listened for. removeEvent(node, type)Remove event listeners on the specified node for the specified event type. Arguments node(Node): on which node should the listeners to be removed type(string): specify the event type. updateAttrs(node, attr)Update attrbutes of the specified node. Arguments node(Node): the node to be updated. attr(object): the attributes object with the attribute items to be updated. updateStyle(node, style)Update styles of the specified node. Arguments node(Node): the node to be updated. style(object): the style object with the style rules to be updated. createFinish()Notify native renders that the series of messages for updating the native dom tree have reached a end. refreshFinish()Notify native renders that the series of messages for refreshing a native dom tree have reached a end.","type":"references"},{"title":"animation","path":"v-0.10/references/modules/animation.html","permalink":"https://weex.apache.org/v-0.10/references/modules/animation.html","text":"animationSmooth and meaningful animation is very effective for enhancing the user experience of mobile application, you can use the animation module to perform animation on components. A animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component. So, if you have a image component, you can move, rotate, grow, or shrink it. APItransition(node, options, callback)example Argumentsnodetype: node position: An element that will be animated, normally you can get this by calling this.$el(id). optionstype: object position: Transition options. duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description example linear Specifies a transition effect with the same speed from start to end example ease-in Specifies a transition effect with a slow start example ease-out Specifies a transition effect with a slow end example ease-in-out Specifies a transition effect with a slow start and end example cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. example styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value example width The width applied to the component after the animation finished. length none example height The height applied to the component after the animation finished. length none example backgroundColor The background color applied to the component after the animation finished. string none example opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 example transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center example transform Transform function to be applied to the element. The properties in the following table are supported object none example properties of transform: name description value type default value example translate/translateX/translateY Specifies the location of which the element will be translated. pixel or percent none example rotate Specifies the angle of which the element will be rotated, the unit is degree. number none example scale/scaleX/scaleY Stretch or shrink the element. number none example callbacktype: function position: Callback which is called after the completion of transition.","type":"references"},{"title":"clipboard","path":"v-0.10/references/modules/clipboard.html","permalink":"https://weex.apache.org/v-0.10/references/modules/clipboard.html","text":"clipboardv0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution only support text. only works on Android and iOS. NOT works for html5, for web security reason. APIgetString(callback)reads from clipboard. Argumentscallback(function): the callback function after executing this action. data is the return value. Example var clipboard = require('@weex-module/clipboard');clipboard.getString(function(ret) &#123; // callback. 'ret' is an object that contains 'result' and 'data'. // use 'ret.data' to fetch the value. console.log(\"read from clipboard is \" + ret.data);&#125;); setString(text)sets the text to clipboard, having the same effect as copying manually. Argumentstext(string): the text copied to clipboard.Example var clipboard = require('@weex-module/clipboard');clipboard.setString(\"SomeStringHere\");","type":"references"},{"title":"globalEvent","path":"v-0.10/references/modules/globalevent.html","permalink":"https://weex.apache.org/v-0.10/references/modules/globalevent.html","text":"globalEventv0.8+ (developing) SummaryglobalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removeEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global eventsAPI development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) ExampleAndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)register global event. Arguments eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Examplevar globalEvent = require('@weex-module/globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123;2console.log(\"get geolocation\")2&#125;); removeEventListener(String eventName)remove global event Arguments eventName(string): You no longer need to listen for event names. Examplevar globalEvent = require('@weex-module/globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"modal","path":"v-0.10/references/modules/modal.html","permalink":"https://weex.apache.org/v-0.10/references/modules/modal.html","text":"modalWeex provides a series of message boxes: toast, alert, confirm and prompt. APItoast(options)A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. Example: &lt;template&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Toast&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); modal.toast(&#123; 'message': 'I am a toast', 'duration': 3 &#125;); &#125; &#125; &#125;&lt;/script&gt;``` ### alert(options, callback) An alert box is often used if you want to make sure information comes through to the user. When an alert box pops up, the user will have to click \"OK\" to proceed. #### Arguments - `options` (object): alert box options. - `message` (string): the text message that the alert shows. - `okTitle` (string): the text of positive button, default is 'OK'. - `callback` (function): callback when complete. This method has a callback function whose arguments will be: - `result` (string): the title text of the confirm button that clicked by user.**Example:**```html&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Alert&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.alert(&#123; 'message': 'I am alert message', 'okTitle' : 'YES' &#125;, function (result) &#123; self.params = String(result) &#125;); &#125; &#125; &#125;&lt;/script&gt; confirm(options, callback)A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user.Example: &lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Confirm&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.confirm(&#123; 'message': 'I have read and accept the terms.', 'okTitle' : 'YES', 'cancelTitle' : 'NO' &#125;, function (e) &#123; self.params = String(e) &#125;); &#125; &#125; &#125;&lt;/script&gt;``` ### prompt(options, callback) A prompt box is often used if you want the user to input a value before entering a page. When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. #### Arguments - `options` (object): some options. - `message` (string): the message that the prompt shows. - `okTitle` (string): the title text of confirm button, default is 'OK'. - `cancelTitle` (string): the title text of cancel button, default is 'Cancel'.- `callback` (function): callback when complete. This method has a callback function whose arguments will be: - `ret` (object): the argument will be a object, which has attributes `result` and `data`, like `&#123; result: 'OK', data: 'hello world' &#125;` - `result` (string): the title of the button that clicked by user. - `data` (string): the value of the text that entered by user. **Example:** ```html&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Prompt&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.prompt(&#123; 'message': 'I am a prompt', 'okTitle' : 'YES', 'cancelTitle' : 'NO' &#125;, function (e) &#123; self.params = JSON.stringify(e) &#125;); &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"storage","path":"v-0.10/references/modules/storage.html","permalink":"https://weex.apache.org/v-0.10/references/modules/storage.html","text":"storagev0.7+ Summarystorage is a series of apis, allowing you to for example add, modify or delete stored data items. APIsetItem(key, value, callback)When passed a key name and value, will add that key to the storage,or update that key’s value if it already exists. Arguments key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.setItem('bar', 'bar-value', function(e) &#123; // callback.'e' is an object that contains 'result' and 'data'. e.result indicate whether `setItem` is succeed. // e.data will return 'undefined' if success or 'invalid_param' if your key/value is \"\"/null.&#125;); getItem(key, callback)When passed a key name, will return that key’s value. Arguments key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.getItem('foo', function(e) &#123; //callback.'e' is an object that contains 'result' and 'data'. // use 'e.data' to fetch the value of the key,if not found,'undefined' will return.&#125;); removeItem(key, callback)When passed a key name, will remove that key from the storage. Arguments key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)Returns an integer representing the number of data items stored in the Storage object. Arguments callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.length(function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. //e.data will return that number.&#125;); getAllKeys(callback)Returns an array that contains all keys stored in Storage object. Arguments callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.getAllKeys(function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. //e.data will return that array of keys.&#125;);","type":"references"},{"title":"navigator","path":"v-0.10/references/modules/navigator.html","permalink":"https://weex.apache.org/v-0.10/references/modules/navigator.html","text":"Navigatorv0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can let us to specify whether to apply animation or not during the transition. example &lt;template&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;click me! &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; data:&#123; message:\"\" &#125;, methods:&#123; onItemClick:function(e)&#123; var navigator = require('@weex-module/navigator'); var params = &#123;'url':'http://weex.alibaba-inc.com/raw/html5/3d2996653c1d129603f9c935b895e998.js','animated':true&#125;; navigator.push(params, function(e) &#123; console.log('i am the callback.') &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text&#123; width: 750; height: 90; &#125;&lt;/style&gt; try it APIpush(options, callback)push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. url(stirng): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. var params = &#123; 'url': 'navigator-demo.js', 'animated' : 'true',&#125;var navigator = require('@weex-module/navigator');navigator.push(params, function(e) &#123; //callback&#125;); pop(options, callback)pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. example var params = &#123; 'animated' : 'true',&#125;var navigator = require('@weex-module/navigator');navigator.pop(params, function(e) &#123; //callback&#125;); close(options, callback)close a weex page, you can specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true, should animation be applied when closing. Default value is true. callback(object): the callback function after executing this action. setNavBarBackgroundColor(params, callback)set color for the navigation bar’s background color, you can specify a callback function to be executed after the operation is over. parameters params(object): some parameters. backgroundColor(string): it’s a required param, no default value provided. callback(object): the callback function after executing this action. setNavBarLeftItem(params,callback)set left item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty, titleColor depends on title. And If title and icon are provided, only the title and its titleColor will be used. That’s to say, icon will only be used when title is not present. title(string): the title for the bar button. titleColor (string): the title color. icon (string): the icon for the bar button, should be an an downloadable image. callback(object): the callback function after executing this action. clearNavBarLeftItem(callback)clear left item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters callback(object): the callback function after executing this action. setNavBarRightItem(params,callback)set the right item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty, titleColor depends on title. And If title and icon are provided, only the title and its titleColor will be used. That’s to say, icon will be used when title is not present. title(string): the title for the bar button. titleColor (string): the title color. icon (string): the icon for the bar button, should be an an downloadable image. callback(object): the callback function after executing this action. clearNavBarRightItem(params, callback)clear the right item for the navigation bar, you can specify a callback function to be executed after the operation is over.parameters params(object): optional. callback(object): the callback function after executing this action. setNavBarMoreItem(params,callback)set the more item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters Actually, the function does nothing. params(object): optional. callback(object): the callback function after executing this action. clearNavBarMoreItem(params, callback)clear the more item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters Actually, the function does nothing. params(object): optional. callback(object): the callback function after executing this action. setNavBarTitle(params,callback)set the title for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty. title(string): the title for the bar button. callback(object): the callback function after executing this action. clearNavBarTitle(params,callback)clear the title for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): optional. callback(object): the callback function after executing this action.","type":"references"},{"title":"stream","path":"v-0.10/references/modules/stream.html","permalink":"https://weex.apache.org/v-0.10/references/modules/stream.html","text":"streamA series of stream api. It provides a network request. APIfetch(options, callback,progressCallback)Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): request type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Example&lt;template&gt; &lt;div&gt; &lt;text onclick=\"startStream\"&gt;click here to start stream&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; startStream: function () &#123; var stream_module = require('@weex-module/stream'); stream_module.fetch(&#123; method: 'GET', url: \"http://httpbin.org/get\", type:'json' &#125;, function(response) &#123; //finished response console.log(\"all received:\",response); &#125;,function(response)&#123; //progress response console.log(\"current bytes received:\",response.length); &#125;); &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"Timer","path":"v-0.10/references/modules/timer.html","permalink":"https://weex.apache.org/v-0.10/references/modules/timer.html","text":"TimerWeex encapsulates a series of APIs in order to start/stop a one-time task or a repeated task at a fixed delay. Please note that this module don’t provide an accuracy delay. It provides best-effort delivery, but the actual delay may still exceed the delay user wants if the corresponding thread is busy.Actually, this module is made for the polyfill of HTML5 timer APIs, developers should not use this module directly unless they know exactly what they are doing. APIAll timeout or interval in this module are measured in milliseconds.Also, timeout and interval should be a non-negative integer(the max of integer is 0x7FFFFFFF). If timeout or interval is negative, then it will be reset to zero, e.g. the task will be put in the task queue immediately. setTimeout(fn, timeout)The setTimeout() method calls a function after a specified number of milliseconds. Use the clearTimeout() method to prevent the function from running. The function is only executed once. If you need to repeat execution, use the setInterval() method. Arguments fn (function): The function that will be executed timeout (number): The number of milliseconds to wait before executing the function Return valueA Number, representing the fnId value of the timer that is set. Use this value with the clearTimeout() method to cancel the timer. setInterval(fn, interval)The setInterval() method calls a function at specified intervals (in milliseconds), and it will continue calling the function until clearInterval() is called. The fnId value returned by setInterval() is used as the parameter for the clearInterval() method. Arguments fn (function): The function that will be executed interval (number): The intervals (in milliseconds) on how often to execute the function Return valueA Number, representing the fnId value of the timer that is set. Use this value with the clearInterval() method to cancel the timer clearTimeout(fnId)The clearTimeout() method clears a timer set with the setTimeout() method. The fnId value returned by setTimeout() is used as the parameter for the clearTimeout() method. If the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method, otherwise, this method has no influence on the task. Arguments fnId (number): The fnId value of the timer returned by the setTimeout() method clearInterval(fnId)The clearInterval() method clears a timer set with the setInterval() method. The fnId value returned by setInterval() is used as the parameter for the clearInterval() method. Arguments fnId (number): The fnId of the timer returned by the setInterval() method Try it","type":"references"},{"title":"webview","path":"v-0.10/references/modules/webview.html","permalink":"https://weex.apache.org/v-0.10/references/modules/webview.html","text":"webviewA series of web operation api like goBack, goForward, and reload. ‘webview’ module used with the web component. APIgoBack(webElement)Loads the previous location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goBack(webElement); goForward(webElement)Loads the next location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goForward(webElement); reload(webElement)Reloads the current web page. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.reload(webElement.ref); Example&lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"...\" class=\"textStyle\" value=\"&#123;&#123;input_text&#125;&#125;\" oninput=\"input\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;wxc-button value=\"LoadURL\" class=\"buttonSytle\" size=\"small\" onclick=\"loadURL\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Backward\" class=\"buttonSytle\" size=\"small\" onclick=\"backforward\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Forward\" class=\"buttonSytle\" size=\"small\" onclick=\"forward\"&gt;&lt;/wxc-button&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; width:600; height: 825; background-color:#778899 ; &#125; .textStyle &#123; width:600; height: 50; background-color: #D3D3D3; &#125; .buttonSytle &#123; width:180; height: 50; font-size: 12; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; &#125; .webStyle &#123; width:600; height: 700; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview'); module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", input_text:\"https://www.tmall.com\" &#125;, methods: &#123; loadURL: function (e) &#123; var web_element = this.$el('webview'); var input = this.$el(\"urlInput\"); this.src = this.input_text; web_module.reload(web_element); &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); this.input_text = web_element.attr.src; &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); this.input_text = web_element.attr.src; &#125;, input:function (e) &#123; var input = this.$el(\"urlInput\"); this.input_text = input.attr.value; &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"JS Bundle format","path":"v-0.10/references/specs/js-bundle-format.html","permalink":"https://weex.apache.org/v-0.10/references/specs/js-bundle-format.html","text":"JS Bundle formatJS Bundle Version: v0.3.0 v0.5.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is used to define some custom components for the instance and bootstrap the instance with certain name, config and data. Developers could use all kinds of JS code packager like webpack, browserify, requirejs to organize your whole instance code. Meta InfoThe JS Bundle Must begin with a comment line which is a JSON object like: // &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125; This JSON object as least contains: property framework must be &quot;Weex&quot; property version should be corresponded with the JS Bundle format version Global Members __weex_define__(name, options) __weex_bootstrap__(name, config, data) __weex_document__ __weex_require__(name) __weex_define__(name:string, options: object)Define a custom component named name for current instance with options. example: __weex_define__('rmb', &#123; template: &#123; type: 'div', style: &#123;flexDirection: 'row'&#125;, children: [ &#123;type: 'text', attr: &#123;value: '￥'&#125;&#125;, &#123;type: 'text', attr: &#123;value: this.value&#125;&#125; ] &#125;, data: function () &#123; return &#123; value: '0' &#125; &#125;, methods: &#123;...&#125;&#125;) The enabled component options contains: template: just the same as v0.3.0 style: just the same as v0.3.0 data: a function which return a plain object to observe by the ViewModel methods: a function map to proxy to the ViewModel computed: a map of several computed keys for the ViewModel init, created, ready: lifecycle methods events: event handlers for the ViewModel The enabled ViewModel APIs contains: $el(id): Element: find element by id in current ViewModel scope $vm(id): ViewModel: find sub ViewModel by id $getConfig(): object: get instance config info $broadcast/$emit/$dispatch/$on/$off: listen and fire component events $transition (experimental): animation transition (see more in animation native module) __weex_require__(name: string): objectGet a Weex native module with several native APIs. example: var modal = __weex_require__('modal')modal.toast(&#123; message: 'Hey!', duration: 2&#125;) polyfill for v0.3.0 function __weex_require__(name) &#123; var result define('__weex_require__', function (r, e, m) &#123; result = r('@weex-module/' + name) &#125;) return result&#125; __weex_bootstrap__(nameOrOptions: string|object, config: object?, data: object?): AppInstance | ErrorStart to render by a certain component name or a direct component options as the root element, and some instance config and instance data. If everything fine, it will returns the root app instance. Otherwise it will return an Error instance which describes something wrong. example: __weex_bootstrap__( 'root', &#123; // format 1: // downgrade: &#123; appVersion: '&gt;= 0.5.0' &#125;, // format 2: // downgrade: function (config) &#123; return true &#125; &#125;, &#123; // external data // value: '12345' &#125;) The instance config now only support downgrade property which allows two format: an object like { osVersion, appVersion, weexVersion, deviceModel } a function like function (config) { return true } to return a boolean value. true means normal and false means downgrade. The instance data will merge to root component data. So the root component is also easy to reuse and the instance data is easy to customize. __weex_document__An virtual-DOM Document instance. Also the host of virtual-DOM APIs. Every Weex instance has and must have just one Document instance. Preserved Global Variablesdefine, bootstrap, module, exports, document, require, register, render A whole example// &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125;var modal = __weex_require__('modal')__weex_define__('item', &#123; template: &#123; type: 'div', style: &#123; flexDirection: 'row' &#125;, event: &#123; click: function (e) &#123; this.update(e) &#125; &#125;, children: [ &#123; type: 'image', attr: &#123; src: this.imageUrl &#125;, ...&#125;, &#123; type: 'text', attr: &#123; value: this.title &#125;, ...&#125; ] &#125;, data: function () &#123; return &#123; imageUrl: '', title: '' &#125; &#125;, methods: &#123; update: function (e) &#123; modal.toast(&#123; message: this.title &#125;) &#125; &#125;&#125;)__weex_define__('app', &#123; template: &#123; type: 'div', children: [ &#123; type: 'item', repeat: &#123; expression: function () &#123; return this.list &#125;, key: '$index', value: '$value'&#125; &#125;, attr: &#123; imageUrl: function () &#123; return this.$value.imageUrl &#125;, title: function () &#123; return this.$value.title &#125; &#125; &#125; ] &#125;, data: function () &#123; return &#123; list: [ &#123; imageUrl: 'xxx', title: '111' &#125;, &#123; imageUrl: 'yyy', title: '222' &#125;, &#123; imageUrl: 'zzz', title: '333' &#125; ] &#125; &#125;&#125;)__weex_bootstrap__('app') v0.3.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is organized by several modules with AMD-like format: define('moduleName1', function (require, exports, module) &#123; // content of module1&#125;)define('moduleName2', function (require, exports, module) &#123; // content of module2&#125;)... A whole Weex JS Bundle is concatenated by these modules and last a bootstrap(rootComponentName, optionalConfig, optionalExternalData) function call. define('@weex-component/a', function (require, exports, module) &#123; // content of composed component &lt;a&gt;&#125;)define('@weex-component/b', function (require, exports, module) &#123; // content of composed component &lt;b&gt;&#125;)bootstrap('@weex-component/b') As the sample above, the component name should be hyphenated (a-z, 0-9, “-“). Other characters are not allowed. And, the method call bootstrap() allows 1~3 parameters: root module name (String), config info (optional JSON) and external data (optional JSON). Content of Composed ComponentsA module of composed component contains 3 parts: whole options definition, additional template option definition and additional style option definition. whole options is a piece of JavaScript code to put component options (except template option and style option) into module.exports template option is a piece of JSON-like object assigned to module.exports.template which describes the display structure of this component style option is a piece of JSON object assigned to module.exports.style which describes the reusable styles in this component The template option is required and appeared only once, and the style option and whole options definition are optional. These options are defined and transformed by Transformer. Actually you can also ignore all the format limitation and write options to module.exports as the same result if you are not going to use Transformer. But that’s not recommended. Details of template option definitionsA piece of multi-level embedded JSON-like object which describes the view structure. Every level JSON-like object has these members below: type: a required string, component name/type component: an optional boolean, whether this component is composed or native attr: an optional k-v pairs which contains all attributes of an element, the value could be a string, number, boolean or a function that bind some data value style: an optional k-v pairs which contains all styles of an element, just the same format as the attr classList: an optional array of strings which contains class names for styling. events: an optional k-v pairs whose keys are event type and values are corresponding method names children: an optional array of child components info append: an optional string which determines a compiling workflow strategy: append node-by-node singly or a whole node tree just one time. the default value is node and another supported value is tree. shown: a optional function which returns a boolean value to determine whether this component should be displayed repeat: a optional function which returns a list data to displays components with each Corresponding Keys to Weex Transformer: tag name in Weex file corresponds to type attr if in Weex file corresponds to shown attr repeat in Weex file corresponds to repeat attr append in Weex file corresponds to append attr style in Weex file with CSS syntax corresponds to style attr class in Weex file with class names separated by blanks corresponds to classList attr on*** in Weex file with prefix on corresponds to a k-v pair in events other attributes in Weex file corresponds to attr Child nodes in Weex file corresponds to children All tag names, attr names are case-insensitive and transformed to lower-cased. But the attr values are case-sensitive. Details of style option definitionsJust a two-levels JSON object. The first levels are class names. The second levels are k-v pairs which describes style names &amp; properties for each class name. Corresponding Keys to Weex Transformer: class name corresponds to first level keys prop name corresponds to second level keys prop value corresponds to second level values","type":"references"},{"title":"Virtual DOM APIs","path":"v-0.10/references/specs/virtual-dom-apis.html","permalink":"https://weex.apache.org/v-0.10/references/specs/virtual-dom-apis.html","text":"Virtual DOM APIs0.4 DocumentEach instance has a corresponding document with the instance id. A document has many nodes which compose a node tree. Constructornew Document(id: string, url: string?)MemberscreateElement(tagName: string, props: Object?): ElementCreate a certain type Element. And the props may contain attr object and style object. e.g. createBody(&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}}) createComment(text: string): CommentCreate a Comment with a certain comment text. open()Set a flag which means init rendering start, so each dom update will be called immediately close()Set a flag which means init rendering finished, so the dom updates later will be batched in each task. fireEvent(el: Element, type: string, e: Object?, domChanges: Object?)Fire an certain type of event on a certain element with an event object. When the event leads to some dom changes, the fourth parameter will describe the change just like props parameter in createElement method. Read-only &amp; Gettersid: stringURL: string?body: Elementbody element documentElement: Elementdocument element getRef(ref: string): Node?Get node by ref from the internal node map Note: the documentElement will be generated automatically when a document created, and the body should to be created manually and appended to documentElement to work. The type of a body must be one of div, list or scroller. NodeConstructornew Node()Membersdestroy()Read-only &amp; Gettersref: stringnextSibling: Node?previousSibling: Node?parentNode: Node?Element extends NodeConstructornew Element(type: string, props: Object?, ownerDocument: Document)Create an element and the props may contain attr object and style object. MembersDOM TreeappendChild(node: Node)insertBefore(node: Node, before: Node?)insertAfter(node: Node, after: Node?)removeChild(node: Node, preserved: boolean?)Removes a child. The parameter preserved means whether destroy the removed node immediately or preserve it. clear()DOM propssetAttr(key: string, value: string, silent: boolean?)If silent is true, it won’t cause native calls. Used for handling event with virtual-DOM changes. setStyle(key: string, value: string, silent: boolean?)The silent parameter is just same as setAttr method. setClassStyle(classStyle: Object)The specificity of class style is lower than normal style. In another way the normal style will override the same name value in class style. addEvent(type: string, handler: Function)removeEvent(type: string)fireEvent(type: string, e: any)Read-only &amp; GetterstoJSON(): ObjectFormat of {ref: string, type: string, attr: Object, style: Object, event: Array(string), children: Array} Comment extends NodeComment won’t be passed to the rendering engine. So it’s very useful as a assistant placeholder sometimes. Constructornew Comment(value: string)MembersRead-only &amp; Getterstype: stringReturns &#39;comment&#39; value: string","type":"references"},{"title":"JS Framework APIs","path":"v-0.10/references/specs/js-framework-apis.html","permalink":"https://weex.apache.org/v-0.10/references/specs/js-framework-apis.html","text":"JS Framework APIs0.4 Intro about JS RuntimeThese APIs are designed for JS Framework and Native Engine working together. Considering the limitation of mobile phone resource, Weex runs only one JS runtime to handle all Weex instances. So it need a multi-instance management layer in JavaScript. These JS Framework APIs are just designed to do the management job. First, each Weex instance have a lifecycle, from createInstance to destroyInstance. During this period, we can import some extra data by refreshInstance. To communicate with Native Engine, we have a couple of APIs: sendTasks and receiveTasks. They are used to call each other by some commands and messages. And when JS runtime start at the beginning of the app launching, we need something initialized and configured. So we supply some APIs like registerComponents, registerModules. The last API is just for debugging, we supply an API named getRoot to return the whole virtual-DOM data for developers. If any of these API calls failed, an Error object should be returned. Called by native and supplied from JS FrameworkcreateInstance(instanceId, code, options, data)Create a Weex instance from Native Engine instanceId: The unique id for a Weex instance, generated by Native Engine. code: The JS bundle code send from Native Engine. It will be executed by new Function(code) in JS Framework. The code format depends on JS Bundle Foramt options: Optional. An options object. Currently it supports debug flag which enable printing log and bundleUrl flag which the url of bundle. data: Optional. It’s an chance to supply external data instead of the original data in JS bundle. Example: createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')createInstance('x', '...', &#123; bundleUrl, debug, ... &#125;, &#123; a: 1, b: 2 &#125;&#125;) destroyInstance(instanceId)Destroy an existed Weex instance by id from Native Engine refreshInstance(instanceId, data)Refresh data to an existed Weex instance with certain external data from Native Engine Example: refreshInstance('x', &#123;a: 100, b: 200&#125;) registerComponents(components)Register all native components components: A array of whose items are component options that are force part to use. Currently it supports append attribute which forces the appending mechanism (tree or node) when first time rendering. Example: registerComponents([ &#123; type: 'container' &#125;, &#123; type: 'text' &#125;, &#123; type: 'image' &#125;, &#123; type: 'slider', append: 'tree' &#125;, &#123; type: 'list' &#125;, &#123; type: 'cell', append: 'tree' &#125;, ...]) registerModules(modules)Register the name, methods and args format of each module modules: A map that collects all native module definitions. Each module definition is an array which has several API definitions. Each API definition has a name string and an args array which contains a list of each parameter’s type. NOTE: the node type data will actually return its ref property. And the function type data will actually return a unique function id referring to it. Example: registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ], ...&#125;) receiveTasks(instanceId, tasks)Fire events or callbacks to an existed Weex instance from Native Engine tasks[]: A task list. Each task has a method=&quot;fireEvent|callback&quot; property and a list of args. In fireEvent method, the args is ref of the target, event type, event data and domChanges description in order. Note: if some event make virtual-DOM data changed (e.g. value changed in &lt;input&gt; or current index changed in &lt;slider&gt;), the changing of the target element will be passed as domChanges. In callback method, the args is funcId of a handler, data and ifKeepAlive which describes whether this callback handler should be keeping called. (Each callback handler is matched with a funcId when the original call happens.) Example: receiveTasks('x', [&#123;method: 'fireEvent', args: ['x', '13', 'click', &#123;a: 100, b: 200&#125;]&#125;])receiveTasks('x', [&#123;method: 'callback', args: ['x', '7', &#123;a: 100, b: 200&#125;, true]&#125;]) getRoot(instanceId)Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging Example: getRoot('x')// &#123;ref: '_root', type: 'container', attr: &#123;...&#125;, style: &#123;...&#125;, children: [...]&#125; Called from JavaScript and implemented with native codesendTasks(instanceId, tasks)Make native calls from JS Framework tasks[]: A task list. Each task has a module name, a method name, and a args[] list. Example: sendTasks('x', [ &#123;module: 'dom', method: 'addElement', args: ['_root', &#123;ref: '1', type: 'container'&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '2', type: 'text', ...&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '3', type: 'image', ...&#125;, -1]&#125;, ...]) Supporting other JS Framework (experimental)Register a new JS Framework// lib/frameworks/index.jsimport Vue from '...'import React from '...'import Angular from '...'export const frameworks = &#123; Vue, React, Angular&#125; Expose JS Framework APIs// 3rd-party-framework.jsexport function createInstance (id, code, config, data) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; The virtual-DOM tasks should follow virtual-DOM spec. Framework HelperYou can import lib/runtime/helper.js to get two important things: Document class, see virtual-DOM spec for more. sendTasks method. JS Bundle formatYou must ensure the JS Bundle has its first line of code like this: // &#123; \"framework\": \"Vue\" &#125;... to allow JS Runtime to detect which JS Framework it should be opened by. If no valid annotation found. The JS Bundle will be opened by default JS Framework of Weex.","type":"references"},{"title":"picker","path":"cn/references/modules/picker.html","permalink":"https://weex.apache.org/cn/references/modules/picker.html","text":"pickerv0.9+ 概述以下为 picker 相关的 API，用于数据选择，日期选择，时间选择。（ H5模块如需使用，请手动引入weex-picker组件） APIpick(options, callback[options])调用单选 picker 参数 options {Object}：调用单选 picker 选项 index {number}：默认选中的选项 items {array}：picker 数据源 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {number}：选择的选项,仅成功确认时候存在。 pickDate(options, callback[options])调用 date picker 参数 options {Object}：调用 date picker 选项 value {string}：必选，date picker 选中的值，date 的字符串格式为yyyy-MM-dd max {string}：可选，date 的最大值 min {string}：可选，date 的最小值 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：选择的值 date 的字符，格式为 yyyy-MM-dd, 仅成功确认的时候存在。 pickTime(options, callback[options])调用 time picker 参数 options {Object}：调用 time picker 选项 value {string}：必选，time 格式为 HH:mm callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：time 格式为 HH:mm, 仅成功确认的时候存在。 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"webview","path":"cn/references/modules/webview.html","permalink":"https://weex.apache.org/cn/references/modules/webview.html","text":"webview一系列的 &lt;web&gt; 组件操作接口。 比如 goBack、goForward、和 reload。webview module 与 &lt;web&gt; 组件共用。 示例查看 简单浏览器 ，一个结合 &lt;web&gt; 组件和 webview module 的示例。 APIgoBack(webElement)加载历史记录里的前一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 goForward(webElement)加载历史记录里的下一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 reload(webElement)刷新当前页面。 参数 webElement {Element}：&lt;web&gt; 组件对象。 注意事项：未来 &lt;web&gt; 组件的 Element 对象将会支持直接这些方法，届时 webview module 将不再需要 Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"在浏览器中调试","path":"cn/v-0.10/guide/how-to/debug-with-html5.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/how-to/debug-with-html5.html","text":"如何在浏览器中调试？由于 weex-html5 可以在现代移动浏览器上运行，因此自然支持在浏览器的开发工具中调试 weex-html5 代码。下面将介绍如何使用浏览器的 devTools 调试和分析 weex-html5 程序。以chrome的调试工具为例： Elements使用 Elements 面板来检查 weex-html5 页面的布局和设计，并操纵 DOM 和 CSS 来自由地做一些开发实验。 Console您可以使用 console.log 在控制台上记录信息。 断点您可以设置断点来调试代码，断点是调试代码的最有效的方法之一。断点使您能够暂停脚本执行，然后查看该时刻的调用堆栈变量值。 手动断点是您在特定代码行上设置的各个断点。您可以通过 Chrome DevTools GUI 或在代码中插入 debugger 关键字来设置这些断点。 找出 bug 的精确位置一般来说，有三个可能发生错误的地方：渲染器（weex-html5），js 框架（weex-js框架）和变压器（gulp-weex）。 这里有一些方便以找出错误建议，以便你可以快速识别哪个是哪个地方的错误： 请检查控制台是否有错误。在调试模式如果有一个错误出现，将会在 console 中打印有关于它的信息。 在 bridge/receiver.js，查看是否调用了 callNative 函数。 是否被认为是 API 的方法被执行。 是否调用用于事件触发或执行回调的 callJS 方法。 其他更多关于如何调试 H5 页面的信息请查看 chrome’s devTools docs","type":"guide"},{"title":"如何引入第三方库","path":"cn/v-0.10/guide/how-to/require-3rd-party-libs.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/how-to/require-3rd-party-libs.html","text":"如何引入第三方库0.4 在 Get started 中，我们学习了知道可以在 &lt;script&gt; 标签中编写 JavaScript 代码。但是在项目中常用的功能或模块，例如解析url参数，将属性从一些对象扩展到另一个对象等等，在每个组件中复制和粘贴这些代码是一个糟糕的做法，因此迫切需要通过 require 的方式对可复用的代码进行管理。Weex 为开发人员提供了 CommonJS 风格的 require 语法。 我们以 extend 作为例子。 引入本地 JS Modules下面是 extend 最简单的实现，并将其放在 ./common/utils.js 路径中。 function extend(dest, src) &#123; for (var key in src) &#123; dest[key] = src[key] &#125;&#125;exports.extend = extend 在 .we 文件中，extend 可以与require一起使用： &lt;script&gt; var utils = require('./common/utils') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; utils.extend(obj1, obj2) // obj1 =&gt; &#123;a: 1, b: 2&#125;&lt;/script&gt; 引入已经安装的 Node.js Modulesunderscore 是一个 JavaScript 库，它提供了一整套函数式编程的实用功能，而不扩展任何 JavaScript 内置对象。它提供了一个更具稳健性的 extend。 我们可以使用 underscore 的 extend，而不是我们自己实现的版本。首先，在项目中安装 underscore，然后我们便可以将 underscore reuqire 进来并使用它。 npm install underscore &lt;script&gt; var _ = require('underscore') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; var obj3 = &#123;c: 3&#125; var ret = _.extend(obj1, obj2, obj3) // ret =&gt; &#123;a: 1, b: 2, c: 3&#125;&lt;/script&gt;","type":"guide"},{"title":"将 `.we` 源代码转换成 JS Bundle","path":"cn/v-0.10/guide/how-to/transform-code-into-js-bundle.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/how-to/transform-code-into-js-bundle.html","text":"将 .we 源代码转换成 JS Bundle0.4 在前面的章节中你已经了解到如何编写及组织 Weex 代码，如果你还有疑问，可参考 语法 及 手册。 但是，Weex 语法的代码必须转换为 JSBundle，以便 Weex JSFramework 可以在 iOS，Android 和浏览器端解析和执行。了解更多信息，可参考 Weex 工作原理 和 JS Bundle 格式 现在，回到将 .we 源代码转换成 JS Bundle 的主题。有几种方法来实现这一目标。 使用 weex-toolkit如果你已经有了 node.js 开发环境，可以直接使用以下命令。关于 node.js 及其他依赖安装可参考安装依赖$npm install -g weex-toolkit 将 .we 文件转换为 JS Bundle$ weex your_best_weex.we -o . your_best_weex.we 将会被转换为 your_best_weex.js 并保存在当前目录。 将 .we 文件转换为 JS Bundle 并开启 watch 功能，实时自动转换$ weex your_best_weex.we -o . --watch 将所有 .we 文件转换到一个目录中$ weex we/file/storage/path -o outputpath we/file/storage/path 目录下的每个 .we 文件都会被转换为 JS Bundle 并保存到 outputpath 目录。 请访问 npmjs.com 了解更多关于 weex-toolkit。 transformernpm install weex-transformer CLI ToolUsage: transformer [options] &lt;file...&gt;Options: -h, --help output usage information -V, --version output the version number -l, --oldFormat [value] whether to transform to old format (default: false) -e, --isEntry [value] whether is an entry module which has `bootstrap` (default: true) -o, --output [path] the output file dirname API transform(name, code, path, elements, config) var transformer = require('weex-transformer')var output = transformer.transform('foo', '/* code here */', '.', &#123;&#125;) 参数： name {string}：当前 bundle 文件名 code {string}：源码 path {string}： 可选，当在某个路径中查找自定义组件时很有用 elements {Object}：可选，存在的自定义组件映射 config {Object}：可选 oldFormat {boolean}：是否转换为旧格式 （默认：false） isEntry {boolean}：是否是具有 bootstrap 的入口模块 （默认：true） 返回值: 一个对象： result {string}：所有自定义组件的 define() 方法和最终的 bootstrap() logs {Array}：相应的警告和错误日志 gulp weexnpm install gulp-weex var gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) 参数: oldFormat {boolean}：是否转换为旧格式 （默认：false） isEntry {boolean}：是否是具有 bootstrap 的入口模块 （默认：true）","type":"guide"},{"title":"组件通信","path":"cn/v-0.10/guide/syntax/comm.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/comm.html","text":"组件间通信自定义事件Weex 支持自定义事件，这里有两个相关的设计：1，监听自定义事件；2，创建自定义事件。 监听自定义事件每个 Weex 的 ViewModel 都支持 this.$on(type, handler) 和 this.$off(type[, handler]) 的 API。type 是监听的自定义事件类型，handler 是事件处理函数。 当 handler 被触发时，会有一个事件对象 event 作为第一个参数被传入，事件对象的数据格式基于事件机制中提到的事件描述对象。 创建自定义事件每个 Weex 的 ViewModel 都支持 this.$emit(type, detail) 的 API，可以在当前 ViewModel 中产生一个自定义事件。type 是自定义事件的类型，detail 则是一个对该事件细节补充描述的 JSON 对象，会以 event.detail 的形式出现在处理此事件的函数中。 从子组件向父组件通信首先父组件要监听特定类型的自定义事件，而子组件可以使用 this._parent 找到父组件，然后再调用 this._parent.$emit(type, detail) 方法，即可实现自下而上的通信。例如： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"thumb\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .thumb &#123; width: 200; height: 200; &#125; &lt;/style&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; // Emit notify to parent this._parent.$emit('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo title=\"Hello\" image-url=\"https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png\"&gt;&lt;/foo&gt; &lt;text if=\"eventType\"&gt;event: &#123;&#123;eventType&#125;&#125; - &#123;&#123;eventDetail&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; eventType: '', eventDetail: &#123;&#125; &#125;, created: function () &#123; this.$on('notify', function(event) &#123; // When a notify comes, this handler will be run. // `event.detail` will be `&#123;a: 1&#125;` this.eventType = event.type this.eventDetail = JSON.stringify(event.detail) &#125;) &#125; &#125;&lt;/script&gt; 体验一下 从父组件向子组件通信同理，首先子组件要监听特定类型的自定义事件，而父组件可以使用 this.$vm(id) 找到父组件，然后再调用 this.$vm(id).$emit(type, detail) 方法，即可实现自上而下的通信。例如： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image if=\"imageUrl\" src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"thumb\"&gt;&lt;/image&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .thumb &#123; width: 200; height: 200; &#125; &lt;/style&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; this.$on('changeImage', function (e) &#123; this.imageUrl = e.detail &#125;.bind(this)) &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo id=\"sub\"&gt;&lt;/foo&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$vm('sub').$emit( 'changeImage', 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png' ) &#125; &#125; &#125;&lt;/script&gt; 体验一下 下一节：页面整体配置","type":"guide"},{"title":"组件封装","path":"cn/v-0.10/guide/syntax/composed-component.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/composed-component.html","text":"组件封装经常我们会发现 Weex 的 &lt;template&gt; 中有很多可复用的部分，这时候我们可以将其封装成上层的自定义组件并重用。例如我们可以直接创建一个名为 foo.we 的文件，&lt;foo&gt; 就是自定义组件的组件名称： &lt;!-- foo.we --&gt;&lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var env = 'foo' module.exports = &#123; data: &#123; title: null, image: null &#125; &#125;&lt;/script&gt; foo.we 的也包含 &lt;template&gt;，&lt;style&gt; 和 &lt;script&gt;，定义好了后，直接用 &lt;foo&gt; 标签即可将其引入到其它组件的 &lt;template&gt; 中，并且在 &lt;foo&gt; 标签上设置其 data 同名的特性会将这个值赋给 &lt;foo&gt; 的上下文： 注意事项：由于 HTML 语法中特性名是不区分大小写的，所以您无法直接用驼峰命名，我们提供了 hyphenated 语法，在解析之后这些名称会自动转换为驼峰命名 (比如在 &lt;template&gt; 的组件特性里用 aaa-bbb-ccc 表示其 data 或上下文里的 aaaBbbCcc)。 &lt;!-- bar.we --&gt;&lt;template&gt; &lt;foo title=\"...\" image=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; var env = 'bar'&lt;/script&gt; 注意事项：这里 bar.we 和 foo.we 必须在同目录下才能自动建立依赖关系。 注意事项：foo.we 文件的 &lt;script&gt; 具有相对独立的作用域，不会和 bar.we 中的 &lt;script&gt; 产生干扰。同时 &lt;foo&gt; 对象具有相对独立的子组件上下文，即 this，也包括其定义的完全不同的数据和方法。 组件嵌套自定义组件也支持嵌套，如下： &lt;!-- somepath/foo.we --&gt;&lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; // These keys must be declared explicitly here // or data-binding will not work from its parent. title: null, image: null &#125; &#125;&lt;/script&gt; &lt;!-- samepath/foo.list.we --&gt;&lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;description&#125;&#125;&lt;/text&gt; &lt;foo repeat=\"item in list\" title=\"&#123;&#123;item.text&#125;&#125;\" image=\"&#123;&#123;item.img&#125;&#125;\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; description: '', // This key must be declared explicitly here // or data-binding will not work from its parent. list: [] &#125; &#125;&lt;/script&gt; &lt;!-- samepath/main.we --&gt;&lt;template&gt; &lt;foo-list list=\"&#123;&#123;list&#125;&#125;\"&gt;&lt;/foo-list&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; 这里的 main.we 嵌套了 &lt;foo-list&gt;，&lt;foo-list&gt; 嵌套了 &lt;foo&gt;，同时组件可以正常的配合数据绑定、repeat 特性等使用。 更多子组件的定义和书写方式除了在主文件同目录下创建和被封装组件同名的 we 文件之外，Weex 还支持另外几种子组件的书写方式： 在 &lt;script&gt; 中通过 require 其它目录的 we 文件定义同名组件 在主文件下新增 &lt;element name=&quot;xxx&quot;&gt; 标签，name 特性的值为新创建的组件名，其 &lt;element&gt; 内部的内容是定义该组件的代码 比如： &lt;!-- path-a/main.we --&gt;&lt;element name=\"foo\"&gt; &lt;text&gt;Foo&lt;/text&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('path-b/bar.we')&lt;/script&gt; &lt;!-- path-b/bar.we --&gt;&lt;template&gt; &lt;text&gt;Bar&lt;/text&gt;&lt;/template&gt; 这样的话，path-a/main.we 最终展示的结果是“Foo”和“Bar”两段文本。 注意事项 组件各自的 &lt;style&gt; 是相互独立的，不会担心不同组件中相同的 class name 相互干扰。 如果自定义组件在父组件中有 id 特性，则可以在父组件上下文中通过 this.$vm(id) 接口来访问该自定义组件的上下文，也可以通过 this.$el(id) 来找到其背后真实的原生组件。更多详见获取子组件信息 自定义组件之间通信的问题可以参考组件间通信 不论通过父组件把数据传递进来还是在当前组件内部对数据发起修改，只有在组件的 data 选项中明确写明的字段才会被正常的监听。 任何组件目前均不支持自闭合标签的写法，请勿使用。 下一节：获取子组件信息","type":"guide"},{"title":"页面配置和页面数据","path":"cn/v-0.10/guide/syntax/config-n-data.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/config-n-data.html","text":"页面配置和页面数据在 Weex 中，你可以通过一些特殊的 &lt;script&gt; 进行页面整体配置。 注意事项：这些配置会代表页面整体，所以写在自定义子组件中是无效的，只有写在顶级 ViewModel 的 &lt;sctipt&gt; 中才会生效。 先举个例子： &lt;!-- definition of sub components --&gt;&lt;element name=\"sub-component-a\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-b\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-c\"&gt;...&lt;/element&gt;&lt;!-- definition of top-level component --&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; x: 1, y: 2 &#125; &#125;&lt;/script&gt;&lt;!-- config and data --&gt;&lt;script type=\"config\"&gt; downgrade: &#123; ios: &#123; os: '9', // all of 9.x.x app: '~5.3.2', framework: '^1.3', // all of 1.3.x deviceModel: ['AAAA', 'BBBB'] &#125;, android: &#123; os: '*', // all of version app: '^5', framework: '', deviceModel: '' &#125; &#125;&lt;/script&gt;&lt;script type=\"data\"&gt; &#123; y: 200 &#125;&lt;/script&gt; &lt;script type=&quot;config&quot;&gt;开发者可以在顶级 ViewModel 中加入这样一段 &lt;script&gt;，以 JSON 格式描述页面整体的配置信息。 目前支持的配置信息只有 downgrade：用来从平台、应用等维度描述页面的降级规则。这样设计对于产品迭代最大的帮助是可以在高版本中使用 Weex，而在低版本中使用之前已有的渲染方式，这部分控制降级的细节需要 native 接入的时候进行相应的识别和具体操作。 未来这里会有更多的配置项出现在这里。 &lt;script type=&quot;data&quot;&gt;开发者可以在顶级 ViewModel 中加入这样一段 &lt;script&gt;，以 JSON 格式额外配置顶级 ViewModel 的数据，它会覆盖顶级 ViewModel 数据中相应的字段。比如上述例子中，最终的顶级 ViewModel 中的数据为 { x: 1, y: 200 }。 总结至此，Weex 基本的语法已经全部介绍过了。相信您对 Weex 的使用方式和开发方式有了更多的了解。 接下来我们推荐您阅读： 最佳实践 Weex 手册","type":"guide"},{"title":"数据绑定","path":"cn/v-0.10/guide/syntax/data-binding.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/data-binding.html","text":"数据绑定Weex使用 mustache 的语法 ({{...}}) 来对 &lt;template&gt; 中的模板和 &lt;script&gt; 里的数据进行绑定. 一旦数据额模板绑定了, 数据上的修改会实时的在模板内容中生效。 数据绑定路径&lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 48, title: 'Alibaba Weex Team' &#125; &#125;&lt;/script&gt; 体验一下 上面的代码会把 title 和 size 的数值绑定到模板内容上。 我们也可以通过 . 符号来绑定数据结构中的字段。看一下下面的代码片段： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;title.size&#125;&#125;\"&gt;&#123;&#123;title.value&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: &#123; size: 48, value: 'Alibaba Weex Team' &#125; &#125; &#125;&lt;/script&gt; 体验一下 数据绑定表达式进行数据绑定时，Weex 支持一些简单的 JavaScript 表达式，例如： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125; &#125;&lt;/script&gt; 体验一下 这些表达式会在当前的上下文中进行运算。 计算属性 v0.5+数据绑定表达式已经非常方便了，但如果希望在模板里实现更复杂的逻辑判断，你也可以使用计算属性。例如： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left: 10;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: function() &#123; return this.firstName + ' ' + this.lastName &#125; &#125;, methods: &#123; changeName: function() &#123; this.firstName = 'Terry' &#125; &#125; &#125;&lt;/script&gt; 体验一下 同样能够达到相同的效果。这里我们引入了一个叫做 fullName 的计算属性，由 firstName 和 lastName 计算而成，在数据绑定的时候，如果 firstName 或 lastName 发生改变，fullName 都会自动重新计算并触发改变。 另外计算属性还支持另外一种写法，就是同时定义一个计算属性的 getter 和 setter，这样的话当下面例子中的 fullName 被赋值时，data 里的 firstName 和 lastName 会被自动改变： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left: 10;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName &#125;, set: function(v) &#123; var s = v.split(' ') this.firstName = s[0] this.lastName = s[1] &#125; &#125; &#125;, methods: &#123; changeName: function() &#123; this.fullName = 'Terry King' &#125; &#125; &#125;&lt;/script&gt; 体验一下 注意事项：data、methods、computed 中的字段是不能相互重复的，因为它们都会通过组件实例的 this 访问到。 数据绑定在 &lt;template&gt; 中的特殊用法样式: style 或 class组件的样式能够通过 style 特性进行绑定： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;; color: &#123;&#123;color&#125;&#125;;\"&gt;Hello World&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 32, color: '#ff0000' &#125; &#125;&lt;/script&gt; 体验一下 样式也能够通过 class 特性实现样式绑定，多个 class 名通过空格分隔： &lt;template&gt; &lt;div&gt; &lt;text class=\"&#123;&#123;size&#125;&#125;\"&gt;Hello&lt;/text&gt; &lt;text class=\"title &#123;&#123;status&#125;&#125;\"&gt;World&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .large &#123; font-size: 64; &#125; .small &#123; font-size: 32; &#125; .title &#123; font-weight: bold; &#125; .success &#123; color: #00ff00; &#125; .error &#123; color: #ff0000; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 'large', status: 'success' &#125; &#125;&lt;/script&gt; 体验一下 在上面的代码中如果 {{size}} 和 {{status}} 是空值, 就只有 class=&quot;title&quot; 会被解析。 延伸阅读：style 和 class 事件绑定：on...以 on... 开头的就是用于绑定事件的特性，特性名中 on 之后的部分就是事件的类型，特性的值就是处理该事件的函数名。函数名外不需要添加 mustache 语法中的大括号。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: true &#125;, methods: &#123; toggle: function () &#123; this.result = !this.result &#125; &#125; &#125;&lt;/script&gt; 体验一下 除此之外 Weex 还支持更多的事件处理方式。 延伸阅读：事件处理 展示逻辑控制 if &amp; repeatif 特性能够通过特性值的真假来控制组建是否显示，且 mustache 大括号可以省略。例如： &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image if=\"&#123;&#123;shown&#125;&#125;\" src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .logo &#123; width: 512; height: 512; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true, imageUrl: 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png' &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; 体验一下 repeat 特性可以根据一组数组数据重复生成相同或相似的顺序排列的界面。例如： &lt;template&gt; &lt;div&gt; &lt;text repeat=\"(k,v) in list\"&gt;&#123;&#123;k&#125;&#125; - &#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: ['a', 'b', 'c'] &#125; &#125;&lt;/script&gt; 体验一下 延伸阅读：展示逻辑控制 静态模板优化 static v0.9.2+static 特性可以一次性把数据设置到模板相应的位置上，但是今后不会随着数据的变化而更新。这样可以减少无谓的数据绑定，有效控制和优化长列表、纯静态页面在运行时的开销。不过你也要小心使用不要导致原本需要更新的视图没有触发更新。 &lt;template&gt; &lt;div static&gt; &lt;text&gt;&#123;&#123; word &#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; ready: function() &#123; this.word = 'Data changes' // UI won't be updated &#125;, data: &#123; word: 'Hello static' &#125; &#125;&lt;/script&gt; 体验一下 如上所示，添加 static 关键字，渲染结果会是“Hello static”字样，相当于渲染一个静态的节点，ready 函数中对数据 word 的改变不会更新到视图。 下一篇：style 和 class","type":"guide"},{"title":"展示逻辑控制","path":"cn/v-0.10/guide/syntax/display-logic.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/display-logic.html","text":"展示逻辑控制Weex 支持通过两种特殊的特性 if 和 repeat 确定组件的显示逻辑，这会使得整个界面的展示逻辑控制更加简单灵活。 if通过设置 if 特性值，你可以控制当前组件是否显示。如果值为真，则当前组件会被渲染出来，如果值为假则会被移除。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle Image&lt;/text&gt; &lt;image if=\"shown\" src=\"&#123;&#123;imageUrl&#125;&#125;\" style=\"width: 512; height: 512;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; imageUrl: 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png', shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125;&#125;&lt;/script&gt; 体验一下 注意事项：if=&quot;condition&quot; 和 if=&quot;{{condition}}&quot; 都是可以的，两者等价使用。 注意事项：if 不能用在 &lt;template&gt; 的根组件上，否则将无法被 Weex 正常的识别和处理。 if 不会阻断子元素的数据更新下面这个例子在数据更新后 item 或 item.image 不存在的情况下会报错： &lt;template&gt; &lt;div if=\"&#123;&#123;(item &amp;&amp; item.image)&#125;&#125;\" style=\"width: 200; height: 200;\"&gt; &lt;image style=\"width: 100; height: 100;\" src=\"&#123;&#123;item.image.url&#125;&#125;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; 原因在于 Weex 本身的机制是数据更新在 DOM 更新之前，因此 if 数据更新之后，不支持阻断其子元素的数据更新，即 if 数据更新为 false 之后，内部的子元素仍然会触发自身的数据更新，找不到对应字段，导致报错，可参考这个 issue。 因此，有两种解决方案： 为 img 组件的 src 也增加容错方案： &lt;div if=\"&#123;&#123;(item &amp;&amp; item.image)&#125;&#125;\" style=\"width: 200; height: 200;\"&gt; &lt;image style=\"width: 100; height: 100;\" src=\"&#123;&#123;item &amp;&amp; item.image &amp;&amp; item.image.url&#125;&#125;\"&gt;&lt;/image&gt;&lt;/div&gt; 如果是在 repeat 的列表中，还可以使用 track-by强制不复用子元素解决。 repeatrepeat 特性用于重复渲染一组相同的组件。它绑定的数据类型必须为数组，数组里的每一项数据可以体现在不同的组件特性、样式、事件绑定等。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 此外，repeat 特性还支持绑定数组中数据项目的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"(index, person) in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 每一个昵称之前都有对应数组项目的索引值。 注意事项：同样的 repeat=&quot;...&quot; 和 repeat=&quot;{{...}}&quot; 都是可以的，两者等价使用。 注意事项：if 不能用在 &lt;template&gt; 的根组件上，否则将无法被 Weex 正常的识别和处理。 注意事项: 当你修改 repeat 中的数组时，在写法上会受到一定的限制，具体如下： 直接通过“角标”修改数组的某个项目 (如 this.items[0] = ...) 是不会触发视图自动更新的。我们在数组的原型上提供了一个额外的方法：this.items.$set(index, item) 来完成相同的事情。 // 和 `this.items[0] = ...` 作用相同，但会自动触发视图更新this.items.$set(0, &#123; childMsg: 'Changed!'&#125;) 直接通过修改 length 来改变数组长度 (如 this.items.length = 0) 也是不会触发视图自动更新的。我们推荐您直接赋值一个新的空数组把旧的替换掉。 // 和 `this.items.length = 0` 作用相同，但会自动触发视图更新this.items = [] repeat 特性中的 $index 形参在 repeat 特性值中，如果没有指定索引值的形参，则可以通过绑定形参 $index 来展示数组项目的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 渲染效果和上一个例子应该是相同的。 在 repeat 中使用 track-by 特性追踪变化通常情况下，当更新 repeat 中绑定的数组时，所有数组项目关联的组件都会被重新渲染。如果其中部分索引值对应的数据未发生变更，那么最好是让这些组件在渲染层保持原样，仅更新数据有变化的节点。Weex 提供了 track-by 特性来辅助判断哪些数组项目发生了改变。 首先 track-by 特性的值必须是在每一条数组项目中都有且值没有重复的一个字段名，用来区分和追踪每一条数据项增删与否或次序变化与否的关键依据。每当数组发生变化之后，新老数组数据会根据 track-by 特性值所代表的字段重新匹配，然后再决定渲染层应该新建或删除一个组件？还是移动一个组件？还是讲组件保持原来的位置。默认的 track-by 的值就是数组的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text&gt;----&lt;/text&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\" track-by=\"id\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text&gt;----&lt;/text&gt; &lt;!-- something wrong here: duplicated track-by value --&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\" track-by=\"nickname\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; id: 11, gender: 'male', nickname: 'Li Lei' &#125;, &#123; id: 22, gender: 'female', nickname: 'Han Meimei' &#125;, &#123; id: 33, gender: 'male', nickname: 'Jim Green' &#125; ] &#125;, ready: function () &#123; this.list.unshift(&#123; id: 44, gender: 'female', nickname: 'Han Meimei' &#125;) &#125;&#125;&lt;/script&gt; 体验一下 这种情况下，第一个列表的更新策略是： 把第一个 &lt;text&gt; 赋值为 Han Meimei 第二个赋值为 Li Lei 第三个赋值为 Han Meimei 最后新建一个 &lt;text&gt; 并赋值为 Jin Green 第二个列表的更新策略是： 在最前面新建一个 &lt;text&gt; 并赋值为 Han Meimei 第三个列表的更新会遇到问题，因为有两个数组项目的 nickname 值都是 Han Meimei 所以造成意料之外的渲染结果 (只渲染了三个数组项目)。 下一节：渲染过程控制","type":"guide"},{"title":"找节点","path":"cn/v-0.10/guide/syntax/id.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/id.html","text":"找节点在 Weex 中，您可以通过在特定的子组件上设置 id 特性，以此在该 &lt;template&gt; 内唯一标识这个组件。 获取子组件您可以在父组件上下文中使用 this.$el(id) 来找到该组件，以运用 scrollToElement() 为例： &lt;template&gt; &lt;div&gt; &lt;text id=\"goto-top\"&gt;Top&lt;/text&gt; &lt;div style=\"height: 10000; background-color: #999999;\"&gt;&lt;/div&gt; &lt;text onclick=\"back2Top\"&gt;Back to Top&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') module.exports = &#123; methods: &#123; back2Top: function () &#123; var el = this.$el('goto-top') dom.scrollToElement(el, &#123; offset: 10 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 id 和 repeat 特性配合使用id 也可以和 repeat 语法配合使用，关于 repeat 更多详见 展示逻辑控制，但是要确保循环的节点需要用不同的 id，比如： &lt;template&gt; &lt;div&gt; &lt;image repeat=\"image in images\" id=\"img-&#123;&#123;image.id&#125;&#125;\" src=\"&#123;&#123;image.url&#125;&#125;\" onclick=\"getImageId\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; images: [ &#123;id: 1, url: '...'&#125;, &#123;id: 2, url: '...'&#125;, &#123;id: 3, url: '...'&#125;, ... ] &#125;, methods: &#123; getImageId: function(e) &#123; // get e.target.id &#125; &#125;&#125;&lt;/script&gt; 获取自定义子组件的上下文另外，我们还可以通过 this.$vm(id) 方法可以访问自定义子组件的上下文： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: null &#125;, methods: &#123; setTitle: function (text) &#123; this.title = text &#125; &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo id=\"sub\" title=\"Hello\"&gt;&lt;/foo&gt; &lt;text onclick=\"update\"&gt;Click Me to Update&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; update: function (e) &#123; this.$vm('sub').setTitle('Updated') &#125; &#125; &#125;&lt;/script&gt; 体验一下 实际上，如上述的例子，我们找到子组件上下文之后，直接在这个上下文中调用子组件方法或修改子组件的数据并不是我们认为最好的方式，我们更倾向于通过一套确定的组件间通信机制来完成这一工作。 获取父级组件或其上下文除了可以自上而下寻找组件或其上下文，Weex 也支持自下而上做相同的事情。当前上下文中的 this._parent 可以获取其父级上下文。除了父级上下文，对于父级组件本身，相关处理也可以基于先获取父级上下文，然后在父级组件内部完成更多更细致的处理。更多内容可以深入了解组件间通信的部分。 _注意事项：在未来的版本中 this._parent 将改为 this.$parent。_ 下一篇： 组件间通信","type":"guide"},{"title":"事件处理","path":"cn/v-0.10/guide/syntax/events.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/events.html","text":"事件处理Weex 允许对 &lt;template&gt; 中的元素绑定事件处理函数。 基本语法以 on... 开头的就是用于绑定事件的特性，特性名中 on 之后的部分就是事件的类型，特性的值就是处理该事件的函数名。函数名外不需要添加 mustache 语法中的大括号。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: true &#125;, methods: &#123; toggle: function () &#123; this.result = !this.result &#125; &#125; &#125;&lt;/script&gt; 体验一下 内联事件处理参数同时我们也支持在事件绑定的特性值中内联写明被传入的参数。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"update(1, 2)\"&gt;Result: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: '&lt;empty&gt;' &#125;, methods: &#123; update: function (x, y) &#123; this.result = x + y &#125; &#125; &#125;&lt;/script&gt; 体验一下 特殊的内联事件处理参数额外的，在这种内联的事件绑定写法中，你可以使用一个特殊的参数 $event，代表事件描述对象，即默认事件处理函数的第一个参数。所以 &lt;template&gt; 中的 onclick=&quot;foo&quot; 和 onclick=&quot;foo($event)&quot; 是等价的，$event 的用法可以更多参考下面的例子 &lt;template&gt; &lt;div&gt; &lt;text onclick=\"update($event, 1, 2)\"&gt;Result: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: '&lt;empty&gt;' &#125;, methods: &#123; update: function (e, x, y) &#123; this.result = e.type + (x + y) &#125; &#125; &#125;&lt;/script&gt; 体验一下 事件描述对象每当一次事件被触发的时候，都会产生一个事件描述对象，该对象会默认作为第一个参数传递给事件处理函数，或以 $event 形参的方式出现在内联事件处理函数中。 每个事件描述对象至少包含以下几个特性： type (string): 事件名称, 如: click target (Element): 目标元素 timestamp (number): 事件触发时的时间戳数字 下一节：展示逻辑控制","type":"guide"},{"title":"渲染过程控制","path":"cn/v-0.10/guide/syntax/render-logic.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/render-logic.html","text":"渲染过程控制appendappend 特性定义了当前组件的子组件： 以一整棵树的方式一次性添加到视图中 (append=&quot;tree&quot;)，还是 每个子组件都产生一次单独的添加到视图的指令 (append=&quot;node&quot;) &lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;div append=\"node\"&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;div append=\"tree\"&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 在上面的代码中，第一组和第二组 &lt;div&gt; 的渲染过程相同，即先添加空的父级 &lt;div&gt;，然后插入第一个 &lt;text&gt; Hello，然后插入第二个 &lt;text&gt; Weex；第三组 &lt;div&gt; 则是连带两个 &lt;text&gt; 子组件一齐传给渲染层进行渲染的。 渲染结果显而易见，前两组渲染方式会使首次绘制的响应速度比后者快些，但是总渲染时间可能比第三组 append=&quot;tree&quot; 更长。开发者可以根据实际界面的情况自行选择合理的渲染过程。 默认情况下，除了 &lt;cell&gt; 组件的默认渲染过程是 tree 模式，其它组件都默认按照 node 模式进行渲染。 下一节：自定义组件","type":"guide"},{"title":"CSS 样式和类","path":"cn/v-0.10/guide/syntax/style-n-class.html","permalink":"https://weex.apache.org/cn/v-0.10/guide/syntax/style-n-class.html","text":"CSS 样式和类基础语法CSS 样式可以理解为一系列的键值对，其中的每一对描述了一个特定的样式，例如组件的宽或者高。 .div &#123; width: 400; height: 50;&#125; 键值对的形式是 prop-name: prop-value;。键名是 prop-name，键值是 prop-value。 一般情况下，键名按照连接符的方式进行命名，键和值之间由冒号 : 进行分隔，每对键值之间由分号 ; 进行分隔。 在 Weex 页面上样式有两种形式： &lt;template&gt; 中的 style 特性 &lt;style&gt; 样式表 &lt;template&gt; 中的 style 特性在 style 特性中编写样式，例如： &lt;template&gt; &lt;div style=\"width: 400; height: 50;\"&gt; ... &lt;/div&gt;&lt;/template&gt; 这段代码的意思是 &lt;div&gt; 组件的宽和高分别为 400 像素和 50 像素。 &lt;style&gt; 样式表例如: &lt;style&gt; .wrapper &#123; width: 600; &#125; .title &#123; width: 400; height: 50; &#125; .highlight &#123; color: #ff0000; &#125;&lt;/style&gt; 样式表包含了多个样式规则，每条规则有一个对应的类，以及由 {...} 包括的若干条样式。例如： .title &#123; width: 400; height: 50; &#125; class 特性&lt;template&gt; 标签中的 class 特性值用来匹配 &lt;style&gt; 样式表中的一个或多个 class 名，多个 class name 之间由空格分隔。例如： &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"title\"&gt;...&lt;/text&gt; &lt;text class=\"title highlight\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; width: 600; &#125; .title &#123; width: 400; height: 50; &#125; .highlight &#123; color: #ff0000; &#125;&lt;/style&gt; 体验一下 这段代码的含义是 &lt;div&gt; 组件的宽度是 600 像素，两个 &lt;text&gt; 组件的尺寸为 400x50，其中第二个文本组件是红色字。 注意事项 为了简化页面设计和实现，屏幕的宽度统一为 750 像素，不同设备屏幕都会按照比例转化为这一尺寸进行长度计算。 标准 CSS 支持很多样式选择器，但 Weex 目前只支持单个 class name 的选择器。 标准 CSS 支持很多的长度单位，但 Weex 目前只支持像素，并且 px 单位可以忽略不写，直接使用对应的数值。更多详情请查看通用样式。 子元素的样式不会继承自父元素，这一点与标准 CSS 不同，比如 color 和 font-size 等样式作用在 &lt;text&gt; 上层的 &lt;div&gt; 上是无效的。 标准 CSS 包含了非常多的样式属性，但 Weex 只支持了其中的一部分，比如盒模型、flexbox、position 等布局属性，以及 font-size、color 等其它样式。 与数据绑定结合请查阅数据绑定中有关 style 和 class 特性的相关部分。这里简单举个例子： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;fontSize&#125;&#125;;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large &#123;&#123;textClass&#125;&#125;\"&gt;Weex Team&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 32;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; fontSize: 32, textClass: 'highlight' &#125; &#125;&lt;/script&gt; 体验一下 下一篇：事件处理","type":"guide"},{"title":"<a>","path":"cn/v-0.10/references/components/a.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/a.html","text":"&lt;a&gt;&lt;a&gt; 组件定义了指向某个页面的一个超链接. 此组件的作用和用法与HTML5中的 &lt;a&gt; 非常类似，区别在于 Weex 的 &lt;a&gt; 组件不能直接在里面添加文本（字符串），如果要展示文本，应该添加 &lt;text&gt; 组件。 一个简单例子： &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a href=\"http://dotwe.org/raw/dist/a468998152ee680413588c38bd61c29e.js\"&gt; &lt;text&gt;click&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; text-align: center;&#125;&lt;/style&gt; 体验一下 子组件此组件支持除了自己外的所有 Weex 组件作为子组件。 特性 href {string}：定义了超链接的 URL。 样式&lt;a&gt; 支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式。 事件&lt;a&gt; 支持所有通用事件。 click注意：我们不能保证 click 事件和 href 跳转的执行顺序。建议不要使用 click 事件来处理 href 跳转前的逻辑处理。 longpress appear disappear 查看 通用事件。 约束 不能直接在 &lt;a&gt; 中添加文本。错误示例，“click” 无法被正常渲染。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a href=\"http://dotwe.org/raw/dist/a468998152ee680413588c38bd61c29e.js\"&gt; click &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; text-align: center;&#125;&lt;/style&gt; 体验一下 请不要为 &lt;a&gt; 添加 click 事件。我们不能确保 click 事件和 href 跳转的执行顺序。 示例&lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"lines\"&gt; &lt;text class=\"item\"&gt;Repo name: &lt;/text&gt;&lt;a href=\"&#123;&#123;item.repo_url&#125;&#125;\"&gt;&lt;text class=\"link\"&gt;&#123;&#123;item.full_name&#125;&#125;&lt;/text&gt;&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.header &#123; padding: 25; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.list &#123; background-color: #ffffff;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;.lines &#123; flex-direction: row;&#125;.link &#123; color: #008cff; text-decoration: underline;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc', PAGE_URL = 'http://dotwe.org/raw/dist/f1fa0895d0fa0fd80896e02a589443dd.js'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; var repo_url = results[i].html_url if (repo_url) &#123; results[i].repo_url = self.processUrl(repo_url) &#125; self.items.push(results[i]) &#125; &#125; &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125;, processUrl: function (url) &#123; var platform = this.$getConfig().env.platform.toLowerCase() if (url) &#123; // iOS do not need encode if (platform === 'ios') &#123; return PAGE_URL + '?weburl=' + url &#125; else if (platform === 'web') &#123; return url &#125; else &#123; var encodeUrl = encodeURIComponent(url) return PAGE_URL + '?weburl=' + encodeUrl &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; 体验一下。","type":"references"},{"title":"<cell>","path":"cn/v-0.10/references/components/cell.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/cell.html","text":"&lt;cell&gt;用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; 组件的子组件, 这是为了优化滚动时的性能。 子组件支持所有 Weex 的组件作为它的子组件。 样式注意： 你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例 &lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.header &#123; padding: 25; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.list &#123; background-color: #ffffff;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; page: 1, loadingDisplay: 'show', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<div>","path":"cn/v-0.10/references/components/div.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/div.html","text":"&lt;div&gt;&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 不可滚动，即使显式设置高度也一样。 错误示例 示例 &lt;style&gt;.item &#123; padding: 20; height: 220; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.item-content &#123; flex-direction: row; width: 710; background-color: #ffffff;&#125;.item-imgbox &#123; height: 180; width: 180; margin-right: 20;&#125;.item-img &#123; width: 180; height: 180;&#125;.item-info &#123; height: 180; width: 510; justify-content: center; position: relative;&#125;.item-info-detail &#123; position: relative; color: #A2A2A2;&#125;.desc &#123; lines: 4; text-overflow: ellipsis; font-size: 26; line-height: 30; color: #A2A2A2;&#125;.title &#123; lines: 1; text-overflow: ellipsis; font-size: 32; color: #2D2D2D; line-height: 40;&#125;.detail-info &#123; margin-top: 15;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;scroller&gt; &lt;div class=\"item\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item-content\"&gt; &lt;div class=\"item-imgbox\"&gt; &lt;img class=\"item-img\" src=\"&#123;&#123;item.img&#125;&#125;\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;div class=\"item-info-detail\"&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;div class=\"detail-info\"&gt; &lt;text class=\"desc\"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') || &#123;&#125; module.exports = &#123; data: &#123; items: [&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;] &#125;, created: function () &#123; &#125;, methods: &#123; goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<image>","path":"cn/v-0.10/references/components/image.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/image.html","text":"&lt;image&gt;&lt;image&gt; 组件用于渲染图片，并且它不能包含任何子组件。可以用 &lt;img&gt; 作简写。 需要注意的是，需要明确指定 width 和 height，否则图片无法显示。 简单例子： &lt;template&gt; &lt;div&gt; &lt;img style=\"width: 560;height: 560;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/img&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 子组件&lt;image&gt; 组件不支持任何子组件，因此不要尝试在 &lt;image&gt; 组件中添加任何组件。如果需要实现 background-image 的效果，可以使用 &lt;image&gt; 组件和 position 定位来现实，如下面代码。 &lt;template&gt; &lt;div&gt; &lt;img style=\"width:750; height:750;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/img&gt; &lt;div class=\"title\"&gt; &lt;text style=\"font-size:50; color: #ff0000\"&gt;你好，image&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .title&#123; position:absolute; top:50; left:10; &#125;&lt;/style&gt; 体验一下 特性&lt;image&gt; 组件，包含 src 和 resize 两个重要特性。 src {string}：定义图片链接，目前图片暂不支持本地图片。 resize {string}：可以控制图片的拉伸状态，值行为和 W3C 标准一致。 可选值为： stretch：默认值，指定图片按照容器拉伸，有可能使图片产生形变。 cover：指定图片可以被调整到容器，以使图片完全覆盖背景区域，图片有可能被剪裁。 contain：指定可以不用考虑容器的大小，把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 例子： 体验一下 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 load v0.8+：当图片加载完成时触发。目前在 Android、iOS 上支持，H5 暂不支持。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 需要指定宽高； 不支持子组件。 示例我们这里展示了一篇文章，文章标题有一副背景图。 这个效果实现起来非常容易，我们只需要将标题文案通过 position: absolute 进行定位即可。唯一需要注意的一点是，Weex 目前不支持 z-index，因此必须把上层元素放在后。 &lt;style&gt; .page-head &#123; width:750; height:200; &#125; .title-bg &#123; width:750; height:200; &#125; .title-box &#123; width: 750; height: 200; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32; font-weight: bold; &#125; .article &#123; padding: 20; &#125; .paragraph&#123; margin-bottom: 15; &#125;&lt;/style&gt;&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/image&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt; 体验一下","type":"references"},{"title":"<indicator>","path":"cn/v-0.10/references/components/indicator.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/indicator.html","text":"&lt;indicator&gt;&lt;indicator&gt; 组件用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件&lt;indicator&gt; 组件没有任何子组件。 样式&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：设置项的颜色，可以是颜色的名称，例如 red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-selected-color {color}：被选中时的颜色，可以是颜色的名称，red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-size {number}：元素的个数。 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束 不支持子组件。 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<input>","path":"cn/v-0.10/references/components/input.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/input.html","text":"&lt;input&gt;Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 &lt;text&gt;， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 &lt;input&gt; 或 change 来代替 click 事件。 子组件不支持子组件。 特性 type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，password，url，email，tel 。每个 type 值都符合 W3C 标准。 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 样式 placeholder-color {color}：placeholder 字符颜色。默认值是 #999999。 text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 约束目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\" @focus=\"onfocus\" @blur=\"onblur\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; const modal = weex.requireModule('modal') module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, onfocus () &#123; console.log('onfocus:'); modal.toast(&#123; message: 'onfocus', duration: 0.8 &#125;) &#125;, onblur () &#123; console.log('onblur:'); modal.toast(&#123; message: 'input blur', duration: 0.8 &#125;) &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<list>","path":"cn/v-0.10/references/components/list.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/list.html","text":"&lt;list&gt;&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 一个最简例子： &lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 子组件&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 一个错误的示范，此例子无法在客户端正常渲染，因为 &lt;list&gt; 子组件是 &lt;div&gt;： &lt;template&gt; &lt;list class=\"list\"&gt; &lt;div class=\"row\" repeat=\"item in rows\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 特性 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 体验一下 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 示例&lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下 约束 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<refresh>","path":"cn/v-0.10/references/components/refresh.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/refresh.html","text":"&lt;refresh&gt;v0.6.1+ &lt;refresh&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供下拉加载功能。用法与特性与 &lt;loading&gt; 类似，&lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 一个简单例子： &lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;refresh onpullingdown='onpullingdown' onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"i in staffs\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;i.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onrefresh:function(e)&#123; this.refreshDisplay='show'; this.staffs=[&#123;name:'anna'&#125;,&#123;name:'baos'&#125;,&#123;name:'connon'&#125;,&#123;name:'inns'&#125;]; this.refreshDisplay='hide' &#125;, onpullingdown:function(e)&#123; console.log('onpullingdown triggered.'); console.log('dy:'+e.dy); console.log('headerHeight:'+e.headerHeight); console.log('maxHeight:'+e.maxHeight); &#125; &#125; &#125;&lt;/script&gt; 体验一下 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，&lt;loading&gt; 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 refresh： 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发。 pullingdown：仅在 Android 支持。当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发，可以从事件的参数对象中获取 dy，headerHeight，maxHeight 约束 &lt;refresh&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，refresh 事件仍会被触发。 如果需要 &lt;refresh&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 refresh 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"1000\"&gt; &lt;refresh onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text id=\"refreshText\"&gt;&#123;&#123;refreshText&#125;&#125;&lt;/text&gt; &lt;/refresh&gt; &lt;div repeat=\"v in items\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text id=\"loadingText\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh', items: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 30; i++) &#123; this.items.push(&#123; 'item': 'test data' + i &#125;); &#125; &#125;, methods: &#123; onrefresh: function () &#123; var vm = this; vm.refreshDisplay = 'show' if (vm.items.length &gt; 50) &#123; vm.refreshText = \"no more data!\" vm.refreshDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.unshift(&#123; 'item': 'test data ' + i &#125;); &#125; vm.refreshDisplay = 'hide' &#125;, onloading: function () &#123; var vm = this; vm.loadingDisplay = 'show' if (vm.items.length &gt; 30) &#123; vm.loadingText = \"no more data!\" vm.loadingDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.push(&#123; 'item': 'test data ' + i &#125;); &#125; vm.loadingDisplay = 'hide' &#125;, onloadmore: function () &#123; console.log(\"into--[onloadmore]\") &#125; &#125; &#125;&lt;/script&gt; 体验一下 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<loading>","path":"cn/v-0.10/references/components/loading.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/loading.html","text":"&lt;loading&gt;v0.6.1+ &lt;loading&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供上拉加载功能。用法与特性与 &lt;refresh&gt; 类似， 是 &lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loading：加载时被触发。 约束 &lt;loading&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 如果需要 &lt;loading&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 loading 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/loading&gt; &lt;cell class=\"row\" repeat=\"i in staffs\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;i.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onloading:function(e)&#123; console.log('onloading...'); this.staffs.push(&#123;name:'onloading'&#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<scroller>","path":"cn/v-0.10/references/components/scroller.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 一个简单例子： &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"v in items\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; items: [], triggered: false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123; 'item': 'test data' + i &#125;); &#125; &#125;, methods: &#123; onloadmore: function () &#123; if (!this.triggered) &#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123; 'item': 'onloadmore triggered' + i &#125;); &#125; &#125; this.triggered = true; &#125; &#125; &#125;&lt;/script&gt; 体验一下 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性 show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 示例&lt;template&gt; &lt;scroller&gt; &lt;div class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下 约束不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例 &lt;style&gt;.item &#123; padding: 20; height: 220; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.item-content &#123; flex-direction: row; width: 710; background-color: #ffffff;&#125;.item-imgbox &#123; height: 180; width: 180; margin-right: 20;&#125;.item-img &#123; width: 180; height: 180;&#125;.item-info &#123; height: 180; width: 510; justify-content: center; position: relative;&#125;.item-info-detail &#123; position: relative; color: #A2A2A2;&#125;.desc &#123; lines: 4; text-overflow: ellipsis; font-size: 26; line-height: 30; color: #A2A2A2;&#125;.title &#123; lines: 1; text-overflow: ellipsis; font-size: 32; color: #2D2D2D; line-height: 40;&#125;.detail-info &#123; margin-top: 15;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;scroller&gt; &lt;div class=\"item\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item-content\"&gt; &lt;div class=\"item-imgbox\"&gt; &lt;img class=\"item-img\" src=\"&#123;&#123;item.img&#125;&#125;\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;div class=\"item-info-detail\"&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;div class=\"detail-info\"&gt; &lt;text class=\"desc\"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') || &#123;&#125; module.exports = &#123; data: &#123; items: [&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;] &#125;, created: function () &#123; &#125;, methods: &#123; goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<slider>","path":"cn/v-0.10/references/components/slider.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/slider.html","text":"&lt;slider&gt;&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性 auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<switch>","path":"cn/v-0.10/references/components/switch.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ &lt;switch&gt; 是 Weex 的内置组件，用来创建与 iOS 一致样式的按钮。例如，在 iPhone 中的设置应用中的飞行模式按钮就是一个 switch 按钮。 子组件&lt;switch&gt; 组件不支持任何子组件。 特性 checked {boolean}：默认值为 false，表明按钮是否开启 is on or not. disabled {boolean}：默认值为 false，表明是否激活按钮 样式值得注意的是，在这个组件上，有些样式组件属性不能使用，它们是： width height min-width min-height margin padding border 注意： 由于设计宽度为 750px，宽度和高度相关的属性不能配置，组件的尺寸限定在 100x60。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;muted:&lt;/text&gt; &lt;switch checked=\"true\" onclick='onclick' onchange='onchange' ondisappear='ondisappear' onappear='onappear'&gt;&lt;/switch&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; methods:&#123; onclick:function(e)&#123; console.log('onclick:' + e.timestamp); &#125;, onchange:function(e)&#123; console.log('onchage, value:' + e.value); &#125;, ondisappear:function(e)&#123; console.log('ondisappear, value:' + e.value); &#125;, onappear:function(e)&#123; console.log('onappear, value:' + e.value); &#125;, &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<text>","path":"cn/v-0.10/references/components/text.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/text.html","text":"&lt;text&gt;&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 子组件此组件不支持子组件。 特性 value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式 lines {number}: 指定文本行数。默认值是 0 代表不限制行数。 text styles: 查看 文本样式 支持 color 样式. 支持 font-size 样式. iOS默认值：32，Android：不同设备不同，H5 默认值：32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 。line-height 在 iOS 中与 H5 和 Android 中不同， 文本值将放置在框的底部。 不支持 flex-direction, justify-content, align-items 这些为子节点设置的属性，并且&lt;text&gt;没有子节点。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 &lt;template&gt; &lt;div&gt; &lt;text&gt; 测试1，直接放置头尾用空白的文本 &lt;/text&gt; &lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; msg: ' 测试2，使用数据绑定 ' &#125;&#125;&lt;/script&gt; 体验一下 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;this is text content&lt;/text&gt; &lt;text value=\"this is text value\"&gt;&lt;/text&gt; &lt;text id=\"textid\" onclick=&#123;&#123;showtext&#125;&#125;&gt;this is gettext content&lt;/text&gt; &lt;text value=\"&#123;&#123;text&#125;&#125;\"&gt;&lt;/text&gt; &lt;text style=\"lines: 3;\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text &#123; font-size: 24; text-decoration: underline; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; price1: '99.99', price2: '88.88', text:'' &#125;, methods: &#123; showtext: function(event) &#123; var textComponent = this.$el(\"textid\"); this.text = textComponent.attr.value; &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<textarea>","path":"cn/v-0.10/references/components/textarea.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件textarea 组件不支持子组件。 特性 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：表示是否在页面加载时控件自动获得输入焦点。 rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式 text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;textarea class=\"textarea\" autofocus=\"true\" placeholder=\"...\" value=\"我是一个多行版本的input组件\"&gt; &lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .textarea &#123; margin: 20; border-width: 2; border-style: solid; border-color: #efefef; border-radius: 5; &#125;&lt;/style&gt; 体验一下","type":"references"},{"title":"<video>","path":"cn/v-0.10/references/components/video.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/video.html","text":"&lt;video&gt;v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件 &lt;text&gt; 是唯一合法的子组件。 特性 src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;Big Eater!&lt;/text&gt; &lt;video class=\"video\" onstart=\"onstart\" onpause=\"onpause\" onfinish=\"onfinish\" onfail=\"onfail\" auto-play=\"false\" play-status=\"pause\" src=\"&#123;&#123;src&#125;&#125;\" style=\"width:750;height:500;\"&gt;&lt;/video&gt; &lt;text&gt;state: &#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports =&#123; data: &#123; msg: '', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125;, methods:&#123; onstart:function(e)&#123; this.msg = 'onstart' &#125;, onpause:function(e)&#123; this.msg = 'onpause' &#125;, onfinish:function(e)&#123; this.msg = 'onfinish' &#125;, onfail:function(e)&#123; this.msg = 'onfinish' &#125;, &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<web>","path":"cn/v-0.10/references/components/web.html","permalink":"https://weex.apache.org/cn/v-0.10/references/components/web.html","text":"&lt;web&gt;v0.5+ 使用 &lt;web&gt; 组件在 Weex 页面中嵌入一张网页内容。src 属性用来指定资源地址。你也可以使用 webview module 来控制 web 的行为，比如前进、后退和重载。可以在这里查看 webview module。 子组件不支持子组件。 特性 src {string}：此特性指定嵌入的 web 页面 url。 样式 通用样式：不支持部分盒模型样式，支持列表如下： width 组件的宽度，默认值是0。这个样式定义必须指定数值。 height 组件的高度，默认值是0。这个样式定义必须指定数值。 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 pagestart: &lt;web&gt; 组件开始加载时发送此事件消息。 pagefinish: &lt;web&gt; 组件完成加载时发送此事件消息。 error: \b如果 &lt;web&gt; 组件加载出现错误，会发送此事件消息。 通用事件 支持以下通用事件： appear disappear 查看 通用事件 注意： 不支持 click 事件。 示例我们用一个简易浏览器示例，来展示如何使用 &lt;web&gt; 组件和 webview module。 查看 webview module。 &lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"input url\" onchange=\"change\" oninput=\"input\" class=\"textStyle\" value=\"https://www.baidu.com\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;text class=\"buttonSytle\" onclick=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"buttonSytle\" onclick=\"backforward\"&gt;Backward&lt;/text&gt; &lt;text class=\"buttonSytle\" onclick=\"forward\"&gt;Forward&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color:#778899 ; &#125; .textStyle &#123; width: 750; height: 50; background-color: #D3D3D3; font-size: 30; &#125; .buttonSytle &#123; width:200; height: 50; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; font-size: 30; &#125; .webStyle &#123; width: 750; height: 800; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview') module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", &#125;, methods: &#123; loadURL: function (e) &#123; var input = this.$el(\"urlInput\"); this.src = input.attr.value; &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"animation","path":"cn/v-0.10/references/modules/animation.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/animation.html","text":"animation 动画流畅且有意义的动画是一个十分有效的提升移动应用用户体验的手段，animation 模块被用于在组件上执行动画。动画可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 示例&lt;template&gt; &lt;div&gt; &lt;div id=\"test\" class=\"test\" onclick=\"run\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .test &#123; background-color: #6666ff; width: 200; height: 200; &#125;&lt;/style&gt;&lt;script&gt; var animation = require('@weex-module/animation') module.exports = &#123; methods: &#123; run: function () &#123; var testEl = this.$el('test') animation.transition(testEl, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(100px, 100px)' &#125;, duration: 0, //ms timingFunction: 'ease', 'transform-origin': 'center center', delay: 0 //ms &#125;, function () &#123; console.log('animation finished.') &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 APItransition(el, options, callback)example 参数 el {Element}：将要执行动画的元素，通常可以通过调用 this.$el(id) 来获取元素的引用。 options {Object}：描述动画过程的对象。 options.duration {number}：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 options.delay {number}：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 options.timingFunction {string}：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 示例 linear 动画从头到尾的速度是相同的 example ease-in 动画速度由慢到快 example ease-out 动画速度由快到慢 example ease-in-out 动画先加速到达中间点后减速到达终点 example cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. example options.styles {Object}：设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 示例 width 动画执行后应用到组件上的宽度值 length 无 example height 动画执行后应用到组件上的高度值 length 无 example backgroundColor 动画执行后应用到组件上的背景颜色 string none example opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 example transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center example transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 example transform属性的合法值: 名称 描述 值类型 默认值 示例 translate/translateX/translateY 指定元素将已被移动到的新位置 像素值或百分比 无 example rotate 指定元素将被旋转的角度，单位是度 number 无 example scale/scaleX/scaleY 按比例放大或缩小元素 number 无 example callback {Function}：动画执行完毕之后的回调","type":"references"},{"title":"clipboard","path":"cn/v-0.10/references/modules/clipboard.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/clipboard.html","text":"clipboard 剪切板v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。但是现在我们可以通过简单的调用 clipboard.getString() 接口来获取短信内容了。 示例&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;hello &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"setContent\"&gt;click me to set: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var clipboard = require('@weex-module/clipboard'); module.exports =&#123; data:&#123; tobecopied:'yay!', message:\"nothing.\" &#125;, methods:&#123; setContent:function(e)&#123; clipboard.setString(this.tobecopied); &#125;, onItemClick:function(e)&#123; this.message='clicked! '; clipboard.getString(function(ret) &#123; this.message = 'text from clipboard:'+ ret; &#125;.bind(this)); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text &#123; width: 750; height: 90; &#125;&lt;/style&gt; 体验一下 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 APIgetString(callback)从系统粘贴板读取内容。 参数 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 示例var clipboard = require('@weex-module/clipboard');clipboard.getString(function(ret) &#123; console.log(\"text from clipboard： \" + ret.data);&#125;); setString(text)将一段文本复制到剪切板，相当于手动复制文本。 参数 text {string}：要复制到剪切板的字符串。 示例var clipboard = require('@weex-module/clipboard');clipboard.setString(\"SomeStringHere\");","type":"references"},{"title":"dom","path":"cn/v-0.10/references/modules/dom.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/dom.html","text":"dom包含如下可以更新 dom 树的 dom API。 这部分API是通过把 virtual-dom 的消息发送到 native 渲染器来做到的。 开发者在日常开发中，唯一可在 .we 文件中使用的是 scrollToElement。你也可以调用 $scrollTo 方法来使用它 这个页面提及的其他的 API，只在 callNative 进程中的 native 渲染器用。（关于 callNative 进程的进一步介绍，可以在 How it works中的 JS Framework 部分看到 ） APIscrollToElement(node, options)让页面滚动到那个对应的节点，这个API只能在 &lt;scroller&gt; 和 &lt;list&gt; 组件中用。 这个API也能通过调用VM的方法 $scrollTo 来使用（已弃用） 要在你的 .we 文件中使用这个 API，可以使用 require(&#39;@weex-module/dom&#39;).scrollToElement。 参数 node {Node}：你要滚动到的那个节点 options {Object}：如下选项 offset {number}：一个到其可见位置的偏移距离，默认是 0 示例&lt;template&gt; &lt;scroller&gt; &lt;div class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 其他dom 还有一些底层接口用于创建 Weex 实例时调用，比如 createBody、updateAttrs 等，但并未开放供外部使用。","type":"references"},{"title":"globalEvent","path":"cn/v-0.10/references/modules/globalevent.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/globalevent.html","text":"全局事件0.8 (开发中) globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 AndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)注册全局事件。 参数 eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例var globalEvent = require('@weex-module/globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)取消事件监听。 参数 eventName {string}：需要取消的事件名称。 示例var globalEvent = require('@weex-module/globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"modal","path":"cn/v-0.10/references/modules/modal.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/modal.html","text":"modal 模态modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 APItoast(options)toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数 options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） 示例&lt;template&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Toast&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); modal.toast(&#123; 'message': 'I am a toast', 'duration': 3 &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 alert(options, callback)警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数 options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Alert&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.alert(&#123; 'message': 'I am alert message', 'okTitle': 'YES' &#125;, function (result) &#123; self.params = String(result) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 confirm(options, callback)确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数 options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Confirm&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.confirm(&#123; 'message': 'I have read and accept the terms.', 'okTitle': 'YES', 'cancelTitle': 'NO' &#125;, function (e) &#123; self.params = String(e) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 prompt(options, callback)提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数 options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下 result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Prompt&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.prompt(&#123; 'message': 'I am a prompt', 'okTitle': 'YES', 'cancelTitle': 'NO' &#125;, function (e) &#123; self.params = JSON.stringify(e) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"navigator","path":"cn/v-0.10/references/modules/navigator.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/navigator.html","text":"navigator 导航控制v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 示例&lt;template&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;click me! &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = require('@weex-module/navigator') var nextUrl = 'http://dotwe.org/raw/dist/6cd1703a45d7b2752cf05303069ce881.js' module.exports =&#123; data:&#123; message:'' &#125;, methods:&#123; onItemClick:function(e)&#123; var params = &#123;'url':nextUrl,'animated':'true'&#125; navigator.push(params, function(e) &#123; console.log('i am the callback.') &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text&#123; width: 750; height: 90; &#125;&lt;/style&gt; 体验一下 APIpush(options, callback)把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数 options {Object}：选项参数 url {stirng}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 示例var navigator = require('@weex-module/navigator')var params = &#123; url: 'navigator-demo.js', animated: 'true'&#125;navigator.push(params, function () &#123; // callback&#125;) pop(options, callback)把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数 options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 示例var navigator = require('@weex-module/navigator')var params = &#123; animated: 'true'&#125;navigator.pop(params, function () &#123; // callback&#125;) 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题","type":"references"},{"title":"storage","path":"cn/v-0.10/references/modules/storage.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/storage.html","text":"storage 本地存储v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 这里，我们简单模拟“搜索”记录的场景。在搜索的时候写入，然后读取出来展示成列表。 &lt;template&gt; &lt;div style=\"background-color:#F6F6F6;\"&gt; &lt;div class=\"search_view\"&gt; &lt;input class=\"search\" placeholder=\"Please input\" onchange=\"change\"/&gt; &lt;text class=\"btn\" onclick=\"search\"&gt;Search&lt;/text&gt; &lt;/div&gt; &lt;text class=\"item\"&gt;History&lt;/text&gt; &lt;list&gt; &lt;cell repeat=\"(i, v) in items\"&gt; &lt;text class=\"item\"&gt;&#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .search_view&#123; height:70; margin-top:20; margin-left:10; margin-right:10; flex-direction:row; &#125; .search&#123; height:70; border-width:1; border-color:#dddddd; padding-left:10; font-size:28; flex:1; &#125; .btn&#123; width:80; text-align:center; justify-content:center; font-size:28; background-color:#1A89EA; color:#ffffff; &#125; .item&#123; text-align:center; font-size:25; height:50; margin-top:10; color:#5E5E5E; border-bottom-width:1; border-bottom-color:#dddddd; justify-content:center; &#125;&lt;/style&gt;&lt;script&gt; var storage = require('@weex-module/storage'); module.exports = &#123; data: &#123; items: [], keywords:'' &#125;, created: function()&#123; var that = this; storage.getAllKeys(function(e) &#123; if(e.result == 'success' &amp;&amp; e.data.length)&#123; e.data.forEach(function(item)&#123; if(item.indexOf('search_') &gt; -1)&#123; that.items.push(item.split('search_')[1]); &#125; &#125;); &#125; &#125;); &#125;, methods:&#123; search: function()&#123; var that = this; if(!this.keywords) return; storage.setItem('search_' + this.keywords, this.keywords, function(e) &#123; that.items.push(that.keywords);22 &#125;); &#125;, change: function(e)&#123; if(!e.value) return; this.keywords = e.value; &#125; &#125; &#125;;&lt;/script&gt; 体验一下 这里，逐一解释下上面的代码。input 组件监听了 change 事件，可以保存用户输入的搜索关键字。如果用户点击了搜索按钮，则将关键字存储到 storage。这里，使用了 search_ 作为 storage key 的前缀。因此，我们在页面加载时，在 created 生命周期中可以先使用 storage.getAllKeys 获取所有的 key。如果 key 包含了 search_，则说明是搜索记录。因此，将该记录压入数组 items 中，于是界面就会展示出搜索记录的列表。 APIstorage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数 key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 示例var storage = require('@weex-module/storage')storage.setItem('bar', 'bar-value', function (e) &#123; e.result e.data&#125;) 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)传入键名返回对应的键值 参数 key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined 示例var storage = require('@weex-module/storage')storage.getItem('foo', function (e) &#123; e.data&#125;); removeItem(key, callback)传入一个键名将会删除本地存储中对应的键值 参数 key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 示例var storage = require('@weex-module/storage')storage.removeItem('foo', function (e) &#123; e.result e.data&#125;) length(callback)返回本地存储的数据中所有存储项数量的整数 参数 callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 示例var storage = require('@weex-module/storage')storage.length(function (e) &#123; e.result e.data&#125;) getAllKeys(callback)返回一个包含全部已存储项键名的数组 参数 callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例var storage = require('@weex-module/storage')storage.getAllKeys(function (e) &#123; e.result e.data&#125;) 其它参考 W3school: html5 localStorage storage 模块完整的 Demo","type":"references"},{"title":"stream","path":"cn/v-0.10/references/modules/stream.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/stream.html","text":"stream概述以下为 stream 相关的 API，用于实现网络请求。 APIfetch(options, callback[,progressCallback])发起网络请求 参数 options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：请求类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"webview","path":"cn/v-0.10/references/modules/webview.html","permalink":"https://weex.apache.org/cn/v-0.10/references/modules/webview.html","text":"webview一系列的 &lt;web&gt; 组件操作接口。 比如 goBack、goForward、和 reload。webview module 与 &lt;web&gt; 组件共用。 示例查看 简单浏览器 ，一个结合 &lt;web&gt; 组件和 webview module 的示例。 APIgoBack(webElement)加载历史记录里的前一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.goBack(webElement) goForward(webElement)加载历史记录里的下一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.goForward(webElement) reload(webElement)刷新当前页面。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.reload(webElement.ref) 注意事项：未来 &lt;web&gt; 组件的 Element 对象将会支持直接这些方法，届时 webview module 将不再需要","type":"references"},{"title":"JS Framework APIs (英)","path":"cn/v-0.10/references/specs/js-framework-apis.html","permalink":"https://weex.apache.org/cn/v-0.10/references/specs/js-framework-apis.html","text":"JS Framework APIsIntro about JS RuntimeThese APIs are designed for JS Framework and Native Engine working together. Considering the limitation of mobile phone resource, Weex runs only one JS runtime to handle all Weex instances. So it need a multi-instance management layer in JavaScript. These JS Framework APIs are just designed to do the management job. First, each Weex instance have a lifecycle, from createInstance to destroyInstance. During this period, we can import some extra data by refreshInstance. To communicate with Native Engine, we have a couple of APIs: sendTasks and receiveTasks. They are used to call each other by some commands and messages. And when JS runtime start at the beginning of the app launching, we need something initialized and configured. So we supply some APIs like registerComponents, registerModules. The last API is just for debugging, we supply an API named getRoot to return the whole virtual-DOM data for developers. If any of these API calls failed, an Error object should be returned. Called by native and supplied from JS FrameworkcreateInstance(instanceId, code, options, data)Create a Weex instance from Native Engine instanceId: The unique id for a Weex instance, generated by Native Engine. code: The JS bundle code send from Native Engine. It will be executed by new Function(code) in JS Framework. The code format depends on JS Bundle Foramt options: Optional. An options object. Currently it supports debug flag which enable printing log and bundleUrl flag which the url of bundle. data: Optional. It’s an chance to supply external data instead of the original data in JS bundle. Example: createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')createInstance('x', '...', &#123; bundleUrl, debug, ... &#125;, &#123; a: 1, b: 2 &#125;&#125;) destroyInstance(instanceId)Destroy an existed Weex instance by id from Native Engine refreshInstance(instanceId, data)Refresh data to an existed Weex instance with certain external data from Native Engine Example: refreshInstance('x', &#123;a: 100, b: 200&#125;) registerComponents(components)Register all native components components: A array of whose items are component options that are force part to use. Currently it supports append attribute which forces the appending mechanism (tree or node) when first time rendering. Example: registerComponents([ &#123; type: 'container' &#125;, &#123; type: 'text' &#125;, &#123; type: 'image' &#125;, &#123; type: 'slider', append: 'tree' &#125;, &#123; type: 'list' &#125;, &#123; type: 'cell', append: 'tree' &#125;, ...]) registerModules(modules)Register the name, methods and args format of each module modules: A map that collects all native module definitions. Each module definition is an array which has several API definitions. Each API definition has a name string and an args array which contains a list of each parameter’s type. NOTE: the node type data will actually return its ref property. And the function type data will actually return a unique function id referring to it. Example: registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ], ...&#125;) receiveTasks(instanceId, tasks)Fire events or callbacks to an existed Weex instance from Native Engine tasks[]: A task list. Each task has a method=&quot;fireEvent|callback&quot; property and a list of args. In fireEvent method, the args is ref of the target, event type, event data and domChanges description in order. Note: if some event make virtual-DOM data changed (e.g. value changed in &lt;input&gt; or current index changed in &lt;slider&gt;), the changing of the target element will be passed as domChanges. In callback method, the args is funcId of a handler, data and ifKeepAlive which describes whether this callback handler should be keeping called. (Each callback handler is matched with a funcId when the original call happens.) Example: receiveTasks('x', [&#123;method: 'fireEvent', args: ['x', '13', 'click', &#123;a: 100, b: 200&#125;]&#125;])receiveTasks('x', [&#123;method: 'callback', args: ['x', '7', &#123;a: 100, b: 200&#125;, true]&#125;]) getRoot(instanceId)Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging Example: getRoot('x')// &#123;ref: '_root', type: 'container', attr: &#123;...&#125;, style: &#123;...&#125;, children: [...]&#125; Called from JavaScript and implemented with native codesendTasks(instanceId, tasks)Make native calls from JS Framework tasks[]: A task list. Each task has a module name, a method name, and a args[] list. Example: sendTasks('x', [ &#123;module: 'dom', method: 'addElement', args: ['_root', &#123;ref: '1', type: 'container'&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '2', type: 'text', ...&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '3', type: 'image', ...&#125;, -1]&#125;, ...]) Supporting other JS Framework (experimental)Register a new JS Framework// lib/frameworks/index.jsimport Vue from '...'import React from '...'import Angular from '...'export const frameworks = &#123; Vue, React, Angular&#125; Expose JS Framework APIs// 3rd-party-framework.jsexport function createInstance (id, code, config, data) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; The virtual-DOM tasks should follow virtual-DOM spec. Framework HelperYou can import lib/runtime/helper.js to get two important things: Document class, see virtual-DOM spec for more. sendTasks method. JS Bundle formatYou must ensure the JS Bundle has its first line of code like this: // &#123; \"framework\": \"Vue\" &#125;... to allow JS Runtime to detect which JS Framework it should be opened by. If no valid annotation found. The JS Bundle will be opened by default JS Framework of Weex.","type":"references"},{"title":"Virtual DOM APIs","path":"cn/v-0.10/references/specs/virtual-dom-apis.html","permalink":"https://weex.apache.org/cn/v-0.10/references/specs/virtual-dom-apis.html","text":"Virtual DOM APIsDocument每个实例有一个与实例 id 对应的 document。Document 具有组成一个节点树的多个节点。 构造函数new Document(id: string, url: string?)成员createElement(tagName: string, props: Object?): Element创建一个特定类型 Element 对象。props 对象可能包含一个 attr 对象和一个 style 对象。例如 createBody(&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}}) createComment(text: string): Comment创建一个具有一些注释文本的 Comment 对象。 open()初始化渲染开始时设置一个标志，表示初始化渲染开始，每个 DOM 更新将被立即调用。 close()初始化渲染完成时设置一个标志，标识初始化渲染完成，DOM 更新以后将在每个任务中批处理。 fireEvent(el: Element, type: string, e: Object?, domChanges: Object?)在某个元素上触发一个带有特定类型的事件，这个事件带有一个事件对象。当事件导致一些 DOM 的变化，第四个参数将像 createElement 方法里的 props 参数一样描述这些 DOM 变化。 只读属性 &amp; Gettersid: stringURL: string?body: Elementbody 元素 documentElement: Elementdocument 元素 getRef(ref: string): Node?通过内部 node map 的 ref 获取节点。 注意： 在一个 document 被创建时会自动生成一个 documentElement ，并且 body 应该手动创建并添加到 documentElement 才能工作。body 的 type 必须是一个 div，list 或 scroller。 Node构造函数new Node()成员destroy()只读属性 &amp; Gettersref: stringnextSibling: Node?previousSibling: Node?parentNode: Node?Element extends Node构造函数new Element(type: string, props: Object?, ownerDocument: Document)创建一个元素，并且 props 对象可能包含一个 attr 对象和一个 style 对象。 成员DOM 树appendChild(node: Node)insertBefore(node: Node, before: Node?)insertAfter(node: Node, after: Node?)removeChild(node: Node, preserved: boolean?)移除一个子节点。preserved 参数表示是否立即销毁删除该节点或保存它。 clear()DOM propssetAttr(key: string, value: string, silent: boolean?)如果 silent 为 true，也不会调用 native。用于有 virtual-DOM 变化的事件处理。 setStyle(key: string, value: string, silent: boolean?)silent 参数作用与 setAttr 中的一样。 setClassStyle(classStyle: Object)class 样式的 CSS 优先级低于内联样式，当两种样式风格出现时，内联样式的值会覆盖 class 样式的值。 addEvent(type: string, handler: Function)removeEvent(type: string)fireEvent(type: string, e: any)只读属性 &amp; GetterstoJSON(): Object格式化 {ref: string, type: string, attr: Object, style: Object, event: Array(string), children: Array} Comment extends NodeComment 将不被传给渲染引擎。因此，可作为占位符使用。 构造函数new Comment(value: string)成员只读属性 &amp; Getterstype: string返回 &#39;comment&#39; value: string","type":"references"},{"title":"<wxc-navpage>","path":"cn/v-0.10/references/wxc/wxc-navpage.html","permalink":"https://weex.apache.org/cn/v-0.10/references/wxc/wxc-navpage.html","text":"&lt;wxc-navpage&gt; (v0.5+)&lt;wxc-navpage&gt; 组件是一个包含 navbar 的容器组件，可以根据业务场景定制 navbar 组件。同时，可以使用 navigator 模块控制页面的跳转，具体参考 navigator module。一般情况，都是配合 navbar 组件使用。如果不了解 navigator 相关知识，建议先了解下 iOS 或者 Android 的相关组件。在 H5 上，其实是相当于导航栏。 用法：在 script 标签中通过一个 require 语句引入，即：require(&#39;weex-components&#39;); 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-navpage tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-navpage&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); // more&lt;/script&gt; 在 require(&#39;weex-components&#39;); 之前 ，需要在工程目录下执行以下命令： npm install weex-components 子组件&lt;wxc-navpage&gt; 组件支持任意 Weex 组件。 特性&lt;wxc-navpage&gt; 组件的特性其实是对 navbar 进行功能设置，如下图所示，是 navbar 的一个简单示意。 height {number}：navbar 的高度，默认是 88。 background-color {color}：navbar 的背景颜色，默认是白色。 title {string}：navbar 的标题。 title-color {color}：navbar 标题的颜色，默认黑色。 left-item-title {string}：navbar 左侧按钮的标题。 left-item-color {color}：navbar 左侧按钮标题颜色，默认黑色。 right-item-title {string}：navbar 右侧按钮标题。 right-item-color {color}：navbar 右侧按钮标题颜色，默认黑色。 left-item-src {string}：navbar 左侧按钮的图标。 right-item-src {string}：navbar 右侧按钮的图标。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件&lt;wxc-navpage&gt; 组件支持左右两项点击事件。 naviBar.leftItem.click: 当 navbar 的左侧按钮被点击时触发事件，需要在 created 时期注册事件。 naviBar.rightItem.click: 当 navbar 的右侧按钮被点击时触发事件，需要在 created 时期注册事件。 示例： &lt;template&gt; &lt;wxc-navpage height=&#123;&#123;...&#125;&#125; background-color=\"...\" title=\"...\" title-color=\"...\" left-item-title=\"...\" left-item-color=\"...\" right-item-src=\"...\"&gt; &lt;content&gt; ...&lt;/content&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; created: function() &#123; this.$on('naviBar.rightItem.click',function(e)&#123; //handle your click event here. &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; //handle your click event here. &#125;); &#125; &#125;&lt;/script&gt; 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例注意： dotwe 平台暂不支持 wxc-xxx 类型的组件。 &lt;template&gt; &lt;wxc-navpage data-role=\"none\" height=&#123;&#123;navBarHeight&#125;&#125; background-color=\"#ff5898\" title=&#123;&#123;title&#125;&#125; title-color=\"white\" left-item-title=\"More\" left-item-color=\"white\" right-item-src=\"http://gtms02.alicdn.com/tps/i2/TB1ED7iMpXXXXXEXXXXWA_BHXXX-48-48.png\"&gt; &lt;wxc-panel title=\"push a new page\"&gt; &lt;wxc-button type=\"primary\" size=\"small\" value=\"push\" onclick=\"push\"&gt;&lt;/wxc-button&gt; &lt;/wxc-panel&gt; &lt;wxc-panel title=\"pop to the last page\"&gt; &lt;wxc-button type=\"success\" size=\"small\" value=\"pop\" onclick=\"pop\"&gt;&lt;/wxc-button&gt; &lt;/wxc-panel&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '', &#125;, created: function() &#123; this.$getConfig(function (config) &#123; var env = config.env; if(env.platform == 'iOS')&#123; var scale = env.scale; var deviceWidth = env.deviceWidth / scale; this.navBarHeight = 64.0 * 750.0 / deviceWidth; &#125; &#125;.bind(this)); this.$on('naviBar.rightItem.click',function(e)&#123; duration = 2; this.$call('modal', 'toast', &#123; 'message': 'naviBar.rightItem.click', 'duration': duration &#125;); &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; duration = 2; this.$call('modal', 'toast', &#123; 'message': 'naviBar.leftItem.click', 'duration': duration &#125;); &#125;); &#125;, methods: &#123; push: function() &#123; var vm = this; var params = &#123; 'url': 'http://dotwe.org/raw/dist/33dfcbe81979c60ba5de72c235d7d0f8.js', 'animated' : 'true', &#125; vm.$call('navigator','push',params, function () &#123;&#125;); &#125;, pop: function() &#123; var vm = this; var params = &#123; 'animated' : 'true', &#125; vm.$call('navigator','pop',params, function () &#123;&#125;); &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<wxc-tabbar>","path":"cn/v-0.10/references/wxc/wxc-tabbar.html","permalink":"https://weex.apache.org/cn/v-0.10/references/wxc/wxc-tabbar.html","text":"&lt;wxc-tabbar&gt;&lt;wxc-tabbar&gt; 是一个名为 weex-components 依赖库的自定义组件。&lt;wxc-tabbar&gt; 能在窗口的底部显示 tab 页面，我们可以在不同的 tab 页面之间切换。 用法：在 script 标签中通过一个 require 语句引入，即：require(&#39;weex-components&#39;); 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123;&#125;, methods: &#123; // more &#125; &#125;&lt;/script&gt; 在 require(&#39;weex-components&#39;); 之前 ，需要在工程目录下执行以下命令： npm install weex-components 子组件该组件不支持子组件。 特性 selected-index {number}：设置默认选中的 tab 索引，默认值为 0（第一个 tab）。 selected-color {color}：设置当标题被选中时标题的颜色，默认为红色。 unselected-color {color}：设置当标题不被选中时标题的颜色，默认为黑色。 tab-items {Array[Object]}：该属性接受一个 tabitems 对象数组, 分别对应到对应的 tab 页面，tab 页面的顺序跟对象数组的位置对应。我们可以通过设置每一项的属性来配置 tabbar 的外观： index {integer}：必填属性，指明了 tabitem 的次序。 title {string}：设置 tabitem 的标题，非必填，当标题为空时，标题将不会被显示 titleColor {color}：设置 tabitem 的标题颜色，默认是黑色 image {string}：当 tab 页面不被选中时显示的 icon，当不提供时，什么也不显示。 selectedImage {string}：设置 tab 页面被选中时显示的图片，不提供图片时，什么也不显示。 src {string}：设置 tab 对应的 Weex 页面的 url，为 http 开头。 visibility {string}：值为 visible | hidden，该属性指明了 tab 页面的显示状态，默认值是 visible 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 tabBar.onClick：当 tab 页面被选中时触发，需要在 ready 或者 create 生命周期中注册，如： 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items=\"&#123;&#123;tabItems&#125;&#125;\"&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; // ... &#125;, created: function() &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var detail= e.detail; console.log('tabBar.onClick ' + detail.index); &#125;); &#125;, methods: &#123; &#125; &#125;&lt;/script&gt; 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 示例注意： dotwe 平台暂不支持 wxc-xxx 类型的组件。 &lt;template&gt; &lt;div&gt; &lt;wxc-tabbar tab-items=\"&#123;&#123;tabItems&#125;&#125;\"&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; dir: 'examples', tabItems: [ &#123; index: 0, title: 'tab1', titleColor: '#000000', icon: '', image: 'http://gtms01.alicdn.com/tps/i1/TB1qw.hMpXXXXagXXXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms04.alicdn.com/tps/i4/TB16jjPMpXXXXazXVXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/ba202bcd277285c7f3cf79f9b1055dce.js?itemId=tab1', visibility: 'visible', &#125;, &#123; index: 1, title: 'tab2', titleColor: '#000000', icon: '', image: 'http://gtms03.alicdn.com/tps/i3/TB1LEn9MpXXXXaUXpXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms02.alicdn.com/tps/i2/TB1qysbMpXXXXcnXXXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/7e24b83c5868dbd4462e30549999245d.js?itemId=tab2', visibility: 'hidden', &#125;, &#123; index: 2, title: 'tab3', titleColor: '#000000', icon: '', image: 'http://gtms01.alicdn.com/tps/i1/TB1B0v5MpXXXXcvXpXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms04.alicdn.com/tps/i4/TB1NxY5MpXXXXcrXpXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/8a8b49b67084423e097a6b7f549f1453.js?itemId=tab3', visibility: 'hidden', &#125; ], &#125;, created: function() &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var detail= e.detail; console.log('tabBar.onClick ' + detail.index); &#125;); &#125;, methods: &#123;&#125; &#125;&lt;/script&gt;","type":"references"}],"posts":[{"title":"Hello World","path":"en/hello-world/","link":"","permalink":"https://weex.apache.org/en/hello-world/","text":"Hello world","type":"blog"},{"title":"test","path":"en/test/","link":"","permalink":"https://weex.apache.org/en/test/","text":"testasdfadfasdfasdfadfadsfasdfasdfadsfadsfadsfadsf sdfasdfasdfsdfsdfsdf","type":"blog"},{"title":"Weex ❤️ iOS 11 系列之一：Core ML 初探","path":"en/coreml/","link":"","permalink":"https://weex.apache.org/en/coreml/","text":"背景WWDC 2017 有一个非常明确的信号：端上机器学习将会是未来苹果的一个重要发力点，同时开发者的使用门槛在不断降低。 Core ML 是今年 WWDC 上苹果发布的机器学习框架。它允许开发者在自己开发的 app 上使用机器学习，同时不需要收集用户数据。 有了 Core ML，你可以将自己训练得到的模型，借助苹果提供的转换工具，转化成 Core ML 类型的模型文件，你可以非常轻松地直接实现模型和 app 数据的互通。 WWDC 上展示了一张简单的架构图： 最底层的 Accelerate 和 MPS，其实是苹果去年推出的接口，前者可以直接调用 CPU，后者则直接调用 GPU。 Core ML 会自行决定到底使用 CPU 还是 GPU 来进行运算，可以最大程度地利用硬件资源来处理模型数据。 而 Core ML 往上一层则是应用层。Vision 主要负责图像相关的人工智能处理，如人脸识别、面部追踪、文字识别等等；NLP 则提供语义分析相关 API。这部分内容在以前版本的 SDK 中也存在，这次被集成到了新框架当中。好处在于，开发者拥有了更大的自由度。在以前，开发者的 app 调用这些高级接口，对底层的实现细节的掌控力度非常小。现在，你可以通过自定义底层所使用的机器学习模型，从而实现更个性化的需求。 Weex-MLWeex 交互视觉能力小结中提到，Weex 最大的特别之处在于其 native 的能力， 我们要最大化利用 native 的特性， 而不是去模仿它。 作为本次 iOS 11 的一个重要 native 能力，我也第一时间尝试将 Core ML 透传到了 Weex 上。所有代码和 Demo 都已开源到 Github，后续也会将机器学习相关的Weex 模块统一放到 Weex Market 上。 得益于 Core ML API 的简洁，在 Weex 上使用 Core ML 相关能力变得非常简单: let imageRecognition = weex.requireModule('imageRecognition')imageRecognition.predictWithImage(this.$refs.image.ref, (results)=&gt;&#123; this.results = results.slice(0,5);&#125;) 通过调用透传的 module imageRecognition , 并传入 image 组件的 ref 作为参数，就可以实现图片识别的功能，最后提取出识别结果中 confidence 最高的 5 个结果。 DemoimageRecognition 使用 Inceptionv3 作为模型，能够高效识别， 该模型已经在 keras 中被训练好并通过苹果提供的工具转换成 mlmodel 文件， 只需拖拽的方式就可以集成到 iOS 开发环境中， 上述 demo 输出了对一张图片分类最大可能的5个预测结果， 对于 Weex 来说，几行代码就能搞定。 digitDetect 上述 demo 首先使用 weex-gcanvas 插件做了一个简单的绘制板，然后使用 MNIST model 完成了对手写数字的识别。 faceDetect 这个 demo 没有加载任何 model，使用了 iOS 11 内置的 Vision Framework，顾名思义，Vision 可以让开发者运行计算机视觉相关的任务，它相当于 Core ML 的 High-Level Solution， 它可以做很多事情: 脸部识别，会返回一个矩形数组来表示每一个脸部 脸部更精细识别，比如眼睛和鼻子的具体位置、头部的形状等，上述 demo 就是拿到这些信息以后使用 gcanvas 绘制出了面部精细轮廓 图片中的矩形探测 图片中的文字探测 二维码/条形码探测 视频中跟踪移动的物体 总结这次 Core ML 的推出，同时得益于苹果对软硬件的全面掌控，使得从系统级到第三方开发者，都具备了在端上就可以进行机器学习模型处理的能力。所有代码和 Demo 都已上传到 Github，欢迎贡献和交流。 当然在实际研究过程中，也发现了 Core ML \u0005的一些限制： 无法在端上进行模型的训练，所有模型必须提前训练好再转换成 Core ML 的格式 无法动态下载和更新模型，对于需要经常重新训练的模型不太友好 目前看只支持监督学习的模型，不支持非监督学习。 Weex 未来在提供更多功能透传的同时，也会继续探索更深层次的结合。 最后，本文是 Weex 和 iOS 11 结合系列的第一篇文章，后续将会有更多有意思的iOS 11 feature (如 ARKit、 drag &amp; drop 等) 和大家一起探讨。","type":"blog"},{"title":"hello","path":"cn/hello/","link":"","permalink":"https://weex.apache.org/cn/hello/","text":"","type":"blog"}]}