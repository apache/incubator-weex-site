{"meta":{"title":"Weex","subtitle":null,"description":"A framework for building Mobile cross-platform UIs. Different from a \"web app\", \"HTML5 app\", or \"hybrid app\", you can use Weex to build a real mobile app. The code that you write is relatively simple, because you can build native applications just using HTML, CSS, Javascript. But underneath, the core of the application is Objective-C or Java. At the same time, Weex will provide a lot of native components or modules for developers to use.","author":"Jinjiang","url":"https://weex.apache.org"},"pages":[{"title":"Bug Report Guidelines","path":"bug-report-guidelines.html","permalink":"https://weex.apache.org/bug-report-guidelines.html","text":"Bug Report Guidelines#This document describes how to write a good Weex bug report. Good bug reports help developers to classify the priority and severity of a bug properly, which helps the bug get fixed as soon as possible. The more specific information you provide, the better your bug gets understood. Bug Report General Principles# Avoid duplicates: Search before you file a new one! Always test the latest available version before submitting a bug. One bug per report. State useful facts, not opinions or complaints. How to Write a Good Bug Report#A good bug report should include the following information: Title#The goal of title is to make the report searchable and uniquely identifiable. A bad example: List Crash A good Example: List Crashes when deleting a header Environment#Weex Version: Please identify the version of WeexSDK or Weex Playground or weex-toolkit you were using when the bug occurred Device environment: Please identify the device model, platform and OS version. e.g. , iPhone 6, iOS 10.3. Overview/Description#The overview or description of a bug report is to explain the bug in detail, including: Justifications of why this is a bug dotwe demo that can reproduce the bug Screenshots for visual bugs Stack traces for crash bugs Console logs or error messages which are relevant in the bug Steps to Reproduce#The aim to provide the reproducible steps is to enable developers to reproduce the bug in their own environment. Here’s an example: Step 1: Load the demo using Weex Playground Step 2: Scroll to the bottom of the list Step 3: Click the red button to delete a header Test Results#The test results, including Expected Result and Actual Result, will tell developers what’s wrong. Expected Result describes what should happen, and Actual Result describes what actually happens. Reference#This document is a modified version of [1]. [1] http://testthewebforward.org/docs/bugs.html","type":"community"},{"title":"How to Contribute","path":"contributing.html","permalink":"https://weex.apache.org/contributing.html","text":"How to Contribute#Apache Weex is an open source project that is under active development and we’re continuously working out to simplify contributing to Weex ecosystem. Developers can participate and contribute to the Apache Weex community by reporting bugs, contributing code, answering questions, joining in discussions and contributing to documentation. Bugs#You can use Weex directly through Getting Started tutorial. If you encounter any unexpected phenomena during your use, feel free to let us know by filing a bug report. Find Known Issues#We are using JIRA for tracking all the issues and updating whenever when have an internal fix in progress. Before filing a new task, try to confirm if it is already listed or if there is a fix in progress. Report New Issues#Open a JIRA Issue , click on the top red “Create” button (you may need to create a JIRA account if you haven’t registered). Bug Report Guidelines document provides some of the most useful information about writing a good bug report. The better your bug report is, the faster we can reproduce and fix it! Contribute Code#Apache Weex is an open source project and both, core team members and external contributors, send pull requests which go through the same review process. If you have already decided to start writing code in Weex, Congratulations! You’re up and running. You can contribute code by either fixing an existing bug or developing new features. In either case, we always encourage to create a JIRA ticket and ensure we are in agreement on your proposal. To help you get started, we’ve created a document with more details about development process. Please read Getting Started with Development Process. Ask or Answer Questions#For basic use problems and help, we suggest you ask questions on stackoverflow.com and mark them with weex tag. You can also view all Weex related issues and answer some of the questions if you can. This will also help you get familiar with basic concepts and common misunderstandings about Weex, which can be useful when contributing documentation or code. Join in Discussions#In Weex community, most discussions happen on the mailing list. Dev mailing list “dev@weex.incubator.apache.org“ is the place where Weex developers exchange ideas and discuss new features, new releases and the development process. Contributors and developers should subscribe to this list and follow it in order to keep up to date on what’s happening in Weex. (subscribe) (unsubscribe) (archives) Contribute Documentation#Documentation with good quality is a great help to developers. If there is a powerful API that is not easy to use, it becomes useless. So, we welcome any contributions to help Weex’s documents become precise and easy to read. To make changes to the document, you can edit the corresponding Markdown file at the weex-site repository and create a pull request. How to Become a Committer#Committers are core members of the community who can access the project’s repository and modify its code, documentation and web sites, as well as accept the contributions of other developers. There’s no exact criteria for becoming a committer, we are looking for contributors who are actively involved in community contributions and who have continued interest in Weex. If you are interested in becoming a Weex committer, contact any existing committer and we will help you go through the invitation process. License#By contributing to Weex, you agree that your contributions will be licensed under its Apache License, Version 2.0.","type":"community"},{"title":"Development Process","path":"development-process.html","permalink":"https://weex.apache.org/development-process.html","text":"Development Process#Contributions are always welcome, but it is very important to understand the development process to make contributing simpler. This document will help you understand how to contribute changes to the Weex source code. Below are the recommended steps. 1. Choose or Create a JIRA issue#Weex uses JIRA to track all types of code changes and not just bug fixes. A JIRA ticket should be used to describe what should be fixed or modified and the high-level approach of how it will be fixed. We use Github pull requests to manage the review and merge specific code changes. Pull Requests describe how to implement that change in the project’s source code. If you would like to create a new issue on JIRA, be sure to search the existing issues and see if someone has already reported the same. It helps in avoiding duplication. If your change may be controversial, you may want to create a discussion in the weex-dev mailing list. Every pull request should correspond to an issue in JIRA. 2. Develop Your Changes# Fork the Github repository at https://github.com/apache/incubator-weex. Clone the forked repository and create a new branch from master to push your commits to. Develop your feature or bug fix in your new branch. Make sure your code meets the style guidelines. Add the below mentioned copyright notice to the top of any new file(s) you’ve added. /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ Documentation and tests should be added or referenced if they need to be added or updated as part of the change. Make sure to test your changes thoroughly. Commit all the changes to your branch. Commit Guidelines must be followed for better understanding. 3. Create a Pull Request#Open a pull request against the master branch of apache/incubator-weex. Make sure following guidelines are considered when creating a pull request. There should be one pull request for one issue. The PR title should be of the form [WEEX-xxxx][COMPONENT] Summary where xxxx is the relevant JIRA number and COMPONENT is one of the mentioned PR categories (android, iOS, jsfm, web, doc, website, example, test, other). Summary can be same as JIRA’s title or can also be a more specific title describing the PR itself. If the pull request is still a work in progress but needs to be pushed to Github to facilitate review, then add [WIP] after the component. This also means that the PR is not ready to be merged. It is easier to review small pull requests and those are more likely to get merged. Prefer to split the PR if it includes changes for more than one thing. Code Style Guidelines#Objective-C# Tabs should be used for indentation. Please do not use spaces. * operator goes with the variable name (e.g. Type *variable;) For function definitions, place each brace on its own line. For all the other braces, place the open brace on the line preceding the code block and place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android# Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style. Commit Guidelines#Following template should be used to write commit descriptions. Summary of change, same as PR title: `[WEEX-xxxx][COMPONENT] Summary`Longer description of change addressing the following: Why the changeis made, Context if it is part of many other changes, Description of previous behavior and newly introduced differences, etc.Long lines should be wrapped to 80 columns for easier log message viewing in terminals.Bug: 123456 A short subject and a blank line after the subject are crucial. Use the bug number from the JIRA issue. Some good thoughts on how to write better git commit messages can be found here. License#By contributing to Weex, you agree that your contributions will be licensed under its Apache License, Version 2.0.","type":"community"},{"title":"","path":"examples.html","permalink":"https://weex.apache.org/examples.html","text":"","type":"examples"},{"title":"Resources","path":"resources.html","permalink":"https://weex.apache.org/resources.html","text":"About Weex Project# Weex Official Website (weex.apache.org). Mirror in Alibaba Cloud (weex-project.io), faster in China. Weex Project Incubation Status. Mailing List. Issues. Weex Contributing Guide A guidance document tells you how to be submitted by the person weex and how to participate in mailing discussions. Weex FAQ. Supported Front-end Frameworks# Rax Rax is a front-end framework with React-compatible APIs. Vue.js Vue.js is a progressive front-end framework for building user interfaces. Components and Modules# Weex Ui Weex Ui is a rich interaction, lightweight, high performance UI library. Weex Market A website that provides a quick porting of weex’s third-party component list, where you can find the weex components you need for integration. Tools# Online Playground A website provides weex code practice and preview, as well as a convenient sharing platform. Playground App You can preview weex on the Playground App and learning how to use weex on it. Weex Language support for Intellij A plugin supports Weex Language for Intellij. Community# SegmentFault (cn) StackOverflow Telegram Russian Community Group Gitter for weex-en Posts# Weex Articles(cn). Examples# Weex Vue Examples","type":"community"},{"title":"Who is Using Weex?","path":"who-is-using-weex.html","permalink":"https://weex.apache.org/who-is-using-weex.html","text":"","type":"community"},{"title":"","path":"cn/blog.html","permalink":"https://weex.apache.org/cn/blog.html","text":"","type":"blog"},{"title":"Bug 报告指南","path":"cn/bug-report-guidelines.html","permalink":"https://weex.apache.org/cn/bug-report-guidelines.html","text":"Bug 报告指南#该文档描述了如何编写一个好的 Weex bug 报告。好的 bug 报告帮助开发者决定一个 bug 的优先级和严重性，并且增加了 bug 被快速修复的可能性，你能提供的具体信息越多越好。 Bug 报告原则# 避免重复:在报 bug 前先搜索! 总是测试最新的可用版本。 每个报告只报一个 bug。 陈述有用的事实，而不是意见或抱怨。 如何编写一个好的 Bug 报告#一个好的 bug 报告应该包括以下信息: 标题#标题的目标是使 bug 能够被搜索并且唯一可识别。 一个坏的例子:List Crash 一个很好的例子:List Crashes when deleting a header 环境#Weex 版本: 请告知你在 bug 发生时使用的 WeexSDK 、Weex Playground 或 weex-toolkit 的版本 设备环境: 请告知你 bug 所发生的机型、平台和 OS 版本，例如：iPhone 6,iOS 10.3。 概述/描述#bug 报告的概述或描述是向开发者详细解释 bug，包括： 为什么这是一个 bug 可以重现 bug 的 dotwe 链接 在视觉上可感知的 bug， 可以提供截屏 对于 crash bug， 可以提供详细的堆栈 复现步骤#复现步骤的目标是帮助开发者在他自己的系统上重现 bug ，例如： 步骤1：使用 Weex playgroud 扫码打开上面提供的 dotwe 链接 步骤2：滚动到列表底部 步骤3：点击红色按钮删除头部组件 测试结果#测试结果，包括预期结果和实际结果，预期结果描述了应该发生的事情，实际结果描述了实际发生的事情，从而表明这是个 bug 。","type":"community"},{"title":"如何参与贡献","path":"cn/contributing.html","permalink":"https://weex.apache.org/cn/contributing.html","text":"如何参与贡献#Apache Weex 是一个活跃的开源项目，我们一直致力于简化贡献 Weex 生态的流程。开源社区的贡献方式包括但不限于可以报 bug，回答开源社区、邮件组中的问题, 参与讨论新 feature 的方案，纠正或者更改文档， 同时我们也很欢迎直接贡献代码来完善和丰富 Weex。 报 Bug#直接通过快速上手教程开始使用 Weex，如果在使用过程中遇到任何问题和不符合预期的现象，都可以通过写一个 bug 报告来反馈。 查找已知问题#目前我们使用 JIRA 来跟踪所有的 issue 和 feature，只要对已知问题有修复或者有新 feature 计划的时候，都会更新对应的 issue 或者 feature 状态。 在填写 issue 或者 feature 时候，可以翻阅下是否已经有对应的 issue 或者 feature 已经在跟踪中。 报告新 issue#打开 JIRA Issue ，点击最上方红色的 “Create” 按钮（如果还没有注册 JIRA 账号则需要先注册一下）， Bug 报告指南 文档提供了一些关于 Bug 报告中最有用的信息的细节提示。你的 Bug 报告写得越好，我们就能越快地重现和修复它！ 贡献代码# Weex 是一个开源的 Apache 社区项目，不管是核心团队或者外部开源社区的贡献者提交的 pull request 都需要通过同样的社区 code review 流程。 贡献代码可以通过修复已知的 bug 或者 开发新 feature，建议在贡献代码之前创建 JIRA issue(如果是修复 JIRA 中已经记录的 issue，可以直接使用该JIRA issue 的 ID)，我们写了一份关于研发流程的文档，在开始之前可以先阅读一下。 提问或者回答问题#对于使用上的问题，建议你在 stackoverflow.com 平台上提问， 记得用 weex 标签标记它们。 你也可以查看所有的 Weex相关问题，如果可以的话，尽可能帮助回答一些问题，这些问题常常是新手需要了解的基本概念和常见问题， 这也将帮助你更好地熟悉和使用 Weex 。 参与邮件组讨论#在 Weex 社区，大多数讨论都发生在邮件列表上。 dev 邮件组 “dev@weex.incubator.apache.org“ 是 Weex 开发人员交流和讨论新功能、新发布、开发流程的地方。 贡献者和开发者都应该订阅这个邮件组，以便了解到 Weex 项目所发生的事情以及表达自己的观点。 (订阅) (退订) (档案) 帮助提升文档质量#质量好的文档对开发者是极大的帮助。如果有一个功能强大的 API 但不易于使用，它就会变得毫无用处。所以， 我们欢迎任何贡献以帮助 Weex 的文档变得精确和易于阅读。 想要对文档进行更改，可以在 weex-site 仓库编辑对应的 Markdown 文件并创建一个 Pull Request. 如何成为 Committer#Apache committer 是社区的核心成员，他们可以访问项目的仓库，也可以自己修改代码、文档和网站，也可以接受其他开发者的贡献。 我们正在招募 committer，我们所寻找的是积极参与到社区贡献同时对 Weex 有持续兴趣的同学。如果你有兴趣成为一名 Weex committer，可以联系现有的 committer 或者直接联系 dev 邮件组，欢迎你的加入！ License# 默认你对 Weex 的贡献是基于 Apache License 2.0。","type":"community"},{"title":"开发流程","path":"cn/development-process.html","permalink":"https://weex.apache.org/cn/development-process.html","text":"开发流程#本文档描述了如何对 Weex 源代码进行更改和提交，以下是建议的步骤： 1. 选择或创建一个 JIRA issue单#目前 Weex 使用 JIRA Issue 来跟踪所有类型的代码更改，而不仅仅是 bug 修复，我们使用 Github Pull Request 来管理代码 review 和合并特定的代码更改。也就是说，JIRA用于描述什么是需要修复或更改的，Pull Request 用于描述这些修复和变更如何实现。 在创建新问题之前一定要先搜索问题，避免重复。如果你的更改可能需要和其他开发者进行讨论，你可以在 weex-dev 邮件列表中创建一个讨论。 每个 PR 都应该对应于 JIRA 中的一个 issue。 2. 编写代码# Fork 在 https://github.com/apache/incubator-weex 上的 Github 仓库 Clone 你 fork 出来的仓库，创建一个新的分支用于提交变更 编写需要开发的特性或 bug 修复代码，确保你的更改符合代码风格指南。 复制并粘贴下面的注释到你的新文件顶部: /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ 修改或添加该变更相关de的文档和测试。 提交符合 commit 指南 的 commit 到你的分支。 3. 创建一个 Pull Request#创建一个 pull request 并提交到 apache/incubator-weex 的 master 分支，确保它符合这些准则: 一个 Pull Request 只解决一个问题 PR标题应该是 [WEEX-xxxx][模块]标题，其中 xxxx 是相关的 JIRA 问题号，模块是 PR 的类别（android、iOS、jsfm、web、component、doc、website、test、other），标题可以是 JIRA 的标题，也可以是描述 PR 本身的更具体的标题。 如果该 PR 相关的工作还在进行中，还没有准备好被合并，但需要被推到 Github 上以方便查看，可以在模块后添加 [WIP] 标示。 代码风格指南#Objective-C# 用 tab 缩进而不是空格 * 操作符靠近变量名（如 Type *variable） 方法定义：大括号需要另起一行 其他大括号：开括号紧跟在代码后面，不另起一行，闭括号单独占一行 使用 #pragma marks 标记将方法分类 遵循 GitHub Objective-C Style Guide 中其他的代码风格指南 Java &amp; Android# 使用 Google Java Style 作为基本的 Java 代码风格指南 其他 android 相关代码需遵循 AOSP Code Style Commit 指南#使用下面的形式来写 commit 描述: Summary of change, same as PR title: `[WEEX-xxxx][COMPONENT] Summary`Longer description of change addressing as appropriate: why the changeis made,context if it is part of many changes, description of previous behavior andnewly introduced differences, etc.Long lines should be wrapped to 80 columns for easier log message viewing interminals.Bug: 123456 一个简短的主题紧跟一个空行再接着写 commit 的详细描述，Bug 这里使用的是来自 JIRA 的问题号。 在这里可以找到一些关于如何编写 commit message 的好方法。","type":"community"},{"title":"","path":"cn/examples.html","permalink":"https://weex.apache.org/cn/examples.html","text":"","type":"examples"},{"title":"资源","path":"cn/resources.html","permalink":"https://weex.apache.org/cn/resources.html","text":"关于 Weex 项目# Weex 官方网站 (weex.apache.org). Weex 官方网站 \b阿里云镜像 (weex-project.io) 加速中国用户访问 Weex 项目孵化状态. 邮件列表. Issues. Weex 贡献指南 让您了解如何为 Weex 贡献代码或参与邮件组讨论。 Weex FAQ. 前端框架支持# Rax Rax 是一个兼容 React API 的前端框架。 Vue.js Vue.js 是一个用于构建用户界面的渐进式前端框架。 组件和\b模块# Weex Ui Weex Ui 是一个富交互、轻量级、高性能的UI库。 Weex Market 一个提供 \bWeex 第三方组件的网站，您可以在这里找到你需要的 Weex 组件。 Tools# 在线 Playground 一个提供 Weex 代码实验和预览的网站，同时支持\b便捷的分享功能。 Playground 应用 您可以在 Playground 应用中预览 Weex，并且学习如何使用\b Weex。 Weex Language support for Intellij 一个为 Intellij 提供 Weex 语言支持的插件。 社区# SegmentFault StackOverflow Telegram Russian Community Group Gitter for weex-en 文章# Weex 相关文章. 例子# Weex Vue 实例","type":"community"},{"title":"谁在使用 Weex？","path":"cn/who-is-using-weex.html","permalink":"https://weex.apache.org/cn/who-is-using-weex.html","text":"","type":"community"},{"title":"Create a plugin","path":"guide/create-a-plugin.html","permalink":"https://weex.apache.org/guide/create-a-plugin.html","text":"Getting started Web Developing and testing with the playground app Extending Web functionality Android Developing and testing with the playground app Extending native functionality iOS Developing and testing with the playground app Extending native functionality Publishing a plugin to the cocapods repository Publish the plugin in the weex market How to use the plugin in another project Using weexpack: Manual integration: The weex plugin development kit is designed to help developers build weex plugins quickly and easily, allowing them to integrate native functionality without changing business code. The plugin abstracts a functionality and/or component to the rest of the app by including the specific implementation for each target platform (Web, Android and iOS) and exposing it through a common API. Getting started#Create a weex plugin with weexpack:weex plugin create weex-my-plugin This will create a project structure similar to this:├── android (Android native code project)│ └── ...├── ios (iOS native code project)│ └── ...├── js (html5 project)│ └── ...├── examples (sample app)│ └── index.vue├── playground (sample projects to test the plugin)│ ├── android│ ├── browser│ └── ios├── WeexMyPlugin.podspec (iOS .podspec)├── package.json├── README.md The examples directory contains a weex app that you can use to test your plugin. This test app will be loaded from the playground apps that are installed in the playground folder. Web#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:web Webpack will be listening for changes in examples/index.vue and re-build the example app for you. The app will be served in the port 12580 (e.g. http://localhost:12580). Edit the plugin JavaScript/HTML/CSS code under the js folder. Refresh the test app to update the plugin in the playground app. Extending Web functionality#See Extend Web Render. Android#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:native Webpack will be listening for changes in examples/index.vue and re-build the example app for you. Open the android project under playground/android with Android Studio. The native plugin code will be linked as a gradle dependency. You can develop and test the plugin directly from Android Studio. You can also use weex debug to debug the playground app. Extending native functionality#See Extend Android. iOS#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:native Webpack will be listening for changes in examples/index.vue and re-build the example app for you. Open the iOS playground app and install the dependencies: cd playground/iospod install Open WeexDemo.xcworkspace in Xcode. The native plugin code will be linked as cocoa pod. You can develop and test the plugin directly from Xcode. You can also use weex debug to debug the playground app. Extending native functionality#See Extend iOS. Publishing a plugin to the cocapods repository# Edit the *.podspec generated in the root of the plugin project. Check the correctness of the iOS plugin: pod spec lint --allow-warnings Publish to cocoapods repository: pod trunk push --allow-warnings Publish the plugin in the weex market#You can publish to the Weex Market with the simple command:weex plugin publish How to use the plugin in another project#Using weexpack:#weex plugin add weex-kdp Manual integration:#iOS:#pod &apos;WeexMyPlugin&apos; Android:#Add the following line to the dependencies list in the build.gradle file for the corresponding project.compile &apos;$&#123;groupId&#125;:weexkdp:&#123;$version&#125;&apos; Note: You need to specify the groupId and $version of the project. Web integration#npm install weexkdp","type":"guide"},{"title":"Extend Android","path":"guide/extend-android.html","permalink":"https://weex.apache.org/guide/extend-android.html","text":"Module extend Javascript callback Component extend Extend Component Method Extend adapter ImagedownloadAdapter Proguard Rules Weex supports module-extend、component-extend and adapter-extend. Module extend# Customize modules class must extend from WXModule. Extended method must add @JSMethod (uiThread = false or true) annotation, which determines whether the method is run on UI thread. The access level of method must be public. Do not obfuscate code using tools like ProGuard. Extended method suppport the data type of int, double, float, String, Map, List as its param. Register the module: WXSDKEngine.registerModule(&quot;MyModule&quot;, MyModule.class);or else may report an error: ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;xxx&#39; . Refer to the following example: public class MyModule extends WXModule&#123; //run ui thread @JSMethod (uiThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; //run JS thread @JSMethod (uiThread = false) public void fireEventSyncCall()&#123; //implement your module logic here &#125;&#125; Register the module WXSDKEngine.registerModule(\"MyModule\", MyModule.class); Use this module in weex DSLNow event moudle is avaiable in weex, use the module like this: &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;testMyModule&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('MyModule').printLog(\"I am a weex Module!\"); &#125; &#125; &#125;&lt;/script&gt; Javascript callback#If the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @WXModuleAnnopublic void openURL(String url,JSCallback callback)&#123; //implement your module logic here Map&lt;String,Object&gt; resp = new HashMap(); resp.put(\"result\",\"ok\"); callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extend# Customize components must extend from WXComponent Use the @WXComponentProp(name = value(value is attr or style)) annotation to let the update of attribute or style be recognized automatically. The access levels of method must be public Customize can not be obfuscated by tools like ProGuard Component method with the annotation of @JSMethod can Weex params can be int, double, float, String, Map, List, Array Register your Component by WXSDKEngine.registerComponent Refer to the following example public class RichText extends WXComponent&lt;TextView&gt; &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) &#123; super(instance, dom, parent); &#125; @Override protected TextView initComponentHostView(@NonNull Context context) &#123; TextView textView = new TextView(context); textView.setTextSize(22); textView.setTextColor(Color.BLACK); return textView; &#125; @WXComponentProp(name = \"tel\") public void setTel(String telNumber) &#123; getHostView().setText(\"tel: \" + telNumber); &#125;&#125; Register your Component： WXSDKEngine.registerComponent(\"richText\", RichText.class); Use this component in weex DSL： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/richText&gt; &lt;/div&gt;&lt;/template&gt; Extend Component Method# WeexSDK (0.9.5+) support the component method that can be invoked for example： @JSMethodpublic void focus()&#123; //method implementation&#125; after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt; Extend adapter#ImagedownloadAdapter#Weex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examplepublic class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; Proguard Rules#If you want to using proguard to protect your source code, please add the following rules to your profile: -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;-keep class com.taobao.weex.bridge.**&#123;*;&#125;-keep class com.taobao.weex.dom.**&#123;*;&#125;-keep class com.taobao.weex.adapter.**&#123;*;&#125;-keep class com.taobao.weex.common.**&#123;*;&#125;-keep class * implements com.taobao.weex.IWXObject&#123;*;&#125;-keep class com.taobao.weex.ui.**&#123;*;&#125;-keep class com.taobao.weex.ui.component.**&#123;*;&#125;-keep class com.taobao.weex.utils.**&#123; public &lt;fields&gt;; public &lt;methods&gt;; &#125;-keep class com.taobao.weex.view.**&#123;*;&#125;-keep class com.taobao.weex.module.**&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep class * implements com.taobao.weex.ui.IExternalComponentGetter&#123;*;&#125;","type":"guide"},{"title":"Extend JS framework","path":"guide/extend-js-framework.html","permalink":"https://weex.apache.org/guide/extend-js-framework.html","text":"Extend JS framework Weex JS engine features support Adapt to Weex’s initial entry and multi-instance management mechanism Framework initialization Register available native components and modules Multi - instance lifecycle management Native communication Configure the JS Framework in WeexSDK Prepare your JS Framework code Register a JS Framework Extend JS framework#This part of the extension of JS framework is still in the discussion, may be adjusted at any time, please pay attention. Weex wants to be able to respect as many developer development habits as possible.So, in addition to Weex official support Vue 2.0, the developer can also customize and horizontally extension their own or their favorite JS Framework.The steps to customize the JS Framework are as follows: First you have a complete set of JS Framework. Learn about Weex’s JS engine feature support. Adapting Weex’s native DOM APIs. Adapting Weex’s initialization portal and multi-instance management mechanism. Add your own JS Framework to the framework configuration of the Weex JS runtime. Then pack it. Build JS bundles based on the JS Framework. You need to add a specific prefix comment so that the Weex JS runtime can recognize it. Weex JS engine features support# Under iOS, Weex uses the JavaScriptCore that comes with the system, so the ES support depends on the version of the operating system.The current conservative judgments, ES5 features on the market mainstream iOS devices are perfectly supported, but some of the features of ES6 + is not supported. Under Android, Weex uses the v8 kernel provided by UC. For performance and stability considerations, we are not using the latest version of the v8 kernel.The same conservative judgment, the ES5 feature can all support, including strict mode Object.freeze and so on. The Weex JS engine does not support HTML DOM APIs and HTML5 JS APIs, including document, setTimeout`, and so on. We added Promise‘s polyfill, as well as the console‘s polyfill. In addition, in order to ensure that the JS engine can manage memory as much as possible, we have a generic global object for the Object.freeze () freeze operation, which includes: Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype Adapt to Weex’s initial entry and multi-instance management mechanism#The JS Framework provided by the developer needs to be packaged as a CommonJS package, and the package needs to be extension to the following methods: Framework initialization# init(config) config Document Element Comment TaskSender CallbackManager This method places the Native DOM class and two auxiliary classes provided by Weex in the config parameter and allows the framework itself to be initialized. Tip: At the same time, the author can pass in a different config in the framework of the initialization time. This allows for framework testing or environmental simulation. Introduction to parameter format# TaskSender: wip… CallbackManager: wip… Register available native components and modules# registerComponents(components) registerModules(modules) These two methods are called immediately after the frame is initialized. This framework will be able to know which components and modules the current client supports. Introduction to parameter format# components: Array: Describe the array of components, each of which includes: type: string: Component name, for example div。 methods: string[]: Optional, a list of method names supported by this component. These methods can follow the native DOM APIs call. modules: Object: Describe the hash table of a series of modules. Key is the module name, the value is an array. The elements of the array describe a method in the module. The information of the method includes: name: string: Method name args: string[]: Parameter number and type description E.g: registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) Multi - instance lifecycle management# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) Each Weex page has two stages: created and destroyed. At the same time in the Weex page running process, native can send messages to the Weex page. Different frameworks can follow their own ideas to achieve the message. Introduction to parameter format# instanceId: string: The unique id of the Weex page is generated by native. code: string:The Wex page’s JS bundle’s code is passed through native. config: Object?: The configuration information for the Wex page, such as the bundleUrl representing the bundle address, is generated by the native configuration. It has nothing to do with the contents of the JS bundle itself. data: Object?: Native can import an external data when creating a Weex page. The JS framework can also generate different page content for the same JS bundle with different data. env: Object?:The current environment information about the Weex page, the meaning of each field: info: Object: Framework information, see the “JS Bundle format requirements” later. config: Object:Equivalent to the third parameter of the method config callbacks: CallbackManager: only CallbackManagerinstance of Weex page. created: number:The number of seconds that the Wex page was created. framework: string:The name of the framework used by the Wex page. Equivalent to info.framework. Native communication# receiveTasks(instanceId, tasks) Native can use the refreshInstance method to send a message to the JS framework layer. But in many cases will use receiveTasks to send user events or methods callback to the JS framework. For example, if the user clicks on a button, native will send a fireEvent type of task to the JS framework, and then the JS framework will handle the corresponding event logic. This part of the working mechanism is related to the design of the addEvent in the native DOM interface. Another example is the user using fetch to send network requests. When the request is done at the native end, it will be sent to the JS framework with a callback type of task. Since native can not pass the function in JavaScript, it actually only sends a callbackId to the JS framework. This part of the working mechanism is related to the design of CallbackManager. Auxiliary method# getRoot(instanceId): JSON This method returns the full JSON description of the document body node. Developers can view the full native DOM tree as a result. The format of the specific return value is the same as the return method of the toJSON () method in the native DOM interface. This feature is used extensively as a developer tool extension. Configure the JS Framework in WeexSDK#Prepare your JS Framework code#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; Register a JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; And then packaged JS runtime, integrated into WeexSDK. JS Bundle format requirements#Framework infoThe note(alias framework info) at the beginning of the JS Bundle file is very important. The format is as follows: // &#123; \"framework\": \"Vue\" &#125; So that the Weex JS engine will know that the JS bundle needs to use the Vue framework to resolve.Similarly, Weex supports multiple frameworks.It will be based on js bundle notes to select the corresponding framework resolution.","type":"guide"},{"title":"Extend iOS","path":"guide/extend-ios.html","permalink":"https://weex.apache.org/guide/extend-ios.html","text":"extend custom module extend custom component Component Method custom your handlers NOTICE: All of the exported APIs in Weex are controllable and safe, they can not access private APIs or do any system hacks at runtime, neither can they change the primary purpose of the Application. If you are extending your custom modules/components, be sure NOT to export the ability of Objective-C runtime, be sure NOT to export dynamic and uncontrolled methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), be sure NOT to export any private methods. Weex SDK provides only rendering capabilities, rather than have other capabilities. There are some internal components, modules and handlers. If you want these features which weexSDK doesn’t provide, you can to extend. The following section we will extend iOS using Objective-C and here is swift. extend custom module# To extend your custom weex modules in iOS, you must make your class conform to WXModuleProtocol protocol, and then exports your method to javaScript using macro WX_EXPORT_METHOD,finally register your module with your class and a self-define module name. basicwe will custom a module to print params that javaScript give. new a class derived from NSObject conforming WXModuleProtocol protocol add your module method and then exports using macro WX_EXPORT_METHOD register module after WeexSDK’s initialization by far, we’ve finished a basic custom module, and you may understand how to custom a weex module in iOS using Objective-C. We can use it in javaScript code like this: weex.requireModule(\"event\").showParams(\"hello Weex) advanced extendibility you must understand more in WXModuleProtocol protocol, we’ll talk more about blueprint methods and properties in this protocol. weexInstanceThe instance of WXSDKInstance holds the references of all modules created in a single page. if you add @synthesize weexInstance in your module class, your module will hold a reference to the instance of WXSDKInstance who create and initialize your module, or you get nothing. You can get more details by weexInstance such as pageName. targetExecuteThreadWe will schedule your module method to main thread(UI thread), we highly recommend that you can not do much works here, if must, you can add implementation for this method. You can provide a thread so that we can schedule to. WXModuleKeepAliveCallbackSometimes you can return your result to your caller, callback is important in this scene,the params for callback can be string or dictionary. You must specify a second params to keep your callback function id in js after used. We’ll create a new function id every time callback, NO will be a better choice for memory. WX_EXPORT_METHOD_SYNC This feature only works on WeexSDK 0.10 and later. Synchronous method only works in JavaScript thread, you cannot do much works here.exports asynchronous method using WX_EXPORT_METHOD, you may get result in callback function.WX_EXPORT_METHOD_SYNC to export synchronous method. You can get result on the left of operand =. extend custom component# new a class derived from WXComponent classif we do nothing in this class and then register to WeexSDK engine, its functionality is just like div. override the lifecycle of WXComponent loadViewWe will load a view for a component default, if you didn’t override this method, supperclass will provide a WXView derived from UIView. If we want to load html or just to show a map, override loadView and provide a custom view is a good choice. - (UIView *)loadView &#123; return [MKMapView new];&#125; viewDidLoadIf you want to make some configurations for your custom view like set delegate, you can finish here.You don’t need to set frame for your custom view if it doesn’t has any subview, weexSDK will set it’s frame according to style. - (void)viewDidLoad &#123; ((MKMapView*)self.view).delegate = self;&#125; register component [WXSDKEngine registerComponent:@&quot;map&quot; withClass:[WXMapComponent class]]; by far you can use your custom component in front-end &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt; Weex engine has done some works to support common events and other attributes, if you want support your own attributes, let’s continue. custom events for your componentOur target is that support mapLoaded event for the component we just implement, and then we can use in front-end directyly. The front-end code can be like this. &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\" @mapLoaded=\"onMapLoaded\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; onMapLoaded:function(e) &#123; console.log(\"map loaded\"+JSON.stringify(e)) &#125; &#125;&#125;&lt;/script&gt; we must save status for event added or not, so we add a BOOL member named mapLoaded for the component class to make it record, and when event map loaded, we can fire event according to this record. custom event override method add/remove event - (void)addEvent:(NSString *)eventName &#123; if ([eventName isEqualToString:@&quot;mapLoaded&quot;]) &#123; _mapLoaded = YES; &#125;&#125;- (void)removeEvent:(NSString *)eventName&#123; if ([eventName isEqualToString:@&quot;mapLoaded&quot;]) &#123; _mapLoaded = NO; &#125;&#125; fire event to front-endwe’ll fire mapLoaded event when map loaded finish according to our record. do not forget to set delegate for MKMapView. - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView &#123; if (_mapLoaded) &#123; [self fireEvent:@&quot;mapLoaded&quot; params:@&#123;@&quot;customKey&quot;:@&quot;customValue&quot;&#125; domChanges:nil] &#125;&#125; We have finish our custom event, so what about custom attributes? this is the same important as custom events. custom attributesThe next target is that we add a custom attribute showTraffic, we can display real time traffic or not according to this attribute. The front-end code can be like the following. &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\" showTraffic=\"true\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt; override component init method initWithRef...add a BOOL member showsTraffic to make the status whether front-end user use the attribute or not record. We can get all the attribute for this component by override init method of component. - (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if(self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; if (attributes[@&quot;showsTraffic&quot;]) &#123; _showsTraffic = [WXConvert BOOL: attributes[@&quot;showsTraffic&quot;]]; &#125; &#125; return self;&#125; set property for custom view. - (void)viewDidLoad &#123;((MKMapView*)self.view).showsTraffic = _showsTraffic;&#125; support attribute updates - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;showsTraffic&quot;]) &#123; _showsTraffic = [WXConvert BOOL: attributes[@&quot;showsTraffic&quot;]]; ((MKMapView*)self.view).showsTraffic = _showsTraffic; &#125;&#125; more life cycle for component A Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. | method | description | | :------------------: | ---------------------------------------- | | initWithRef:type:... | Initializes a new component using the specified properties. | | layoutDidFinish | Called when the component has just laid out. | | loadView | Creates the view that the component manages. | | viewWillLoad | Called before the load of component&apos;s view . | | viewDidLoad | Called after the component&apos;s view is loaded and set. | | viewWillUnload | Called just before releasing the component&apos;s view. | | viewDidUnload | Called when the component&apos;s view is released. | | updateStyles: | Called when component&apos;s style are updated. | | updateAttributes: | Called when component&apos;s attributes are updated. | | addEvent: | Called when adding an event to the component. | | removeEvent: | Called when removing an event frome the component. | Component Method#from WeexSDK 0.9.5, you can define your component method by macro WX_EXPORT_METHODfor example: @implementation WXMyComponent +WX_EXPORT_METHOD(@selector(focus)) +- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self; &#125; - (void)focus &#123; NSLog(@&quot;you got it&quot;); &#125;@end after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt; custom your handlers#We don’t provide functionality for downloading image but defines a blueprint of methods in WXImgLoaderProtocol for loading image, and image component get image content from these methods. You must implement methods in WXImgLoaderProtocol except the optional methods to display image from specified url.You can also define your own protocol and implement its handler. new a class derived from NSObject conforming WXImgLoaderProtocol and then add implementation for methods in WXImgLoaderProtocol. the flowing code may require SDWebImage as dependency, you can download remote url image by your own way without SDWebImage. @implementation WXImgLoaderDefaultImpl- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end register handlerregister handler by the method registerHandler:withProtocol in WXSDKEngine WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] use handleryou can use your handle in any native code including component, module and other handlers id&lt;WXImgLoaderProtocol&gt; imageLoader = [WXSDKEngine handlerForProtocol:@protocol(WXImgLoaderProtocol)];[iamgeLoader downloadImageWithURL:imageURl imageFrame:frame userInfo:customParam completed:^(UIImage *image, NSError *error, BOOL finished)&#123;&#125;];","type":"guide"},{"title":"Extend iOS with swift","path":"guide/extend-module-using-swift.html","permalink":"https://weex.apache.org/guide/extend-module-using-swift.html","text":"Swift In Weex#Swift and Objective-C mix-up a complete demo extend module using swift# As we export moudle method using macro and calling in runtime, so we can extend module using swift by extension bjective-C class. You can also finish extending module by write an category for swift class in Objective-C class. new WXSwiftTestModule.h/m and WXSwiftTestModule.swift file ，you will get a tip as follow during the creationchoose Create Bridging Header, as we need to access method in Objective-C in swift file, and the Bridging header can help us. And the format name of the header file is yourTarget-Bridging-Header.h, and mine is WeexDemo-Bridging-Header.h. implementation in WXSwiftTestModule.h/m WXSwiftTestModule.h #import &lt;Foundation/Foundation.h&gt;#import &lt;WeexSDK/WeexSDK.h&gt; @interface WXSwiftTestModule : NSObject &lt;WXModuleProtocol&gt; @end WXSwiftTestModule.m you can search WeexDemo-Swift.h after building your project, Xcode will generate this file for us. for simulator the file path may be: weex/ios/playground/DerivedData/WeexDemo/Build/Intermediates/WeexDemo.build/Debug-iphonesimulator/WeexDemo.build/DerivedSources/WeexDemo-Swift.h export method define in swift file. #import &quot;WXSwiftTestModule.h&quot;#import &quot;WeexDemo-Swift.h&quot; // you need to import the header to make Objective-C code recognize the method defined in swift file. @implementation WXSwiftTestModule#pragma clang diagnostic push //forbid unknow selector warrning#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; WX_EXPORT_METHOD(@selector(printSome:callback:)) //method name in Swift, you can get the final method name in `WeexDemo-Swift.h` as the convert of Xcode.#pragma clang diagnostic pop @end in Swiftmake an extension for Objective-C class WXSwiftTestModule, add a method, and then export it in Objective-C, then we can use it in javaScript. WXSwiftTestModule.swift import Foundationpublic extension WXSwiftTestModule &#123; public func printSome(someThing:String, callback:WXModuleCallback) &#123; print(someThing) callback(someThing) &#125;&#125; we need to expose WXSwiftTestModule WXModuleCallback in WeexDemo-Bridging-Header as our Objective-C need to access them WeexDemo-Bridging-Header.h //// Use this file to import your target&apos;s public headers that you would like to expose to Swift.//#import &quot;WXSwiftTestModule.h&quot;#import &quot;WeexSDK.h&quot; by far we have finished our module using swift. module usage# register module to WeexSDK [WXSDKEngine registerModule:@&quot;swifter&quot; withClass:[WXSwiftTestModule class]]; front-end usage &lt;template&gt; &lt;text&gt;Swift Module&lt;/text&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; ready: function() &#123; var swifter = weex.require(&apos;swifter&apos;); swifter.printSome(&quot;https://www.taobao.com&quot;,function(param)&#123; nativeLog(param); &#125;); &#125; &#125;;&lt;/script&gt;","type":"guide"},{"title":"Extend Web Renderer","path":"guide/extend-web-render.html","permalink":"https://weex.apache.org/guide/extend-web-render.html","text":"Extend Web components Extend Web renderer’s built-in components Example of extension for weex built-in components. Extend the Web module Register the module API format The example of register module Use the module Extend Web components#Vue.js is an independent front-end framework. In the browser, you can not use the Weex container for page rendering. So, the two things are the same: (1) for the Weex platform to expand Vue.js Web components. (2) directly using Vue.js to develop a Web component. The development of components can refer to its documentation: component. It is also recommended to use the .vue file to write components. How to use it: Single file component. Extend Web renderer’s built-in components#Weex itself offers a lot of built-in components and modules, but also has the ability to expand horizontally. It allows developers to expand and customize themselves. But it is important to note that Weex is a cross-platform solution. When extending its built-in components or modules, you need to implement it on the three ends (Android, iOS, Web). After Weex switches the kernel to Vue 2.x, it will be easier to extend the Vue component on the Web side. We current use weex-vue-render for Vue 2.x Web side rendering. Firstly import this library in your web page, then you can extend the render’s built-in components using weex.registerComponent or Vue.component. Basically these two methods are doing the same thing. Example of extension for weex built-in components.#To extend &lt;sidebar&gt; as an example, you should first write the logic of the component itself: &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; And then register the &lt;sidebar&gt; component globally before using it: import Vue from 'vue'import weex from 'weex-vue-render'import Sidebar from './path/to/sidebar.vue'weex.init(Vue)// register the `&lt;sidebar&gt;` component globallyweex.registerComponent('sidebar', Sidebar)// or:// Vue.component('sidebar', Sidebar) When you extend the Weex component, if you only use the built-in components provided by Weex and use the styles that Weex supports, it is no different from the normal custom component and does not need to be implemented at the Native side. If you find a component that does not support labels and styles that are not supported by Weex, you will need to really extend the Weex component. At the same time, you also need to extend in the Android side and the iOS side, or will lead to rendering exception. Extend the Web module#In addition to the common components, Weex also provides a common module, you can easily call the native API. In general, the registered Weex module requires three ends to be implemented, otherwise it will affect its normal use. Register the module#If we import the weex-vue-render library, we can get the weex variable globally. You can register the module using the registerModulemethod. API format# registerModule name: {String} Required, module name. define: {Object} Required, module definition. meta: {Object} Optional, module meta info. Basically you won’t need this except you want to pass a non iterable attribute or method from your module implementation object. In this case you should pass a { registerType: &#39;assignment&#39; } object to it. Otherwise only the iterables will be registered in the module. The example of register module#The following code registers a module called guide: weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) Use the module#Weex provides the require method for getting registered modules. You only need to pass the module name directly: //import moduleconst guide = weex.requireModule('guide')// use the methods of moduleguide.greeting()guide.farewell() The above wording is as useful as the native end, except that the methods in the module are provided by Native.","type":"guide"},{"title":"Front-End Frameworks","path":"guide/front-end-frameworks.html","permalink":"https://weex.apache.org/guide/front-end-frameworks.html","text":"Front-end Frameworks in Weex Vue.js Rax Front-end Frameworks in Weex#Front-end technologies seem flourishing and productive. Using front-end frameworks in production is a good way to write maintainable apps. However, Weex is not a front-end framework. Indeed, front-end frameworks are just the syntax layer or DSL (Domain-specific Language) of Weex, they are decoupled from native render engines. In another word, Weex does not rely on any specific front-end frameworks. With the evolution of the technology, Weex can integrate more widely used front-end frameworks as well. Currently, Weex mainly supports Vue.js and Rax, and those frameworks are already integrated into Weex SDK, you don’t need to require them manually. Learn some basics of Vue.js or Rax could be very helpful when you are using Weex. It is better to learn some basics of Vue.js or Rax before using Weex. Vue.js#Weex integrated the v2 version of Vue.js since WeexSDK v0.10.0 is released at 2017/02/17. Vue (pronounced /vjuː/, like view) is a progressive front-end framework for building user interfaces. Please refer to its official website for more information. Please refer to Use Vue.js on Weex document to learn more technics about Weex and Vue. Rax#Rax is a front-end framework with React-compatible APIs. Please refer to Rax’s official website to get more information.","type":"guide"},{"title":"Integrate Devtool to Android","path":"guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-android.html","text":"Integrate Devtool to Android Integrate to Android Installing Dependencies Adding Debug mode switch Example Known Issues Integrate Devtool to Android#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your Android App. Integrate to Android#Installing Dependencies#Weex Devtools depend on weex_inspector. I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. There are two choices to install it: From Gradle dependencies &#123; compile 'com.taobao.android:weex_inspector:0.13.2'&#125; From source code you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(':inspector')&#125; Version compatibility# weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 0.16.0+ 0.12.1 - 0.17.0+ 0.13.2 - Adding Debug mode switch#The key to control the opening and closing of the debug mode can be summarized as three rules: No.1: Set the switch and Debugger Server addresses via sRemoteDebugMode and sRemoteDebugProxyUrl. WXEnvironment class has a pair of static variables mark Weex current debug mode: public static boolean sRemoteDebugMode; // default closepublic static String sRemoteDebugProxyUrl; // Debugger Server addresses You have to set WXEnvironment.sRemoteDebugMode and WXEnvironment.sRemoteDebugProxyUrl at the right time, for example: private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; You can find detail and suitable way of initialize inspector in Playground. No.2: You must call WXSDKEngine.reload() method when sRemoteDebugMode was changed. You can control a state of debug mode via the WXEnvironment.sRemoteDebugMode, but you need reset Weex runtime if you changed a state of debug mode. private void initWXBridge(boolean remoteDebug) &#123; if (remoteDebug &amp;&amp; WXEnvironment.isApkDebugable()) &#123; WXEnvironment.sDebugServerConnectable = true; &#125; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(false); &#125; if (WXEnvironment.sDebugServerConnectable &amp;&amp; (WXEnvironment.isApkDebugable() || WXEnvironment.sForceEnableDevTool)) &#123; if (WXEnvironment.getApplication() != null) &#123; try &#123; Class clazz = Class.forName(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); if (clazz != null) &#123; Constructor constructor = clazz.getConstructor(Context.class, WXBridgeManager.class); if (constructor != null) &#123; mWxDebugProxy = (IWXDebugProxy) constructor.newInstance( WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(new WXJsFunctions()); &#125; &#125; &#125; &#125; catch (Throwable e) &#123; //Ignore, It will throw Exception on Release environment &#125; WXServiceManager.execAllCacheJsService(); &#125; else &#123; WXLogUtils.e(\"WXBridgeManager\", \"WXEnvironment.sApplication is null, skip init Inspector\"); WXLogUtils.w(\"WXBridgeManager\", new Throwable(\"WXEnvironment.sApplication is null when init Inspector\")); &#125; &#125; if (remoteDebug &amp;&amp; mWxDebugProxy != null) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; mWXBridge = new WXBridge(); &#125;&#125; In this way, You can control the debug mode flexibly. No.3: Auto refresh page via ACTION_DEBUG_INSTANCE_REFRESH broadcast ACTION_DEBUG_INSTANCE_REFRESH can be broadcast messages when the debug mode is switched or Chrome page refresh. You can use this mechanism to inform the current page to refresh in time. public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_INSTANCE_RELOAD.equals(intent.getAction()) || IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; Log.v(TAG, \"connect to debug server success\"); if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; String weexTpl = mUri.getQueryParameter(Constants.WEEX_TPL_KEY); String url = TextUtils.isEmpty(weexTpl) ? mUri.toString() : weexTpl; loadWXfromService(url); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; Example#The easiest way is reuse the code of playground. On the other hand QR code is not necessary, if you review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. There are two examples of how to open debug modes in the Playground App: Set the debug mode via XXXApplication public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; Set the debug mode by scan QR code You review the source code of playground. Debug mode switch control: WXApplication.java Refresh control WXPageActivity.java Known Issues#You can report issues and bugs here. We will reply as soon as possible.","type":"guide"},{"title":"Integrate Devtool to iOS","path":"guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-ios.html","text":"Guide Integrate Devtool to iOS Installing Dependencies Integrate Step 1. Add header file in AppDelegate.m Step 3. Auto refresh Usage with Debugger Server Envirenment Guide#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your iOS App. Integrate Devtool to iOS Integrate Devtool to iOS Integrate Devtool to iOS#Installing Dependencies#There are two choices to install dependencies: No.1 From cocoapods#source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.15.3&apos;, :configurations =&gt; [&apos;Debug&apos;]， I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. No.2 From source code# git clone git@github.com:weexteam/weex-devtool-iOS.git Copy source folder to your project. Choose options as the picture shows. Integrate#Step 1. Add header file in AppDelegate.m#//1. From cocoapods#import &lt;TBWXDevtool/WXDevtool.h&gt;//2. From source code#import &quot;WXDevtool.h&quot; ###Step 2. Initialize inspector when the APP launched You can see the WXDevtool header file as follows: + (void)setDebug:(BOOL)isDebug;+ (BOOL)isDebug;+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end Note: The inspector API must be called before weex is initialized setDebug setDebug is used to control the state of debug mode, when its value is YES, open the debug mode, otherwise closed. (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; open inspect model, remove the @selector (setDebug:) or add [WXDevTool setDebug:NO] eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; Step 3. Auto refresh#Q: Why do we need auto refresh feature? A: As shown in future, when you click the debugger button, Javascript runtime environment will change from the phone (JavaScriptCore) to PC (Chrome V8), then Weex need to re-initialize the Weex environment, re-render the page. Page rendering is required for the developer to add on its own page. Q: What kind of scene need to add refresh feature? Click debugger button Switch remoteDebug Refresh inspect page Q: How to add auto refresh feature? Register events when Weex initialization. [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; Notes: You must cancel this event in the dealloc method. For example: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; For example, First you can destroy the current instance, and then re-create instance: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; destroy instance，and reCreate new instance，example: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; You can see the details in this case WXDemoViewController.m Usage with Debugger Server#Envirenment#you need install Debugger Server npm install -g weex-toolkit``` launch DebugServer weex debug[《Get started》](../../guide/index.html)。then,browser will show a page with QR code，you can scan QR code to connect App and Server(PlayGround)## Partial function1. LogLevel - control weex log output level ![_](http://img.alicdn.com/tps/TB1F8WONXXXXXa_apXXXXXXXXXX-1706-674.png) LogLevel define Off = 0, Error = Error Warning = Error | Warning, Info = Warning | Info, Log = Log | Info, Debug = Log | Debug, All = NSUIntegerMax ` Vdom/Native tree choice picture 1 picture 2 Click native option on picture 1,then will show native tree and view property picture 3 picture 4 Click vdom on picture 3, show vdom tree and component property","type":"guide"},{"title":"Integrate to Your App","path":"guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/guide/integrate-to-your-app.html","text":"Integrate to Your App Integrate to Android Platform Quick Start Five Steps Integrated to iOS Step 1: Add Dependencies Step 2: Initialize the Weex environment Step 3: Render weex Instance Step 4: Destroy Weex Instance Integrate to Your App#Integrate to Android Platform#The following documents assume that you already have a certain Android development experience. Quick Start Five Steps#The keys to intergrating Weex into your Android application are the following five step: Configure Gradle dependency in build.gradle dependencies &#123; ... // weex sdk and fastjson compile 'com.taobao.android:weex_sdk:0.18.0@aar' compile 'com.alibaba:fastjson:1.1.46.android' //support library dependencies compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:support-v4:23.1.1' compile 'com.android.support:appcompat-v7:23.1.1'&#125; Add required permissions in your AndroidManifest.xml &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; Init Weex SDK When Application Create public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config = new InitConfig.Builder().setImgAdapter(new FrescoImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; Fresco ImageAdapter Picasso ImageAdapter Create an WXSDKInstance, add IWXRenderListener and activity lifecycle on it. load weex bundle url. when page load success; target view will be send for you on onViewCreated callback, set target view to activity contentView. public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = \"WXSample\"; String bundleUrl = \"http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx\"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Run app, start activity, then you will see hello world demo. well done. Hello World Demo Source Tip: Click QRCode Image in Demo Source Page, your will see compiled bundle js. Integrated to iOS#Through the CocoaPods or Carthage integrated Weex iOS SDK to your project.First assume that you have finished installing the iOS development environment and CocoaPods(or Carthage). Step 1: Add Dependencies#Import Weex iOS SDK to your existing project, if not, you can create a new project according to the tutorial).Before proceeding, make sure that the Podfile file is under the project file. If not, create one and open with text editor(if Carthage, please ensure the Cartfile in your project directory). You can choose one of Integration method. using CocoaPods WeexSDK The latest version on cocoaPods can be obtained here . Add the following to the Podfile file: source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.17.0&apos; ## latest Weex SDK recommendedend Open the command line, switch to the directory of the Podfile file, and run the pod install command. If there are no errors, it means that the environment has been configured. using Carthagehere you can get the latest version of WeexSDK.Add github &quot;apache/incubator-weex&quot; to CartfileOpen the command line, switch to the directory of the Cartfile, and run carthage update.Add Carthage build framework to your project Step 2: Initialize the Weex environment#In the AppDelegate.m file to do the initialization operation, usually in the didFinishLaunchingWithOptions method as follows to add. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk environment[WXSDKEngine initSDKEnvironment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level[WXLog setLogLevel: WXLogLevelAll]; Step 3: Render weex Instance#Weex supports both full page rendering and partial rendering. What you need to do is render Weex’s view with the specified URL and add it to its parent container. The parent container is generally a viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very important class that provides a basic method and some callbacks, such as renderWithURL, onCreate, onFailed, etc., can be found in WXSDKInstance.h. Step 4: Destroy Weex Instance#In the dealloc phase of the viewController destroyed Weex instance, can play a role in avoiding memory leaks. - (void)dealloc&#123; [_instance destroyInstance];&#125; Build your own WeexSDK.framework and Import to your project.#The Weex SDK can be compiled from the source code. You can try the latest feature in the new feature or bugfix branch. clone Weex projectyou can use SSH git clone git@github.com:apache/incubator-weex.git or use https git clone https://github.com/apache/incubator-weex.git open WeexSDK.xcodeproj in weex/ios/sdkswitch target just below Build this project or just use the xcode default hot key ⌘ + b Finally you can find Products directory in weex/ios/sdk, WeexSDK.framework was here Add js-framework(which is in the WeexSDK.framework and renamed to native-bundle-main.js) to your main bundle Import the framework you get above and import system framework add -ObjC to your project settings,just like this","type":"guide"},{"title":"Setup Develop Environment","path":"guide/set-up-env.html","permalink":"https://weex.apache.org/guide/set-up-env.html","text":"Setup Develop Environment Generate a new Weex project Usage Folder Structure Setup Develop Environment#Using dotWe is a good choice, but if you want to develop locally on your own machine, you will need to set up your develop environment. You will need Node.js and the Weex CLI. Install Node.js using nvm (Simple bash script to manage multiple active Node.js versions). Run the following commands in a terminal after installing nvm: $ nvm install 6.10.0$ nvm use 6.10.0 And npm comes with Node.js, with which you can install the Weex command line tools. NOTE: After upgrading the weex-toolkit to v1.0.8, the npm-shrinkwrap.json npm 5 specification has been added to lock the package dependencies, it is needed to upgrade your npm version to 5 above by command: npm install npm@latest -g if your version is lower than this, please check your npm version before using it. Run the following commands in a terminal: $ npm install -g weex-toolkit$ weex -v You can use ‘weex update @x.x.x’ to update weex-devtool, weex-previewer, weex-builder and weexpack to a specific version.weex update weex-devtool@latest // Here latest means to install the latest version NOTE: If you receive an error like permission error, check out where permission problems occur, please delete the corresponding file and reinstall or run the chmod -R 777 [path] command to authorize. Then you can use the Weex command to verify if the installation is successful: Generate a new Weex project#Use the command line tool to generate a Weex project called “awesome-project”. Run the following command in a terminal: $ weex create awesome-project Then enter the awesome-project folder, you will see a standard project skeleton has been generated. Usage#The weex-toolkit will prompt you whether to automatically run npm install, if not running, manually cd into the folder and run npm install. In the awesome-project folder, install dependencies with the following command: npm start It will open the preview server automaticly, if you just want to see the web site, you can visite /index.html, like localhost:8081/index.html. NOTE When the port number is occupied, the port number may change, please pay attention to the console output. Folder Structure#| —— configs | —— config.js global config of webpack | —— helper.js helper functions | —— logo.png | —— plugin.js script for compile plugins | —— utils.js tool functions | —— vue-loader.conf.js loader config of weex | —— webpack.common.conf.js webpack configuration for common environment | —— webpack.dev.conf.js webpack configuration for develop environment | —— webpack.prod.conf.js webpack configuration for production environment | —— webpack.test.conf.js webpack configuration for test environment| —— platforms | —— platforms.json platform meta data| —— plugins | —— plugins.json plugin data| —— src | —— entry.js the entry file of whole bundle | —— index.vue vue file source| —— test | —— unit | —— specs test scripts | —— index.js source code and config test environment | —— karma.conf.js configuration for karma| —— web static source| —— .babelrc configuration for babel-loader| —— android.config.json configuration for packing android project| —— ios.config.json configuration for packing ios project| —— npm-shrinkwrap.json npm dependence lock file| —— package.json| —— README.md| —— webpack.config.js entry file of the webpack command For more technical details, please continue to read the next section. And don’t forget to write and preview your codes at dotWe.","type":"guide"},{"title":"Use Vue.js on Weex","path":"guide/use-vue.html","permalink":"https://weex.apache.org/guide/use-vue.html","text":"Runtime-only Build Platform Differences Context DOM Styles Events The Web Renderer Single File Component Compile Targets Use weex-loader Supported Features Global Config Global API Options Lifecycle Hooks Instance Properties Instance Methods Directives Special Attributes Built-In Components Weex integrated the v2 version of Vue.js since WeexSDK v0.10.0 is released at 2016/02/17. Vue (pronounced /vjuː/, like view) is a progressive front-end framework for building user interfaces. Please refer to its official website for more information. If there is no special instructions, the “Vue.js” or “Vue” in this article all refers to the v2 version of Vue.js. Runtime-only Build#If you are familiar with Vue.js, you should know that there are two available builds of Vue.js: the Runtime + Compiler build and the Runtime-only build. The difference between them is whether to include the compiler which is able to compile the template option at runtime. Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, Weex is using the runtime-only build of Vue.js for better performance and less code size. Specifically, the differences are as follows: The template option is not supported when defining a component. Does not support using x-templates. Does not support using Vue.compile. Platform Differences#Vue.js was designed for the Web platform at the beginning. Although it can be based on Weex to develop native applications, there are still many platform differences between Weex and web. The key platform differences are context, DOM, styles and events. Context#Weex is mostly used to write multi-page applications, each page is a native View or Activity on mobile, and has its own context. In particular, the Vue instances are different in each pages, and even the “global” config of Vue (Vue.config.xxx) only affect the single page on Weex. On this basis, some SPA (single-page application) technologies of Vue, such as Vuex and vue-router will also take effect within the single page. More colloquially, the “page” concept is virtual in SPA technologies, but it is real on Weex. However, Vuex and vue-router are standalone libraries, they all have their own concept and usage scenario, you can still use Vuex and vue-router on Weex. DOM#Because there is no DOM (document object model) on Android and iOS, if you are manipulating and generating DOM elements manually, it may have some compatibility issues. It is a good practice to manipulate data and components instead of generated elements when you are using modern front-end frameworks. Some DOM-related features, such as v-html, vm.$el, template option, may not have the same behavior on different platforms. To be more specific, the type of vm.$el property is HTMLElement on the web, but it is not that type on mobile environments. Actually it’s a special data structure defined by Weex document object model. Styles#The style sheet and CSS rules in managed by Weex js framework and native render engines. It would be very difficult and unnecessary to implement the whole CSSOM spec and support all CSS rules. For performance reasons, Weex only support single class selector currently, and only support a subset of CSS Rules. Please refer to common styles and text styles for more details. On Weex, styles are scoped by force for each Vue component. Events#Event bubbling and capturing are not supported in Weex currently, therefore, event modifiers such as .prevent, .capture, .stop, .self are not supported on Weex native components. Moreover, the keyboard event modifiers and system modifier keys, such as .enter, .tab, .ctrl, .shift mostly are meaningless on mobile device, which are also not supported in Weex. The Web Renderer#If you want to render your page on the web, you need to require the weex-vue-render to achieve it. weex-vue-render is a web renderer for Vue DSL, it implemented the built-in components and built-in modules of Weex on the web. Please refer to its repo for more details. Single File Component#Single file component (as known as the *.vue files) of Vue is a special file format with a .vue extension. The template inside will be compiled into the render function at build time. Moreover, there are a good deals of syntax highlight plugins for all kind of editors. It’s a good practice to use single file component syntax in Weex. Compile Targets#Because of the platform difference and to improve the performance on the web, the *.vue file should be compiled in two different ways: For the web platform, you can compile source files in any official way, such as Webpack + vue-loader or Browserify + vueify. For Android and iOS platforms, you should use weex-loader to compile the *.vue files. Use different bundles for different platforms is to make good use of the platform original features and reduce compatibility code at build time. But the source code is still the same, the only difference is the way to compile it. Use weex-loader#weex-loader is a loader for webpack that can transform *.vue file into a plain javascript module for Android and iOS platform. All features and configurations of it are same with vue-loader. One thing should be noted that if the entry option of your Webpack config is a *.vue file, you also need to pass an additional entry parameter. const webpackConfig = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true' /* ... */ use: &#123; loaders: [&#123; // matches the .vue file path which contains the entry parameter test: /\\.vue(\\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;&#125; You don’t need to write those additional parameters if you are using .js file as entry file. It’s a good practice to using javascript file as the entry file of webpack config. &#123; entry: './path/to/entry.js'&#125; Supported Features#Global Config# The Vue “Global” config only affect the single page on Weex, the configuration will not be shared between different Weex pages. Vue Global Config Supported Notes Vue.config.silent Yes - Vue.config.optionMergeStrategies Yes - Vue.config.devtools No Only supported on the web. Vue.config.errorHandler Yes - Vue.config.warnHandler Yes - Vue.config.ignoredElements Yes Not Recommend. Vue.config.keyCodes No Useless on the mobile. Vue.config.performance No Same with devtools. Vue.config.productionTip Yes - Global API# Vue Global API Supported Notes Vue.extend Yes - Vue.nextTick Yes - Vue.set Yes - Vue.delete Yes - Vue.directive Yes - Vue.filter Yes - Vue.component Yes - Vue.use Yes - Vue.mixin Yes - Vue.version Yes - Vue.compile No Weex is using the runtime-only build. Options# Vue Option Supported Notes data Yes - props Yes - propsData Yes - computed Yes - methods Yes - watch Yes - el Yes The value of el is meaningless on the mobile. template No Weex is using the runtime-only build. render Yes Not Recommend. renderError Yes - directives Yes - filters Yes - components Yes - parent Yes Not Recommend. mixins Yes - extends Yes - provide/inject Yes Not Recommend. name Yes - delimiters Yes Not Recommend. functional Yes - model Yes - inheritAttrs Yes - comments No - Lifecycle Hooks#Instance lifecycle hooks of Vue components will be emitted at particular stages, refer to the lifecycle diagram of Vue component for more details. Vue Lifecycle Hook Supported Notes beforeCreate Yes - created Yes - beforeMount Yes - mounted Yes Not exactly the same with web, because there is no actually DOM in Weex. beforeUpdate Yes - updated Yes - activated No Not support &lt;keep-alive&gt; yet. deactivated No Not support &lt;keep-alive&gt; yet. beforeDestroy Yes - destroyed Yes - errorCaptured Yes New in Vue 2.5.0+, Weex SDK 0.18+ Instance Properties# Vue Instance Property Supported Notes vm.$data Yes - vm.$props Yes - vm.$el Yes The value is not HTMLElement on the mobile. vm.$options Yes - vm.$parent Yes - vm.$root Yes - vm.$children Yes - vm.$slots Yes - vm.$scopedSlots Yes - vm.$refs Yes - vm.$isServer Yes Always false. vm.$attrs Yes - vm.$listeners Yes - Instance Methods# Vue Instance Method Supported Notes vm.$watch() Yes - vm.$set() Yes - vm.$delete() Yes - vm.$on() Yes - vm.$once() Yes - vm.$off() Yes - vm.$emit() Yes - vm.$mount() No You don’t need to mount Vue instance manually. vm.$forceUpdate() Yes - vm.$nextTick() Yes - vm.$destroy() Yes - Directives# Vue Directive Supported Notes v-text Yes - v-html No No HTML parser in Weex, and it is not good practice. v-show No Not support display: none; yet. v-if Yes - v-else Yes - v-else-if Yes - v-for Yes - v-on Yes Not support event modifiers. v-bind Yes - v-model Yes - v-pre Yes - v-cloak No Only support single class selector. v-once Yes - Special Attributes# Vue Special Attribute Supported Notes key Yes - ref Yes - slot Yes - slot-scope Yes New in Vue 2.5.0+, Weex SDK 0.18+ scope Yes Not Recommend. is Yes - Built-In Components# Vue Built-In Component Supported Notes component Yes - transition No The concept of enter and leave maybe different on the mobile, and Weex does not support display: none; yet. transition-group No Same with transition. keep-alive No Native components on the mobile can not be cached at front-end. slot Yes -","type":"guide"},{"title":"BroadcastChannel","path":"references/broadcast-channel.html","permalink":"https://weex.apache.org/references/broadcast-channel.html","text":"API Communication Procedure Usage Example Notice The BroadcastChannel is available since v0.9+. As mentioned in JS Runtime Context, Weex is using different context for each page, even global variables are isolated, but BroadcastChannel is a way to achieve cross-page communication. API# BroadcastChannel is part of W3C specifications, as well as the MessageEvent. The constructor of BroadcastChannel only take one single parameter which is the channel name. const jb = new BroadcastChannel('007') The type declaration of the BroadcastChannel is: declare interface BroadcastChannel = &#123; name: string, postMessage: (message: any) =&gt; void; onmessage: (event: MessageEvent) =&gt; void; close: () =&gt; void;&#125; name: The channel name, it’s the indicator when broadcast messages. postMessage: Sends the given message to other BroadcastChannel objects set up for this channel. onmessage: The event handler. An event will be triggered when the instance received a message. close: Closes the BroadcastChannel object, opening it up to garbage collection. The type declaration of the MessageEvent is: declare interface MessageEvent = &#123; type: string, // \"message\" data: any&#125; Communication Procedure# Just like using radio, each client joins a specific channel by creating a BroadcastChannel object with the same channel name. Then implement the onmessage event handler to listen on the underlying channel. Call the postMessage() method on the BroadcastChannel object will broadcast a message to every subscriber of the channel. Indeed, it’s a full-duplex (bi-directional) communication between all subscriber of the particular channel, each of them is able to receive any message that has been posted to it. Even the sender of the message can receive the message event itself. Communications between different channels will not affect each other. To leave a channel, it is required to call the close() method on the BroadcastChannel object. This method only closed itself, and does not affect other subscribers. When a Weex page is destroyed, all subscribers in it will be closed at destroyInstance. If all subscribers of a channel are closed, the underlying channel would be destroyed and allows garbage collection to happen. Usage Example#In page A: const Steve = new BroadcastChannel('Avengers')Steve.postMessage('Assemble!') In page B: const Hulk = new BroadcastChannel('Avengers') In page C: const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // Assemble! Stack.postMessage('I am Tony and I am leaving now.')&#125; The page A, B and C are all create a BroadcastChannel object which is listening on the &#39;Avengers&#39; channel. They can use it to communicate with each other. When Steve post the message &#39;Assemble!&#39;, Stack will receive a message event whose data equals the &#39;Assemble!&#39;, and then send another message back. But Hulk will not receive the message because he does not implement the onmessage method, so he is not a subscriber actually. Notice# The message object is not deep cloned. (This feature could be changed.) In page A: const a = new BroadcastChannel('app')const list = ['A', 'B']a.postMessage(list) In page B: const b = new BroadcastChannel('app')b.onmessage = function (event) &#123; // the event.data is a reference of list in page A event.data.push('C')&#125; In this case, the event.data in page B is a reference of list in page A. When pushing a new item &#39;C&#39;, it will also affect the list object in page A. Compared to the deep clone, this behavior improves efficiency and reduces memory cost. However, developers are not recommended caching or modifying the event object after received it.","type":"references"},{"title":"Android APIs","path":"references/android-apis.html","permalink":"https://weex.apache.org/references/android-apis.html","text":"Android APIs#WXSDKEngine# Register the module and component Set up various adapters Module &amp; Component#Component#One can register a component using the following function: public static boolean registerComponent(IFComponentHolder holder, boolean appendTree, String ... names) holder is a abstract factory designed for create Component, and SimpleComponentHolder is the a simple way to achieve IFComponentHolder. appendTree is an additional flag which is unused now. names is the component’s name in front end template file. A Android component could be mapped into multiple names. Module#One can register a module using the following way: public static &lt;T extends WXModule&gt; boolean registerModule(String moduleName, Class&lt;T&gt; moduleClass,boolean global) throws WXException moduleName is the name in front end template. moduleClass is the Java class of the module, which provide a constructor with an empty parameter. global is a flag, true for singleton in the whole app, false for creating an object for each WXSDKIntance. Adapter#ImageAdapter#Image adapter is responsible for loading images according to URLs. There are two types of image adapter: Loading a image to a view according to URL. Loading a image to a specified object according to URL. In order to use image component, one must implement the first adapter, while the second adapter is optional. IWXImgLoaderAdapter#public interface IWXImgLoaderAdapter { void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy); } WXImageQuality that the quality of the picture variables, take the following values LOW, NORMAL, HIGH, ORIGINAL picture quality in turn higher. The default is LOW. WXImageStrategy is an extension class that indicates whether the image can be cut (isClipping) sharpening (isSharpen) placeholder (placeHolder) and so on. IDrawableLoaderAdapter#This adapter is optional. void setDrawable(String url, DrawableTarget drawableTarget, DrawableStrategy drawableStrategy); DrawableTarget is a object into where will load an image. DrawableTarget is one of StaticTarget or AnimatedTarget. IWXHttpAdapter#Weex custom WXRequest and OnHttpListener, Native reload interface can be obtained from the Request URL, Header and other parameters, the network request can be completed through OnHttpListener callback notification. Weex provides the default network request: DefaultWXHttpAdapter, using HttpURLConnection for network requests. The interface is defined as follows: public interface IWXHttpAdapter { void sendRequest(WXRequest request, OnHttpListener listener); } WXRequest defines the parameters related to the network request, the request method, the request body, and the timeout time. Weex default timeout is 3000. OnHttpListener defines the corresponding method after the network request ends. Defined as follows: interface OnHttpListener { /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response); } IWXUserTrackAdapter#Weex related performance data (first screen loading time, JS-Native communication time, dom update time, etc.) and other general information (JSLib file size, Weex SDK version number, etc.). public interface IWXUserTrackAdapter { void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params); } Native implementation interface can be obtained through WXPerformance and params corresponding information. IActivityNavBarSetter#Weex provided the ability of navigation through WXNavigatorModule which relys on IActivityNavBarSetter. Usage: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){}); IWXStorageAdapter#Weex provided the ability of local storage through WXStorageModule which depends on IWXStorageAdapter. One can use DefaultWXStorage as the default implementation of IWXStorageAdapter. IWXJSExceptionAdapter#IWXJSExceptionAdapter is used to handle JavaScript exception. WXSDKInstace#Weex Native and JavaScript communication.#Custom events#Used for a custom control for event notifications, such as custom click events, response drop events, and so on. WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges){ } public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data){ fireEvent(elementRef,type,data,null); } public void fireEvent(String elementRef, String type){ fireEvent(ref,type,new HashMap&lt;String, Object&gt;()); } elementRef：The event occurred for the control ID。 type: Custom events, Weex defaults to a custom event starting with onXxxxx. OnPullDown (drop-down event) data: Need to reveal the parameters, such as the current control of the size, coordinates and other information。 domChanges：Update ref for the control’s Attribute and Style Event callback#Used for Module callback, for example, after the completion of positioning Module need to notify JS. Use as follows: public class WXLocation extends WXModule { @JSMethod public void getLocation(JSCallback callback){ //Get the code for the location information ..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(&quot;x&quot;,&quot;x&quot;); data.put(&quot;y&quot;,&quot;y&quot;); //notify once callback.invoke(data); //Continuous connection callback.invokeAndKeepAlive(data); //Invoke method and invokeAndKeepAlive two methods of choice } } Weex Native and other Native code communication#OnWXScrollListener#Weex gets the scroll event You can register registerOnWXScrollListener via WXSDKInstanceThe interface is defined as follows: public interface OnWXScrollListener { /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view&apos;s scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState); } Other Introduction#setSize#You can use the mWXSDKInstance.setSize() method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onException method in interface IWXRenderListener, and if it is an active demoulding errCode is a character that is divided by “|”. “|” The preceding character is 1 for active demotion, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"iOS APIs","path":"references/ios-apis.html","permalink":"https://weex.apache.org/references/ios-apis.html","text":"iOS APIs#Handler(like Android Adapter)# WXImgLoaderDefaultImpl Image load handler. Weex need to implement this interface to download the picture. The interface is defined as follows: @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native interacts with JavaScript# Custom events Used for a custom control for event notifications, such as custom click events, response drop events, and so on. This is a method in the component base class that can be used directly. /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName * @param params * @param domChanges **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges Event callback Used for Module callback. There are two types of callback: WXModuleCallback: For performance reasons, the callback can only callback js once, and then will be released. WXModuleKeepAliveCallback: This callback can be set to multiple callbacks, multiple callbacks of the scene such as continually listen scrolls event and return to js. @implementation WXEchoModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);&#125; Set size of the Weex container#You can use the setFrame(CGRect) method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onFailed method in interface WXSDKInstance, and if it is an active demoulding error domain is TemplateErrorType, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"JS Service","path":"references/js-service.html","permalink":"https://weex.apache.org/references/js-service.html","text":"JS Service#v0.9.5+ JS service and Weex instance are parallel in js runtime. Weex instance lifecycle will invoke JS service lifecycle. Currently provide create, refresh, destroy of lifecycle. !!!Important: JS Service is very powerful. Please be careful to use. Register JS Service#iOS#[WXSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;];// or[WXSDKEngine registerService:@&quot;SERVICE_NAME&quot; serviceScriptUrl: @&quot;SERVICE_JS_URL&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; Write a JS Service#service.register(SERVICE_NAME /* same string with native */, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: function() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"Weex Variable","path":"references/weex-variable.html","permalink":"https://weex.apache.org/references/weex-variable.html","text":"Properties and Methods weex.config Weex Environment Object weex.document weex.requireModule Use Native Module weex.supports Examples weex.isRegisteredModule weex.isRegisteredComponent Each page of Weex contains a weex variable in the js runtime context. It can be assessed directly just like a global object, but it’s readonly and separated from different pages. NOTE: The weex variable only exposed in the Vue framework. It’s not available in Rax framework yet. Properties and Methods#The type declaration of the Weex variable is: declare type Weex = &#123; config: WeexConfigAPI; document: WeexDocument; requireModule: (name: string) =&gt; Object | void; supports: (condition: string) =&gt; boolean | void;&#125; weex.config#The weex.config contains all the environment information of current page. declare type WeexConfigAPI = &#123; bundleUrl: string; bundleType?: string; env: WeexEnvironment;&#125; bundleUrl: The URL of the js bundle in current page. bundleType: v0.17+ The type of the js bundle, it indicates which framework is using for current js bundle, could be &quot;Vue&quot; or &quot;Rax&quot;. env: Weex environment object. Weex Environment Object#Sometimes, you still need to write some platform specific codes for compatibility or enhancement. Weex provides weex.config.env and a global object WXEnvironment (they are strictly equal) to get the information of current runtime environment. weex.config.env === WXEnvironment Properties in Weex environment object: Property Type Description platform String Current running platform, could be “Android”, “iOS” or “Web”. weexVersion String The version of Weex SDK. appName String Mobile app name or browser name. appVersion String The version of current app. osName String The OS name, could be “Android” or “iOS”. osVersion String The version of current OS. deviceModel String Mobile phone device model. (native only) deviceWidth Number Screen resolution width. deviceHeight Number Screen resolution height. This example prints all properties in the Weex environment object. weex.document#The weex.document is the document object of current page, it can be used to create or manipulate the Elements in DOM tree. It’s part of Weex DOM API specification which is NOT the same with the document object in the W3C DOM API. However, it’s not a good practice to manipulate DOM directly when using modern front-end frameworks, such as Vue and Rax. Especially, there is no actually DOM in Weex, it was simulated on the native (Android or iOS). This API is mainly used inside of the Vue and Rax framework to convert the virtual-dom into render directives and send them to native render engines of Weex. Not recommended for using it when developing pages. weex.requireModule#For those features which does not rely on the UI, Weex wraps them into modules. It is a way to access native capabilities in javascript. Except for the built-in modules, it’s quite easy to integrate the existing native modules to Weex platform. After that, you can use weex.requireModule to require both customized and built-in modules. weex.requireModule(name: string): Object | void; Parameter: A case-sensitive module name. Return Value: If the module is registered, return a Proxy or plain object if the context doesn’t support Proxy. You can use it to call the registered methods in the module. If the module is unregistered, return undefined. Use Native Module#You can require a native module and use its APIs just like normal javascript functions. Here is a simple example of using the modal module: &lt;template&gt; &lt;div&gt;&lt;text&gt;Toast&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.supports# This API only available in v0.15+. As you may know, components and modules are extendable and configurable in Weex. So it could be various in different apps or running context. You can use weex.supports to detect whether a feature is supported in the current environment at runtime. weex.supports(condition: string): boolean | void; Parameter: A formatted condition string: @{type}/{name}. The type must be &quot;component&quot; or &quot;module&quot;. The name could be a tag name, module name or the method name in specific module. Return Value: If the feature is supported, return true. If the feature is unsupported, return false. If not sure about whether this feature is supported, return null. Examples#Detects whether the specific component is supported: weex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false Detects whether the specific module is supported: weex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false Detects whether the method in specific module is supported: weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false Invalid input or unknown features: weex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null weex.isRegisteredModule#Detect whether the specific module or method is registered. weex.weex.isRegisteredModule(moduleName: string, methodName: string): boolean It can only be used to check compatibility of a specific module or method. weex.isRegisteredModule('stream') // trueweex.isRegisteredModule('stream', 'fetch') // trueweex.isRegisteredModule('whatever', '- unknown -') // falseweex.isRegisteredModule('div') // false, not support components weex.isRegisteredComponent#Detect whether the specific component is registered. weex.weex.isRegisteredComponent(componentName: string): boolean It can only be used to check compatibility of a specific component. weex.isRegisteredComponent('div') // trueweex.isRegisteredComponent('- unknown -') // falseweex.isRegisteredComponent('navigator') // false, not support modules","type":"references"},{"title":"Helpers","path":"tools/helpers.html","permalink":"https://weex.apache.org/tools/helpers.html","text":"Weex Language Support Plugin#Weex Language Support is a official tools to code highlight, automatic completion，lint and other functions in IDEA, WebStorm or the others IDEs. Supported IDEs#You can install and use this plugin on the following IDEs on any operating system:IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider Install#Just searching the Weex Language Support in plugin repo to install, next you need restart IDE to enable it. Configurations#Open Preferences -&gt; Other Settings -&gt; Weex language support to configuration plugin Target Weex Version: Config the version of Weex that your current project in use, default is LATEST, it means always using the latest version Vue Support: Config whether to support Vue, you need to restart IDE after turning on or off the set to take effect Custom Rules: Import the custom Weex DSL rules, The format of the custom rules will be listed later Global Weex Components: Sets the location of the module that is applied in the project, in particular, the node_modules directory in current project and npm root will be automatically included, you do not need to add them here Format of Custom DSL Rules#Custom rules are included in a json file, the root node of the json file is an array, each element in the array corresponds to a label in the DSL.Let’s take the example of the loading&gt; tag:&#123; \"tag\": \"loading\", //tag name, not null \"attrs\": [ //attributes of tag, can be null &#123; \"name\": \"display\", //attribute name, not null \"valuePattern\": null, //pattern expression to check the attribute value, can be null \"valueEnum\": [ //attribute value enumeration, can be null \"show\", \"hide\" ], \"valueType\": \"var\", //type of attribute value, must be var or function \"since\": 0, //which version the attribute is added to sdk, such as 0.11 \"weexOnly\": false //whether the attribute is available only in 1.0 syntax, default is false &#125; ], \"events\": [ //events list, can be null &#123; \"name\": \"loading\", //event name, not null \"since\": 0 //which version the event is added to sdk &#125; ], \"parents\": [ //The tag is allowed to be a child of which tags, null means no restrictions \"list\", \"scroller\" ], \"childes\": [ //which tags are allowed as their own child tags, null means no restrictions \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //document link &#125; Contribution#Please commiting Issues and Pull Requests into the weex-language-support project","type":"tools"},{"title":"Use weex-toolkit","path":"tools/toolkit.html","permalink":"https://weex.apache.org/tools/toolkit.html","text":"weex-toolkit#weex-toolkit is an official command line tool to help developers to create, debug and build their Weex project. Install#$ npm install -g weex-toolkit You can use the weex -v command to confirm that the installation is successful. If you have never installed node.js, you should go node.js.org to download and install it. The node version needs to be upper 6.0. You can try n to manage your node versions. If you meet some errors when installing, please go weex-toolkit issues or weex-toolkit faq to find some solution or have a discuss with us. Commands#create## create a new project with an official template$ weex create my-project# create a new project straight from a github template$ weex create username/repo my-project Create a new project with an official template or from other remote, also you can create your own weex template, more detail you can see How-to-create-your-own-template. preview#weex-toolkit supports previewing your Weex file(.vue) in a watch mode. You only need specify your file path. $ weex preview src/foo.vue The browser automatically opens the preview page and you can see the layout and effects of your weex page. If you have a Playground App in your mobile devices, you can scan the QR code at the opened page. Try the command below, you’ll preview the whole directory files. $ weex preview src --entry src/foo.vue You need to specify the folder path to preview and the entry file (passed in via --entry). compile#Use weex compile o compile a single weex file or a weex file in an entire folder. $ weex compile [source] [dist] [options] options# Option Description -w, --watch watch we file changes auto build them and refresh debugger page! [default true] -d,--devtool [devtool] set webpack devtool mode -e,--ext [ext] set enabled extname for compiler default is vue -m, --min set jsbundle uglify or not. [default false] You can use like this: $ weex compile src dest --devtool source-map -m platform#Use weex platform [add|remove|update] [ios|android] to add, remove or update your ios / android project templates. # add weex platform$ weex platform add [ios|android]# remove weex platform$ weex platform remove [ios|android]# update weex platform$ weex platform update [ios|android]# list weex platform$ weex platform list Use weex platform list to show what platforms your application supported. run#You can use weex-toolkit to run project on android/ios/web. # run weex Android project$ weex run android# run weex iOS project$ weex run ios# run weex web$ weex run web debug# Weex devtools is a custom devtools for Weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page, both android and iOS platform are supported. So you can use weex-devtools feature by weex-toolkit. usage#weex debug [we_file|bundles_dir] [options] Option Description -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer or loader] -w, --watch watch we file changes auto build them and refresh debugger page [default true] --ip [ip] set the host ip of debugger server --loglevel [loglevel] set log level --min set jsbundle uglify or not. [default false] --remotedebugport [remotedebugport] set the remote debug port,default 9222 Features#Connect devices#$ weex debug This command will start debug server and launch a chrome opening DeviceList page.this page will display a QR code, you can use Playground scan it for starting debug or integrate Weex devtools into your application. Debug with .vue file#$ weex debug your_weex.vue Click the button you can use your app or weex playground app to preview your pages. Inspector# Inspector feature to view the page’s VDOM / Native Tree structure Note: If you do not need this feature as far as possible to maintain the closed state, open the browser Inspector interface will increase the page communication, more affect performance. Breakpoint# JS Debug feature support you to set breakpoint on your jsbundle and debugging with it. You can find your jsbundle in the source folder of the Runtime.js directory. If you do not see the Runtime.js directory, check if the weex-debugger tool is completely installed or try to restart the debug tool. NetWork# The Network feature collects network request information from weex applications. Loglevel &amp; ElementMode# The LogLevel and ElementMode feature are used to adjust the output configuration of the debugger. Prophet# The Prophet feature is used to view weex’s load timing diagram and page performance metrics. Click on the upper right corner of the Prophet to view the timing diagram (iOS is not supported, the performance data can be viewed in the log performance), as follows: Integrate devtool# Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. iOS See the doc Weex devtools (iOS), it will lead you to config and use it step by step.","type":"tools"},{"title":"Color name","path":"wiki/color-names.html","permalink":"https://weex.apache.org/wiki/color-names.html","text":"Basic color keywords: Extended color keywords: Basic color keywords:# Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords:# Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"Common Events","path":"wiki/common-events.html","permalink":"https://weex.apache.org/wiki/common-events.html","text":"Click event event object Longpress event event object Appear event event object Disappear event event object Page event event object Example Weex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Below are the common event attributes that can be added to weex components to define event actions. Click event#The onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Longpress event#If a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Appear event#If a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object# type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Disappear event#If a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object# type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Page event#Weex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object# type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"Common Styles","path":"wiki/common-styles.html","permalink":"https://weex.apache.org/wiki/common-styles.html","text":"Box Model Notes Example Flexbox Flex container Flex item Examples Position Examples transform Example transition v0.17.0+ Property Example Pseudo class v0.9.5+ Rule Example linear-gradient v0.10+ Supported components Usage Note Example box-shadow v0.11+ Note Example Other Common Style Type of Style Value Simple Step All of weex tags share some common style rules Box Model# Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0 border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 Notes#Weex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt;in iOS. This only happens to iOS, it works fine on Android. Although overflow:hidden is default on android, a view will not clip its children according to border-radius unless all the following condtions met. This only happens on Android, it works fine on iOS. The view type is div, a, cell, refresh or loading. OS version is Android 4.3 or higher. OS version is not Andorid 7.0 A view does not have background-image property nor OS version is Android 5.0 or higher. Example#&lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex container#Flexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item# flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examples#a list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Position#we can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples#&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; transform#The CSS transform property lets you modify the coordinate space of the CSS visual formatting model. Using it, elements can be translated, rotated and scaled. Currently supported format: translate( &lt;number/percentage&gt; [, &lt;number/percentage&gt;]?) translateX( &lt;number/percentage&gt; ) translateY( &lt;number/percentage&gt; ) scale( ) scaleX( ) scaleY( ) rotate( &lt;angle/degree&gt; ) rotateX( &lt;angle/degree&gt; ) v0.14+ rotateY( &lt;angle/degree&gt; ) v0.14+ perspective( ), supported for Android 4.1 and above. v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.17.0+#Now you can use the transition attribute in CSS to enhance the interactivity and visual experience of your application. The transition includes the layout animation, that is, LayoutAnimation, which now changes the layout and uses the fluent animation of the transition. Transition allows the CSS attribute values to transition smoothly over a certain time interval. Property# transition-property:Allows the name of the transitional animation to set the value of the different styles transition effect, the default value is empty, that does not perform any transition, the following table lists all the legitimate parameters of the property: Property Description width The transition is performed when the width of the component is involved in the animation height The transition is performed when the height of the component is involved in the animation top The transition is performed when the top of the component is involved in the animation bottom The transition is performed when the bottom of the component is involved in the animation left The transition is performed when the left of the component is involved in the animation right The transition is performed when the right of the component is involved in the animation backgroundColor The transition is performed when the backgroundColor of the component is involved in the animation opacity The transition is performed when the opacity of the component is involved in the animation transform The transition is performed when the transform of the component is involved in the animation transition-duration:Specifies the duration of the transition transition (in milliseconds). The default value is 0, indicating that there is no animation. transition-delay:Specifies the time interval (in milliseconds or seconds) between the request transition transition and the transition transition. The default value is 0, indicating that there is no delay, and the transition transition is performed immediately after the request. transition-timing-function:Describes the velocity curve of the transition transition, which is used to make the transition transition smoother. The default is ease. The following table lists all the valid attributes: Property Description ease The transition gradually slow down the transition effect ease-in The transition starts slowly and then becomes faster for the transition effect ease-out The transition starts quickly and then slows the transition effect ease-in-out The transition starts slowly, then goes fast and then slowly ends the transition effect linear The transition changes at constant speed cubic-bezier(x1, y1, x2, y2) Using the custom transition in the third-order Bessel function, the parameter values of the function must be between 0 and 1. For more information on three times Bessel, see cubic-bezier and Bézier curve. Example#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; Pseudo class v0.9.5+#Weex support four pseudo-classes: active, focus, disabled, enabled All components support active, but only the input component and the textarea component support focus, enabled, diabled. Rule# the high priority override low priority when rules take effect at the same time such as: “input:active:enabled” will override “input:active” the interconnection rule as follow Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; Try it linear-gradient v0.10+#Weex support linear-gradient background, You can see W3C description of the gradient. Supported components#All components in Weex support gradients Usage#You can use linear gradient by background-image property. background-image: linear-gradient(to top,#a80077,#66ff00); radial-gradient is not currently supported, do not use it. Weex currently supports two color gradients. The direction of the gradient is as follows: to rightFrom left to right to leftFrom right to left to bottomFrom top to bottom to topFrom bottom to top to bottom rightFrom the upper left corner to the lower right corner to top leftFrom the lower right corner to the upper left corner Note# background-image and background-color are set at the same time, background-image precedes background-color. Do not use shorthand property such as background. Example#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; box-shadow v0.11+#Weex supports box-shadow in iOS： inset,offset-x,offset-y, blur-radius,color Note# box-shadow takes effect in iOS Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; Other Common Style# opacity background-color Type of Style Value# length type number type color type (The list of color keywords.) enumerated type Simple Step#These up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"wiki"},{"title":"Component","path":"wiki/component-introduction.html","permalink":"https://weex.apache.org/wiki/component-introduction.html","text":"what’s component# Generally，component is a entity Widget in Weex engine, and it can be loaded if confirm to some details rules whlile the Weex engine init. It can display some detail contents, receive touch or other custom events, custom attributes. There are some internal components registered such as div, image and text, you can custom your own component if these can not meet your needs. component method# you can call custom methods for a entity component after adding ref attributes, for example: &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"wiki"},{"title":"CSS Units","path":"wiki/css-units.html","permalink":"https://weex.apache.org/wiki/css-units.html","text":"CSS color units Notes CSS length units CSS number units CSS percentage units (Not support now) CSS color units#.classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; Notes# Not support hsl(), hsla(), currentColor, or 8-character hexadecimal color. Performance of rgb(a,b,c) or rgba(a,b,c,d) is much worse than other color formats, please select the appropriate color format. build-in color name you can see Color Names. CSS length units#In weex we only support px length units. It will resolve to a numeric type in the JavaScript runtime and native renderer.You can use it like this : .classA &#123; font-size: 48px; line-height: 64px; &#125; Other length units in the CSS standard like em, rem, and pt are not supported. CSS number units#You can use number on property opacity and lines. CSS percentage units (Not support now)#","type":"wiki"},{"title":"Design Principles","path":"wiki/design-principles.html","permalink":"https://weex.apache.org/wiki/design-principles.html","text":"","type":"wiki"},{"title":"Event Bubble","path":"wiki/event-bubble.html","permalink":"https://weex.apache.org/wiki/event-bubble.html","text":"Concept How To Use Stop Bubbling Notice Examples v0.13+ Note: This feature works only on weex’s native platforms (i.e., on Android and iOS), but not on the web with latest web renderer yet. If you are a web developer, then you are probably familiar with the event bubbling mechanism, and you may expect Weex to work the same way. However, Weex didn’t implement this mechiansim util version 0.13. To those developers who are not familiar with the event bubbling, Here are some explanations about it, and the concept is rather easy. Concept#Take clicking as a example. When a click event fired on a &lt;video&gt; element that has a parent element (e.g. a parent div component), web browsers run two different phases - the capturing phase and the bubbling phase. We use bubbling phase a lot in web development, and use capturing less. In the capturing phase, The browser checks to see if the element’s outer-most ancestor (on web, may be a &lt;html&gt;) has an corresponding event handler registered on it, and runs it if so. Then it moves on to the next element inside &lt;html&gt; and does the same thing, then the next one, and so on until it reaches the element that was actually clicked on. In the bubbling phase, the exact opposite occurs: The browser checks to see if the element that was actually clicked on has an onclick event handler registered on it in the bubbling phase, and runs it if so. Then it moves on to the next immediate ancestor element and does the same thing, then the next one, and so on until it reaches the &lt;html&gt; element. We usually register our event listeners on the bubbling phase, so that we use bubbling a lot. But if you want to turn this off, you can use stopPropagation method of the event object. The standard event object has a function available on it called stopPropagation, which when invoked on a handler’s event object makes it so that handler is run, but the event doesn’t bubble any further up the chain, so no more handlers will be run. Weex implemented this event bubbling phase in the 0.13 SDK, and for the record, the event bubbling phase is not enabled by default - You should use a attribute bubble=true on the root element to turn this feature on. How To Use#The event bubbling is not enabled by default, you should use bubble=&quot;true&quot; in the root element to turn it on. &lt;template&gt; &lt;!-- Use it in the root element to turn it on. --&gt; &lt;div bubble=\"true\"&gt; ... &lt;/div&gt;&lt;/template&gt; Stop Bubbling#In the event handler function, you can use the event.stopPropagation() method to prevent the event from escalating, which is exactly like the event’s method with the same name in DOM standard. Note that event.stopPropagation() differs from bubble = &quot;true&quot;, which affects only the current elements and the propagation of parent elements, without affecting the propagation of child elements; the latter is a switching mechanism that is added for compatibility, Will be a global shutdown or open the bubble mechanism, the two can co-exist. &#123; handleClick (event) &#123; // Stop event propagation. event.stopPropagation() &#125;&#125; Notice#One thing should be noticed: For compatibility reason, Weex does not turn on event bubbling by default. You need to add bubble = &quot;true&quot; on the root element’s properties to turn on the bubbling mechanism. Otherwise, Weex will keep working in the old way, without the event bubbling effect. Examples# enable event bubbling: Use Weex playground APP to scan the qr-code, and then click on the middle of the rectangle with a line of text ‘click me’ on, you can see the event bubbling up, being handled with every listener binding on each div element, printing messages which indicate that they are indeed been reached by the event. stop event propagation: Use Weex playground APP to scan the qr-code, and then click on the middle of the rectangle with a line of text ‘click me’ on, you can see the event bubbling is disturbed, no longer continue to spread to the root element.","type":"wiki"},{"title":"Gesture","path":"wiki/gestures.html","permalink":"https://weex.apache.org/wiki/gestures.html","text":"Type Properties changedTouches Constrain Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Type#For now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. shouldStopPropagation every touch event will be fired, you can control touch event whether should be bubbled by return true(should bubble) or false(touch event consumed by this view, will not be bubbled). this can be used to handle touch confliction between views. (since v0.18+) Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Horizontal/Vertical Pan v0.10+ . Mainly used for cell swipe gestures before conflict resolving system is completed. start/move/end state of the gesture will be passed by state property. Note: These gestures are in conflict with click event on Android currently. horizontalpan verticalpan Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. LongPress is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. Properties#The following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedTouches#changedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. force. A float value that represents the amount of pressure the user is applying to the touch surface. This is a value between 0.0 (no pressure) and 1.0 (the maximum amount of pressure the hardware can recognize). iOS only and force is included in iPhone 6S and later models have a try Constrain#Currently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting.","type":"wiki"},{"title":"Handler","path":"wiki/handler-introduction.html","permalink":"https://weex.apache.org/wiki/handler-introduction.html","text":"what’s handler# handler(adapter) is just like service in WeexSDK engine, it can service for component and module, you can use it directly in component、module and other native code. handler caller#handler decouples the interface implementation and its interface. You don’t need to care more details about the implementation as a handler user, this can be done by the handler developer and the instance of handler will be only one during the lifecycle of application. You can define your own handler interface(protocol in iOS) and use it in any native code. the difference between module and handler# position in app Assume that we have three weex page(WeexSDK instance) in navigation stacks, and they all use fetch module method during the render of page. There will be an instance of fetch module class in every page(WeexSDK instance) destroyed with page destroyed, but there will be only one for the instance of handler class. usage handler can be called in any native code including weex native component, module and other handlers, it cannot be used in javaScript directly.module can export some methods by native developers to front-end developers, it can be used in javaScript code. introduction to internal handler# navigationHandler There is a default implementation for navigation insterface(protocol), this handler can be used in navigation module methods which complete pop and push operations. imageLoaderHandler The image component is a container for image, you can specify url to load image, the logic for download image is in the imageLoaderHandler handler, image component only display image contents. WeexSDK doesn’t provide default loader for image handler. AppMonitorHandler There are some metrics collected during the render progress, and module caller frequency also collect, you can got these metrics by implementing AppMonitorHandler handler. WeexSDK doesn’t provide default handler for AppMonitorHandler. JSExceptionHandler There are some runtime exceptions during the execution of javaScript code, JSExceptionHandler provide the monitor for javaScript exception, WeexSDK will invoke this handler while exceptions occurs. WeexSDK doesn’t provide default handler for JSExceptionHandler. URLRewriteHandler image、video and web load content from specified url by adopting this rewrite rules, you can define your own rules for custom path. WeexSDK provide default handler for URLRewriteHandler. Get more details about the default rewrite rules","type":"wiki"},{"title":"Module","path":"wiki/module-introduction.html","permalink":"https://weex.apache.org/wiki/module-introduction.html","text":"What is a module?#A module is a set of method operations. You can require it and call its methods. During the initialization of WeexSDK, some internal modules have already been registered by the engine. Native module registration process# Built-in modules#stream module: it provides a method called fetch which can invoke a network request to specified server. You can get more details here. For example: var stream = weex.requireModule('stream');stream.fetch(&#123; method: 'GET', url: 'http://httpbin.org/get', type:'jsonp' &#125;, function(ret) &#123; console.log('in completion') &#125;,function(response)&#123; console.log('in progress') &#125;); Difference between module method and component method#For a module method, you can call the method after require and it doesn’t rely on any component instance. For component method, you must get the ref for component first and then call the component method","type":"wiki"},{"title":"Platform Differences with Web","path":"wiki/platform-difference.html","permalink":"https://weex.apache.org/wiki/platform-difference.html","text":"Platform Differences with Web#Work in progresss.","type":"wiki"},{"title":"Text Styles","path":"wiki/text-styles.html","permalink":"https://weex.apache.org/wiki/text-styles.html","text":"Properties Type of Style Value Text alike components share some common style rules. The text alike components currently includes text and input. Properties# color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weightv0.9+: values: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal is equal to 400, bold equel to 700 default value: normal apply to: &lt;text&gt;, &lt;input&gt; ios support showing 9 kind of font-weight. android support showing 2 kind of font-weight:400,700, other value will map to 400 or 700 Some standard values like lighter, bolder, number unit are not supported. The effect not apply to all elements, just &lt;text&gt; and &lt;input&gt;. In another way, it’s not inherited. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value# length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"wiki"},{"title":"扩展 Android 的功能","path":"cn/guide/extend-android.html","permalink":"https://weex.apache.org/cn/guide/extend-android.html","text":"Module 扩展 Component 扩展 Adapter扩展 Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展# Module 扩展必须继承 WXModule 类。 扩展方法必须加上@JSMethod (uiThread = false or true) 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule &#123; //run ui thread @JSMethod (uiThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; //run JS thread @JSMethod (uiThread = false) public void fireEventSyncCall()&#123; //implement your module logic here &#125;&#125; Register the module WXSDKEngine.registerModule(\"MyModule\", MyModule.class); JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;testMyModule&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('MyModule').printLog(\"I am a weex Module\"); &#125; &#125; &#125;&lt;/script&gt; Component 扩展# Component 扩展类必须继承 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richText&quot;, RichText.class); 示例如下: public class RichText extends WXComponent&lt;TextView&gt; &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) &#123; super(instance, dom, parent); &#125; @Override protected TextView initComponentHostView(@NonNull Context context) &#123; TextView textView = new TextView(context); textView.setTextSize(20); textView.setTextColor(Color.BLACK); return textView; &#125; @WXComponentProp(name = \"tel\") public void setTel(String telNumber) &#123; getHostView().setText(\"tel: \" + telNumber); &#125;&#125; 注册你的组件： WXSDKEngine.registerComponent(\"richText\", RichText.class); JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/richText&gt; &lt;/div&gt;&lt;/template&gt; 组件方法支持#从WeexSDK 0.9.5开始，你可以定义组件方法 在组件中如下声明一个组件方法 @JSMethodpublic void focus()&#123; //method implementation&#125; 注册组之后，你可以在weex 文件中调用 &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39; Adapter扩展#图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; SDK混淆规则#若要在APP中使用混淆，请在相应的配置文件中添加如下规则： -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;-keep class com.taobao.weex.bridge.**&#123;*;&#125;-keep class com.taobao.weex.dom.**&#123;*;&#125;-keep class com.taobao.weex.adapter.**&#123;*;&#125;-keep class com.taobao.weex.common.**&#123;*;&#125;-keep class * implements com.taobao.weex.IWXObject&#123;*;&#125;-keep class com.taobao.weex.ui.**&#123;*;&#125;-keep class com.taobao.weex.ui.component.**&#123;*;&#125;-keep class com.taobao.weex.utils.**&#123; public &lt;fields&gt;; public &lt;methods&gt;; &#125;-keep class com.taobao.weex.view.**&#123;*;&#125;-keep class com.taobao.weex.module.**&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep class * implements com.taobao.weex.ui.IExternalComponentGetter&#123;*;&#125;","type":"guide"},{"title":"扩展 iOS 的功能","path":"cn/guide/extend-ios.html","permalink":"https://weex.apache.org/cn/guide/extend-ios.html","text":"自定义 module Component 扩展 component 基础生命周期 更多 component 生命周期 component 方法 自定义 handler 注意：Weex 所有暴露给 JS 的内置 module 或 component API 都是安全和可控的， 它们不会去访问系统的私有 API ，也不会去做任何 runtime 上的 hack 更不会去改变应用原有的功能定位。 如果需要扩展自定义的 module 或者 component ，一定注意不要将 OC 的 runtime 暴露给 JS ， 不要将一些诸如 dlopen()， dlsym()， respondsToSelector:，performSelector:，method_exchangeImplementations() 的动态和不可控的方法暴露给JS， 也不要将系统的私有API暴露给JS Weex SDK 只提供渲染，提供了一些默认的组件和能力，如果你需要一些特性但 Weex 并未提供，可以通过扩展自定义的一些插件来实现，通过 WeexSDK 加载。这些插件包括 component, module 和 handler。 本文都以 Objective-C 为例子书写，如果需要 swift 请参考 使用 swift 扩展 Weex 自定义 module#自定义 module, 需要让自己的 class 遵循 WXModuleProtocol 这个protocol, 通过 WX_EXPORT_METHOD 这个宏暴露出需要透出到 JavaScript 调用的方法，注册 module , 就可以完成一个简单 module 的自定义。 module 自定义初阶 下面完成一个 module, 该 module 暴露一个打印输入参数的方法 新建一个 基类为 NSObject 的 class WXCustomEventModule, 让该类遵循 WXModuleProtocol 的协议 添加打印的方法，通过 WX_EXPORT_METHOD 暴露该方法 在初始化完成 Weex SDK 之后注册该 module 到此，我们已经完成了一个简单的 module 方法的封装，javaScript 端的使用如下: weex.requireModule(\"event\").showParams(\"hello Weex) module 高阶用法 weexInstance在一个 Weex 页面中，默认 WXSDKInstance 的 Object 持有 多个 module 的 Object, 而 module 的 object 是没有对 WXSDKInstance 做持有的， 在自定义的module 中添加 @synthesize weexInstance, module Object 可以对 持有它本身的 WXSDKInstance Object 做一个 弱引用， 通过 weexInstance 可以拿到调用该 module 的页面的一些信息。 targetExecuteThreadModule 方法默认会在UI线程中被调用，建议不要在这做太多耗时的任务，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)的方法，这样，分发到这个module的任务会在指定的线程中运行 WXModuleKeepAliveCallbackModule 支持返回值给 JavaScript中的回调，回调的类型是WXModuleKeepAliveCallback,回调的参数可以是String或者Map, 该 block 第一个参数为回调给 JavaScript 的数据，第二参数是一个 BOOL 值，表示该回调执行完成之后是否要被清除，JavaScript 每次调用都会产生一个回调，但是对于单独一次调用，是否要在完成该调用之后清除掉回调函数 id 就由这个选项控制，如非特殊场景，建议传 NO。 WX_EXPORT_METHOD_SYNC WeexSDK 0.10 版本后才支持，暴露的同步方法只能在 JS 线程执行，请不要做太多同步的工作导致JS执行阻塞。 使用 WX_EXPORT_METHOD 暴露到前端的方法都是异步方法(获得结果需要通过回调函数获得), 如果期望获得同步调用结果，可以使用WX_EXPORT_METHOD_SYNC 暴露module 方法。 Component 扩展#可能 WeexSDK 内置提供的组件并不能满足你的开发需求，比如需要期望使用地图这样一个复杂的组件，可以通过自定义一个组件，注册到 WeexSDK engine 中， 可以很方便的使用起来。 component 基础生命周期# 新建一个基类为 WXComponent 的 class如果此时我们什么都不做，将改组件注册进 WeexSDK engine，它的功能就跟内置的 div 组件功能是一致的。 覆盖 WXComponent 中的生命周期方法 loadView一个 component 默认对应于一个 view，如果未覆盖 loadView 提供自定义 view, 会使用 WXComponent 基类中的 WXView, WXView 是继承自 UIView 的一个派生 view。要实现地图功能，我们需要对应的地图 view, 比如系统的 MKMapView - (UIView *)loadView &#123; return [MKMapView new];&#125; viewDidLoad 对组件 view 需要做一些配置，比如设置 delegate, 可以在 viewDidLoad 生命周期做，如果当前 view 没有添加 subview 的话，不要设置 view 的 frame，WeexSDK 会根据 style 设置。 - (void)viewDidLoad &#123; ((MKMapView*)self.view).delegate = self;&#125; 注册 component [WXSDKEngine registerComponent:@&quot;map&quot; withClass:[WXMapComponent class]]; 在前端页面直接可以使用 map 标签，如下所示 &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt; 支持自定义事件 给 map 组件支持 mapLoaded 事件 &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\" @mapLoaded=\"onMapLoaded\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; onMapLoaded:function(e) &#123; console.log(\"map loaded\"+JSON.stringify(e)) &#125; &#125;&#125;&lt;/script&gt; 给当前组件添加 BOOL 成员 mapLoaded,记录当前事件是否被添加，当地图加载完成时候，我们可以根据这个判断是否应该发送事件。 覆盖组件生命周期方法添加和移除事件 覆盖 addEvent 和 removeEvent 方法 - (void)addEvent:(NSString *)eventName &#123; if ([eventName isEqualToString:@&quot;mapLoaded&quot;]) &#123; _mapLoaded = YES; &#125;&#125;- (void)removeEvent:(NSString *)eventName&#123; if ([eventName isEqualToString:@&quot;mapLoaded&quot;]) &#123; _mapLoaded = NO; &#125;&#125; 在适宜的时间发事件通知 在 MKMapView 加载完成的 delegate 方法中，发事件通知自定义事件 不要忘记设置 MKMapView 的 delegate. - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView &#123; if (_mapLoaded) &#123; [self fireEvent:@&quot;mapLoaded&quot; params:@&#123;@&quot;customKey&quot;:@&quot;customValue&quot;&#125; domChanges:nil] &#125;&#125; 支持自定义属性 添加自定义属性 showTraffic &lt;template&gt; &lt;div&gt; &lt;map style=\"width:200px;height:200px\" showTraffic=\"true\"&gt;&lt;/map&gt; &lt;/div&gt;&lt;/template&gt; 覆盖组件初始化方法 initWithRef... 当前component 添加 BOOL 成员 showsTraffic，接受保存用户输入值，添加到当前组件上的所有属性都会在初始化方法中 attributes 中传过来，此处我们处理我们感兴趣的属性即可。 - (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if(self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; if (attributes[@&quot;showsTraffic&quot;]) &#123; _showsTraffic = [WXConvert BOOL: attributes[@&quot;showsTraffic&quot;]]; &#125; &#125; return self;&#125; 在 viewDidLoad 中设置该属性 - (void)viewDidLoad &#123; ((MKMapView*)self.view).showsTraffic = _showsTraffic;&#125; 支持属性更新 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;showsTraffic&quot;]) &#123; _showsTraffic = [WXConvert BOOL: attributes[@&quot;showsTraffic&quot;]]; ((MKMapView*)self.view).showsTraffic = _showsTraffic; &#125;&#125; 更多 component 生命周期#native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 component 方法#WeexSDK 0.9.5 之后支持了在 js 中直接调用 component 的方法，自定义完组件后，下面的例子可以指引你完成 component 方法。 自定义一个 WXMyCompoenent 的组件 @implementation WXMyComponentWX_EXPORT_METHOD(@selector(focus)) // 暴露该方法给js- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self;&#125;- (void)focus&#123; NSLog(@&quot;you got it&quot;);&#125;@end 注册组件 [WXSDKEngine registerComponent:@&quot;mycomponent&quot; withClass:[WXMyComponent class]] 在 weex 文件中调用 &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt; 自定义 handler# weexSDK 目前没有提供图片下载的能力，在WXImgLoaderProtocol 定义了一些获取图片的接口, image 组件正是通过 WXImgLoaderProtocol 获得并展示图片，开发者可以实现该 protocol 中的接口方法，这样 image 标签才能正常展示图片。 开发者也可以定义自己的 protocol 和对应的实现来使用 handler 机制 新建基类为 NSObject 的 class 实现 WXImgLoaderProtocol 协议， 实现 WXImgLoaderProtocol 的方法 下面加载图片的逻辑需要依赖 SDWebImage，你也可以不依赖 SDWebimage 使用自己的方式加载对应 URL 图片。 @implementation WXImgLoaderDefaultImpl- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end 注册 handler 你可以通过WXSDKEngine 中的 registerHandler:withProtocol 注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] 使用 handler handler 可以在 native 的 module 或者 component 实现中使用 id&lt;WXImgLoaderProtocol&gt; imageLoader = [WXSDKEngine handlerForProtocol:@protocol(WXImgLoaderProtocol)];[iamgeLoader downloadImageWithURL:imageURl imageFrame:frame userInfo:customParam completed:^(UIImage *image, NSError *error, BOOL finished)&#123;&#125;];","type":"guide"},{"title":"扩展前端框架","path":"cn/guide/extend-js-framework.html","permalink":"https://weex.apache.org/cn/guide/extend-js-framework.html","text":"Weex JS 引擎的特性支持情况 适配 Weex 的初始化入口和多实例管理机制 框架初始化 注册可用的 native 组件和模块 多实例生命周期管理 Native 通信 辅助方法 在 WeexSDK 中配置 JS Framework 准备好你的 JS Framework 代码 注册一个 JS Framework JS Bundle 格式要求 这部分扩展能力还在讨论尝试中，可能随时会有调整，请留意。 Weex 希望能够尊重尽可能多的开发者的使用习惯，所以除了 Weex 官方支持的 Vue 2.0 之外，开发者还可以定制并横向扩展自己的或自己喜欢的 JS Framework。完整一套 JS Framework 的定制和扩展需要以下几个步骤： 首先你要有一套完整的 JS Framework。 了解 Weex 的 JS 引擎的特性支持情况。 适配 Weex 的 native DOM APIs。 适配 Weex 的初始化入口和多实例管理机制。 在 Weex JS runtime 的 framework 配置中加入自己的 JS Framework 然后打包。 基于该 JS Framework 撰写 JS bundle，并加入特定的前缀注释，以便 Weex JS runtime 能够正确识别。 Weex JS 引擎的特性支持情况# 在 iOS 下，Weex 使用的是系统自带的 JavaScriptCore，所以 ES 支持情况取决于操作系统的版本。目前保守判断，ES5 的特性市面上主流的 iOS 设备都是可以完美支持的，但是 ES6+ 的特性存在一定的碎片化。 在 Android 下，Weex 使用的是 UC 提供的 v8 内核，出于体积、性能和稳定性的考虑，我们使用的并不是最新版本的 v8 内核，同样的保守判断，ES5 特性能够全部支持，包括严格模式、Object.freeze 等。 Weex JS 引擎不支持 HTML DOM APIs 和 HTML5 JS APIs，这包括 document, setTimeout 等。 在此基础上，我们加入了 Promise 的 polyfill，以及 console 的 polyfill。 额外的，为了尽可能的确保 JS 引擎的长效内存管理，我们对一个通用的全局对象进行了 Object.freeze() 冻结操作，这包括： Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype 适配 Weex 的初始化入口和多实例管理机制#开发者提供的 JS Framework 最终需要包装成一个 CommonJS 包，并且这个包需要对外暴露以下方法： 框架初始化# init(config) config Document Element Comment TaskSender CallbackManager 该方法会把 Weex 提供的 Native DOM 类和两个辅助类放到 config 参数中，并允许框架本身完成初始化。 小提示：同时，框架作者也能够通过在框架初始化时传入不同的 config 来进行框架的测试或环境模拟。 参数格式介绍# TaskSender: wip… CallbackManager: wip… 注册可用的 native 组件和模块# registerComponents(components) registerModules(modules) 这两个方法会在框架初始化之后立刻调用，这样框架就能够知道当前的客户端支持哪些组件和模块，在一些特殊逻辑或必要的情况下，有机会为框架本身提供参考信息。 参数格式介绍# components: Array: 描述组件的数组，每一项包括： type: string: 组件名称，比如 div。 methods: string[]: 可选项，该组件支持的方法名称列表，这些方法可以遵循 Weex 的 native DOM APIs 的组件方法调用方式。 modules: Object: 描述一系列模块的散列表，每一项的 key 是模块名，每一项的值是一个数组，数组里的每一项描述了一个该模块中的一个方法，该方法的信息包括： name: string: 方法名 args: string[]: 参数个数和类型描述 例如： registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) 多实例生命周期管理# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) 每个 Weex 页面都有被创建、被销毁两个必经阶段，同时在 Weex 页面运行过程中，native 有机会主动向 Weex 页面发送消息，不同的框架可以根据自己框架的设计对这样的消息有自己的理解和设计实现。 参数格式介绍# instanceId: string: 该 Weex 页面的唯一 id，由 native 产生。 code: string: 该 Weex 页面的 JS bundle 的代码，通过 native 传入。 config: Object?: 该 Weex 页面的配置信息，比如代表该 bundle 地址的 bundleUrl，由 native 配置产生，和 JS bundle 本身的内容无关。 data: Object?: Native 有机会在创建一个 Weex 页面的时候，传入一份外部数据，JS 框架也有机会接此机会为相同的 JS bundle 配合不同的 data 生成不同的页面内容。 env: Object?: 当前 Weex 页面的相关环境信息，各字段的含义： info: Object: 框架 info 信息，详见之后的 “JS Bundle 格式要求”。 config: Object: 等同该方法的第三个参数 config。 callbacks: CallbackManager: 该 Weex 页面唯一的 CallbackManager 实例。 created: number: 该 Weex 页面的创建时间毫秒数。 framework: string: 该 Weex 页面基于的框架名，等同于 info.framework。 Native 通信# receiveTasks(instanceId, tasks) Native 除了通过 refreshInstance 方法向 JS 框架层发送消息之外，更多的会通过 receiveTasks 发送用户事件或方法回调给 JS 框架。 比如用户点击了一个按钮，native 就会发送一个 fireEvent 类型的任务给 JS 框架，然后 JS 框架再处理相应的事件逻辑。这部分工作机制和 native DOM 接口中的 addEvent 的设计有关。 再比如用户发起了一个 fetch 网络请求，当请求在 native 端完成时，会以一个 callback 类型的任务发给 JS 框架。由于 native 无法传递 JavaScript 中的 function，所以实际上知会发送一个 callbackId 给 JS 框架。这部分工作机制和之前出现过的 CallbackManager 的设计有关。 辅助方法# getRoot(instanceId): JSON 该方法可以返回文档主体结点的完整 JSON 描述，开发者可以以此查看到完整的 native DOM 树，具体返回值的格式和 native DOM 接口中的 toJSON() 方法返回值格式一致。此功能多用作开发者工具扩展。 在 WeexSDK 中配置 JS Framework#准备好你的 JS Framework 代码#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; 注册一个 JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; 然后打包 JS runtime，集成到 WeexSDK 中。 JS Bundle 格式要求#框架 info 你需要保障基于该 JS Framework 的 JS Bundle 在文件开头带有如下格式的注释，我们称其为框架 info： // &#123; \"framework\": \"Vue\" &#125;... 这样 Weex JS 引擎就会识别出这个 JS bundle 需要用 Vue 框架来解析。并分发给 Vue 框架处理。同理，Weex 支持同时多种框架在一个移动应用中共存并各自解析基于不同框架的 JS bundle。","type":"guide"},{"title":"使用 swift 扩展 iOS 的功能","path":"cn/guide/extend-module-using-swift.html","permalink":"https://weex.apache.org/cn/guide/extend-module-using-swift.html","text":"Swift In Weex#Swift和Objective-C 混编 参考完整 例子 使用 Swift 进行 module 扩展#因为 module 暴露 method 是通过Objective-C宏来做的，调用的时候是通过反射，所以Swift扩展 module 通过extension Objective-C的类。 新建 WXSwiftTestModule.h/m 和 WXSwiftTestModule.swift文件， 在新建Swift文件的时候会提示选择 Create Bridging Header, 因为我们要在 Swift 中访问 Objective-C 的一些类，正是通过这个 header暴露 OC 的类给 Swift,header 格式为 yourTarget-Bridging-Header.h，我这里创建完header文件名称为：WeexDemo-Bridging-Header.h WXSwiftTestModule.h/m中实现 WXSwiftTestModule.h 中 #import &lt;Foundation/Foundation.h&gt;#import &lt;WeexSDK/WeexSDK.h&gt; @interface WXSwiftTestModule : NSObject &lt;WXModuleProtocol&gt; @end WXSwiftTestModule.m 中 WeexDemo-Swift.h 这个文件需要编译一下才可以搜索到，具体的路径 weex/ios/playground/DerivedData/WeexDemo/Build/Intermediates/WeexDemo.build/Debug-iphonesimulator/WeexDemo.build/DerivedSources/WeexDemo-Swift.h 路径具体需要根据自己工程而定 #import &quot;WXSwiftTestModule.h&quot;#import &quot;WeexDemo-Swift.h&quot; // Swift类和方法 被 `Objective-C` 识别需要导入 @implementation WXSwiftTestModule#pragma clang diagnostic push //关闭unknow selector的warrning#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; WX_EXPORT_METHOD(@selector(printSome:callback:)) //Swift 中定义的方法，XCode 转换成的最终的方法名称，在`WeexDemo-Swift.h`里面查看 #pragma clang diagnostic pop @end Swift 中实现扩展 OC 的类 WXSwiftTestModule,增加了一个方法，这个方法就是我们要暴露出来，在 js 中可以调到的 WXSwiftTestModule.swift import Foundationpublic extension WXSwiftTestModule &#123; public func printSome(someThing:String, callback:WXModuleCallback) &#123; print(someThing) callback(someThing) &#125;&#125; `WXSwiftTestModule` 和`WXModuleCallback` 因为是 OC 的，需要在 `WeexDemo-Bridging-Header` 中暴露 WeexDemo-Bridging-Header.h中 //// Use this file to import your target&apos;s public headers that you would like to expose to Swift.//#import &quot;WXSwiftTestModule.h&quot;#import &quot;WeexSDK.h&quot; 至此这个使用 Swift 开发的简单的 module 已经完成 module 使用# 注册 module [WXSDKEngine registerModule:@&quot;swifter&quot; withClass:[WXSwiftTestModule class]]; 前端脚本中用法 &lt;template&gt; &lt;text&gt;Swift Module&lt;/text&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; ready: function() &#123; var swifter = weex.require(&apos;swifter&apos;); swifter.printSome(&quot;https://www.taobao.com&quot;,function(param)&#123; nativeLog(param); &#125;); &#125; &#125;;&lt;/script&gt;","type":"guide"},{"title":"扩展 HTML5 的功能","path":"cn/guide/extend-web-render.html","permalink":"https://weex.apache.org/cn/guide/extend-web-render.html","text":"扩展 Web 端 renderer 的内置组件 扩展内置组件示例 扩展 Web 模块 注册模块 API 格式 注册模块示例 使用模块 Vue.js 本身就是一个独立的前端框架，在浏览器中完全能够不基于 Weex 容器渲染。因此，针对 Weex 平台扩展 Vue.js 的 Web 端组件，和直接使用 Vue.js 开发一个 Web 组件是一样的。具体的组件编写方法可以参考其官方文档：组件 ，另外建议使用 .vue 格式的文件编写组件，使用方法参考：单文件组件。 扩展 Web 端 renderer 的内置组件#Weex 本身提供了很多内置组件和模块，也具备横向扩展的能力，允许开发者自行扩展和定制。需要注意的是，Weex 是一个跨平台的解决方案，扩展其内置组件或模块，需要在三端（Android、iOS、Web）中都有相应的实现。 Weex 将内核切换成 Vue 2.x 之后，在 Web 端扩展 Vue 组件将变得更加容易。 目前我们提供了 weex-vue-render 作为 Vue 2.x Web 端的渲染器。首先引入该库到你的项目里，然后你就可以使用 weex.registerComponent 来进行内置组件扩展了，也可以使用 Vue.component，两者基本上是一致的。 扩展内置组件示例#以扩展 &lt;sidebar&gt; 为例，首先应该编写组件自身的逻辑： &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; 然后在使用之前，全局注册 &lt;sidebar&gt; 组件： import Vue from 'vue'import weex from 'weex-vue-render'import Sidebar from './path/to/sidebar.vue'weex.init(Vue)// 全局注册 sidebar 组件weex.registerComponent('sidebar', Sidebar)// 或者使用 Vue.componentVue.component('sidebar', Sidebar) 在扩展 Weex 组件时，如果只使用了 Weex 提供的内置组件，并且使用的都是 Weex 支持的样式，那么就和普通的自定义组件无异，不需要 Native 端再有相应的实现。 如果你定制组件时不得不用到目前 Weex 不支持的标签和样式，在这种情况下才是真正的“扩展”了 Weex 的组件，你还需要在 Android 和 iOS 中有相应的实现，不然会导致渲染异常。 扩展 Web 模块#除了通用组件以外，Weex 还有提供了通用的模块，可以方便的调用原生 API。通常来说，注册 Weex 模块要求三端都得有相应的实现，否则会影响其正常的使用。 注册模块#如果你引入了 weex-vue-render 这个库，那么在全局能获取到 weex 这个变量，其中提供了 registerModule 方法可以注册模块。 API 格式# registerModule name: {String} 必选，模块名称。 define: {Object} 必选，模块的定义。 meta: {Object} 可选，如果你需要将非 iterable 的属性或方法注册到模块对象里，你才需要用到这个参数，将 { registerType: &#39;assignment&#39; } 作为 meta 参数传入即可。 注册模块示例#下边的代码注册了一个名为 guide 的模块： weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) 使用模块#在 weex 上提供了 require 方法用于获取已注册的模块，直接传递模块名即可： // 获取模块const guide = weex.requireModule('guide')// 可以直接调用模块中的方法guide.greeting()guide.farewell() 上述模块使用方法在 Native 环境中依然有效，只不过模块中的方法是由 Native 提供的。","type":"guide"},{"title":"前端框架","path":"cn/guide/front-end-frameworks.html","permalink":"https://weex.apache.org/cn/guide/front-end-frameworks.html","text":"Weex 中的前端框架 Vue.js Rax Weex 中的前端框架# 前端技术看起来很繁荣，测试、打包、调试等工具都比较丰富，开发效率比原生开发要高很多。在大型项目中使用前端框架也是一个管理应用好方法，这样更方便于长期维护。 然而，Weex并不是一个前端框架。实际上，前端框架仅仅是 Weex 的语法层或称之为 DSL (Domain-specific Language)，它们与原生渲染引擎是分离的。换句话说，Weex 并不依赖于特定的前端框架，随着前端技术的发展，Weex 也可以集成更多广泛使用的前端框架。 目前 Weex 主要支持 Vue.js 和 Rax 作为其内置的前端框架。这些框架已经集成到了 Weex SDK，你不需要在额外引入。 学习一些 Vue 和 Rax 的基础知识，对使用 Weex 非常有帮助。 Vue.js#Weex 从 v0.10.0（发布于 2017/02/17）这个版本开始，就集成了 v2 版本的 Vue.js。Vue.js 是一套用于构建用户界面的渐进式框架，详情请参阅其官方网站。 关于在 Weex 中使用 Vue 的技巧请参阅：《使用 Vue》。 Rax#Rax 是一个兼容 React 接口的前端框架，请参考 Rax 的官方网站 来获得更多信息。","type":"guide"},{"title":"集成 Devtools 到 iOS","path":"cn/guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-ios.html","text":"概要 iOS 应用接入DevTool 添加依赖 方法1: cocoapods 依赖 方法二：github 源码依赖 集成功能 附加页面刷新功能 和DebugServer配合使用 环境准备 概要#Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入DevTool 和Debug Server 配合使用 iOS 应用接入DevTool#添加依赖#建议在DEBUG模式下依赖 方法1: cocoapods 依赖#在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.15.3&apos;, :configurations =&gt; [&apos;Debug&apos;]， 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 方法二：github 源码依赖# git clone git@github.com:weexteam/weex-devtool-iOS.git 如下图示：拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网 App 研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能#参考PlayGround中的实现 //方法1 pod依赖方式#import &lt;TBWXDevtool/WXDevtool.h&gt;//方法2 源码依赖方式#import &quot;WXDevtool.h&quot; 查看 WXDevtool 头文件如下： @interface WXDevTool : NSObject+ (void)setDebug:(BOOL)isDebug;+ (BOOL)isDebug;+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end setDebug：参数为 YES 时，直接开启 debug 模式，反之关闭，使用场景如下所述 在你自己的程序中添加如下代码： [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能# 为什么需要页面刷新功能？ 如下图所示，当点击 debugger 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debugger 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 具体实现可参考 playground WXDemoViewController.m 文件 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 和DebugServer配合使用#环境准备#首先，需要安装 Debugger Server,详情请查看 《Get started》 npm install -g weex-toolkit 运行命令启动 DebugServer weex debug``` 页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接## 部分功能展示1. 日志级别控制 ![_](http://img.alicdn.com/tps/TB1F8WONXXXXXa_apXXXXXXXXXX-1706-674.png) 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0, Error = Error Warning = Error | Warning, Info = Warning | Info, Log = Log | Info, Debug = Log | Debug, All = NSUIntegerMax ` 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"guide"},{"title":"集成 Devtools 到 Android","path":"cn/guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-android.html","text":"Android 应用接入 添加依赖 添加 Debug 模式开关 接入示例 牛刀小试 前置工作 开始调试 背景知识 Devtools 组件介绍 FAQ 注入自定义WebSocket Client Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入#添加依赖#可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:$&#123;version&#125;'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容# weex sdk weex inspector Debugger Server 0.13+ 0.12+ 0.2.39+ 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 0.16.0+ 0.12.1 - 0.17.0+ 0.13.2 - 添加 Debug 模式开关#控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 更详细和合适的位置,初始化 inspector 的方法请参考 Playground. private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用WXSDKEngine.reload()`。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例#最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含 DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试#前置工作#如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug,最新的版本我们建议您使用 weex debugx 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get Started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试#如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下# 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识#Devtools 组件介绍#Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ#在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。 注入自定义WebSocket Client#目前Inspector以反射的方式动态调用了okhttp-ws库中的相关代码，可以兼容的okhttp与okhttp-ws版本为： okhttp, okhttp-ws 2.7.5版本以下 okhttp3, okhttp3-ws 3.5版本以下 如果客户端中集成的版本与上述版本不匹配，则可以使用WeexInspector.overrideWebSocketClient方法来注入自定义的WebSocket实现，示例：public class CustomWebSocketClient implements IWebSocketClient &#123; private WebSocket ws; @Override public boolean isOpen() &#123; return ws != null; &#125; @Override public void connect(String wsAddress, final WSListener listener) &#123; OkHttpClient okHttpClient = new OkHttpClient(); okHttpClient.setConnectTimeout(5, TimeUnit.SECONDS); okHttpClient.setReadTimeout(5, TimeUnit.SECONDS); okHttpClient.setWriteTimeout(5, TimeUnit.SECONDS); Request request = new Request.Builder().url(wsAddress).build(); WebSocketCall webSocketCall = WebSocketCall.create(okHttpClient, request); webSocketCall.enqueue(new WebSocketListener() &#123; @Override public void onOpen(WebSocket webSocket, Request request, Response response) throws IOException &#123; ws = webSocket; listener.onOpen(); &#125; @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException &#123; if (WebSocket.PayloadType.TEXT == type) &#123; listener.onMessage(payload.readUtf8()); &#125; &#125; @Override public void onPong(Buffer payload) &#123; //ignore &#125; @Override public void onClose(int code, String reason) &#123; listener.onClose(); &#125; @Override public void onFailure(IOException e) &#123; listener.onFailure(e); &#125; &#125;); &#125; @Override public void close() &#123; if (ws != null) &#123; try &#123; ws.close(CloseCodes.NORMAL_CLOSURE, \"Normal closure\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void sendMessage(int requestId, String message) &#123; if (ws != null) &#123; try &#123; ws.sendMessage(WebSocket.PayloadType.TEXT, new Buffer().writeString(message, Charset.defaultCharset())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","type":"guide"},{"title":"集成 Weex 到已有应用","path":"cn/guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/cn/guide/integrate-to-your-app.html","text":"集成到 Android Android 集成有两种方式 前期准备 快速接入 源码依赖(IDE Android Studio) 集成到 iOS 通过 CocoaPods 或者 Carthage 集成 Weex iOS SDK到你的项目 导入 Weex SDK framework 到工程 集成到 Android#注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式# 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备# 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入#如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现#注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio)# 下载源码 git clone https://github.com/apache/incubator-weex.git 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录#Native WXSample地址https://github.com/apache/incubator-weex/tree/master/android/playground/apphttps://github.com/apache/incubator-weex/tree/master/ios/playground Vue Examples 地址：http://weex-project.io/examples.html 集成到 iOS#通过 或者 集成 Weex iOS SDK到你的项目#首先假设你已经完成了安装 iOS 开发环境 和 CocoaPods(或者Carthage) 第一步：添加依赖#导入 Weex iOS SDK 到你已有的项目, 如果没有，可以参考新建项目。在继续下面内容之前，确保你已有的项目目录有名称为 Podfile 文件，如果没有，创建一个，用文本编辑器打开(如果使用 Carthage ，请确保已有项目目录下存在 Cartfile)。选择其中一个集成方法就可以。 添加依赖 使用CocoaPodsWeexSDK 在 cocoaPods 上最新版本 可以在这获取 在 Podfile 文件中添加如下内容 source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.17.0&apos; ## 建议使用WeexSDK新版本end 打开命令行，切换到你已有项目 Podfile 这个文件存在的目录，执行 pod install，没有出现任何错误表示已经完成环境配置。 使用 Carthage 可以在这查询到当前最新的版本。在 Cartfile 中添加如下内容github &quot;apache/incubator-weex&quot;在包含 Cartfile 文件目录的终端中执行 carthage update。添加 framework 到你的工程 第二步：初始化 Weex 环境#在 AppDelegate.m 文件中做初始化操作，一般会在 didFinishLaunchingWithOptions 方法中如下添加。 //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk environment[WXSDKEngine initSDKEnvironment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level[WXLog setLogLevel: WXLogLevelAll]; 第三步：渲染 weex Instance#Weex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 Weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController。 #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如 renderWithURL, onCreate, onFailed 等，可以参见 WXSDKInstance.h 的声明。 第四步：销毁 Weex Instance# 在 viewController 的 dealloc 阶段 销毁掉 Weex instance，释放内存，避免造成内存泄露。 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework 到工程# 可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature。 使用 git clone WeexSSH git clone git@github.com:apache/incubator-weex.git 或者 https git clone https://github.com/apache/incubator-weex.git 打开 WeexSDK.xcodeproj in weex/ios/sdk切换到如下图所示 target 编译当前target，可以直接用快捷键 ⌘ + b 最后找到产物在 weex/ios/sdk/Products 目录 导入 framework 到自己工程 需要添加如下图系统依赖 添加 -ObjC 到工程设置中 添加 js-framework 到自己的 main bundle, js-framework 的位置在 WeexSDK.framework 中，文件名称为 native-bundle-main.js","type":"guide"},{"title":"搭建开发环境","path":"cn/guide/set-up-env.html","permalink":"https://weex.apache.org/cn/guide/set-up-env.html","text":"第一步：安装依赖 第二步：初始化 第三步：开发 使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本节会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖#Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试。首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.11.3$ npm -v3.10.10 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 注意: 在weex-toolkit1.0.8\b版本后添加了npm5规范的npm-shrinkwrap.json用于锁定包依赖，故npm版本&lt;5的用户需要通过npm i npm@latest -g更新一下npm的版本，使用前请确认版本是否正确。 $ npm install -g weex-toolkit$ weex -v //查看当前weex版本 weex-toolkit也支持直接升级子依赖，如：weex update weex-devtool@latest //@后标注版本后，latest表示最新 国内开发者可以考虑使用淘宝的 npm 镜像 —— cnpm 安装 weex-toolkit $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第二步：初始化#然后初始化 Weex 项目： $ weex create awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 第三步：开发#之后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启HotReload服务器，代码改动的将会实时同步到网页中 我们先通过 npm install 安装项目依赖。之后运行根目录下的 npm run dev &amp; npm run serve 开启 watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 weex h5 页面。 初始化时已经为我们创建了基本的示例，我们可以在 src/index.vue 中查看。 代码如下所示： &lt;template&gt; &lt;div class=\"wrapper\" @click=\"update\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;text class=\"desc\"&gt;Now, let's use vue to build your weex app.&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; padding-top:40px; padding-bottom: 40px; font-size: 48px; &#125; .logo &#123; width: 360px; height: 156px; &#125; .desc &#123; padding-top: 20px; color:#888; font-size: 24px;&#125;&lt;/style&gt;&lt;script&gt; export default &#123; data: &#123; logoUrl: 'http://img1.vued.vanthink.cn/vued08aa73a9ab65dcbd360ec54659ada97c.png', target: 'World' &#125;, methods: &#123; update: function (e) &#123; this.target = 'Weex' console.log('target:', this.target) &#125; &#125; &#125;&lt;/script&gt; 关于 Weex 语法部分，你可以直接参考 Vue Guide，这里不再重复介绍。如果您想了解有关技术详情的更多信息，请继续阅读下一节。并且不要忘记在 dotWe 写代码并随时预览。","type":"guide"},{"title":"在 Weex 中使用 Vue.js","path":"cn/guide/use-vue.html","permalink":"https://weex.apache.org/cn/guide/use-vue.html","text":"只含有运行时的构建版本 平台的差异 上下文 DOM 样式 事件 Web 渲染器 单文件组件 编译目标 使用weex-loader 支持的功能 全局配置 全局 API 选项 生命周期钩子 实例属性 实例方法 模板指令 特殊属性 内置组件 自2016年2月17日发布 WeexSDK v0.10.0 后， Weex 集成了 v2 版本的 Vue。Vue（读音 /vjuː/，类似于 view 的读音）是一套构建用户界面的渐进式框架。详情请参阅其官方网站。 如果没有特别指示，文章中的 “Vue.js” 或者 “Vue” 都指的是 v2 版本的 Vue。 只含有运行时的构建版本#如果你熟悉 Vue.js，你应该知道 Vue.js 有两种构建版本: 运行时 + 编译器 与 只包含运行时。它们之间的区别在于编译器是否需要能够在运行时编译template选项。由于运行时构建版本比完整版本的构建版本轻约30%，为了更好的性能和更少的代码尺寸，Weex用的是只包含运行时的方式构建Vue。 具体来说，差异如下： 定义组件时不支持template选项。 不支持使用x-templates。 不支持使用Vue.compile。 平台的差异#Vue.js最初是为Web平台设计的。虽然可以基于Weex开发原生应用程序，但是仍然存在许多Weex 与 Web 平台的差异。 与 Web 平台的主要差异是: 上下文、DOM、样式和事件。 上下文#Weex 主要用于编写多页的应用程序，每一页相当于原生开发中的 View 或者 Activity，并且它有着自己的上下文。尤其Vue实例在每个页面都是不同的，甚至 Vue 的”全局”配置（Vue.config.xxx）也只会影响 Weex 上的单个页面。 在此基础上，一些 Vue 的 SPA （单页面应用）技术，如 Vuex 和 vue-router 也将单页内生效。更通俗地说，“页面”概念在 SPA 技术中是虚拟的，但在 Weex 上却是真实的。 无论如何，Vuex 和 vue-router 都是独立的库，它们都有自己的概念和使用场景，你仍然可以在 Weex 里使用 Vuex 和 vue-router。 DOM#因为在 Android 和 iOS 上没有 DOM（Document Object Model），如果你要手动操作和生成 DOM 元素的话可能会遇到一些兼容性问题。在你使用现代前端框架的情况下，操作数据与组件而不是生成的元素是一个比较好的做法。 一些与 DOM 相关的特性，比如 v-html，vm.$el，template 选项，在不同的平台上可能无法获得相同的反应。 准确来说，vm.$el属性类型在web环境下是HTMLElement，但是在移动端并没有这个类型。实际上，它是一个由 Weex 文档对象模型 定义的特殊数据结构。 样式#样式表和 CSS 规则是由 Weex js 框架和原生渲染引擎管理的。要实现完整的 CSS 对象模型（CSSOM：CSS Object Model）并支持所有的 CSS 规则是非常困难的，而且没有这个必要。 出现性能考虑，Weex 目前只支持单个类选择器，并且只支持 CSS 规则的子集。详情请参阅 通用样式 与 文本样式。 在 Weex 里， 每一个 Vue 组件的样式都是 scoped。 事件#目前在 Weex 里不支持事件冒泡和捕获，因此 Weex 原生组件不支持事件修饰符，例如.prevent，.capture，.stop，.self 。 此外，按键修饰符以及系统修饰键 例如 .enter，.tab，.ctrl，.shift 在移动端基本没有意义，在 Weex 中也不支持。 Web 渲染器#如果你想在网络上呈现你的页面，你需要 weex-vue-render 来实现它。 weex-vue-render是 Vue DSL 的 Web 渲染器， 它在 Web 上实现了 Weex 的内置组件和内置模块。详情请参阅这里。 单文件组件#Vue 中的单文件组件（即*.vue文件）是一种特殊的文件格式，扩展名为.vue。这个模板会在构建时便于到render函数里。 此外，所有的编辑器里都支持一个好的语法高亮插件。 在 Weex 中使用单个文件组件语法是一种很好的做法。 编译目标#因为平台的差异以及为了提高网络性能，*.vue文件需要用两种不同的方式来编译： 对于 Web 平台来说，你可以用任何正式的方式来编译源文件，例如 使用 Webpack + vue-loader 或者 Browserify + vueify 来编译*.vue文件。 对于安卓与 iOS 平台来说， 你需要使用 weex-loader 来编译*.vue文件。 不同的平台使用不同的bundles，可以充分利用平台原有的特性，减少构建时的兼容性代码。但是源代码仍然是一样的，唯一的区别是编译它的方法。 使用weex-loader#weex-loader 是一个 webpack 的 loader，它能把*.vue文件转化为简单的javascript 模块用于安卓以及 iOS 平台。所有的特性和配置都是跟 vue-loader 一样的。 需要注意的是，如果您的Webpack配置的entry选项是一个*.vue文件的话，你仍需要传递一个额外的entry参数。 const webpackConfig = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true' /* ... */ use: &#123; loaders: [&#123; // matches the .vue file path which contains the entry parameter test: /\\.vue(\\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;&#125; 如果你现在用的是.js文件做入口文件，你不需要写那些额外的参数。推荐 webpack 配置的入口文件使用 javascript 文件。 &#123; entry: './path/to/entry.js'&#125; 支持的功能#全局配置# Vue “全局”配置只会影响 Weex 上的单一页面，配置不会在不同的 Weex 页面之间共享。 Vue 全局配置 是否支持 说明 Vue.config.silent 支持 - Vue.config.optionMergeStrategies 支持 - Vue.config.devtools 不支持 只在 Web 环境下支持 Vue.config.errorHandler 支持 - Vue.config.warnHandler 支持 - Vue.config.ignoredElements 支持 不推荐 Vue.config.keyCodes 不支持 在移动端无用 Vue.config.performance 不支持 与 devtools 一样 Vue.config.productionTip 支持 - 全局 API# Vue 全局 API 是否支持 说明 Vue.extend 支持 - Vue.nextTick 支持 - Vue.set 支持 - Vue.delete 支持 - Vue.directive 支持 - Vue.filter 支持 - Vue.component 支持 - Vue.use 支持 - Vue.mixin 支持 - Vue.version 支持 - Vue.compile 不支持 Weex 用的是 只包含运行时构建 选项# Vue 选项 是否支持 说明 data 支持 - props 支持 - propsData 支持 - computed 支持 - methods 支持 - watch 支持 - el 支持 在移动端el的值是无意义的 template 不支持 Weex 用的是 只包含运行时构建 render 支持 不推荐 renderError 支持 - directives 支持 - filters 支持 - components 支持 - parent 支持 不推荐 mixins 支持 - extends 支持 - provide/inject 支持 不推荐 name 支持 - delimiters 支持 不推荐 functional 支持 - model 支持 - inheritAttrs 支持 - comments 不支持 - 生命周期钩子#Vue 组件的实例生命周期钩子将在特定的阶段发出，详情请参考 Vue 组件的生命周期图示。 Vue 生命周期钩子 是否支持 说明 beforeCreate 支持 - created 支持 - beforeMount 支持 - mounted 支持 和 Web 端不完全一样（Weex 里并没有真实 DOM） beforeUpdate 支持 - updated 支持 - activated 不支持 不支持&lt;keep-alive&gt; deactivated 不支持 不支持&lt;keep-alive&gt; beforeDestroy 支持 - destroyed 支持 - errorCaptured 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 实例属性# Vue 实例属性 是否支持 说明 vm.$data 支持 - vm.$props 支持 - vm.$el 支持 移动端没有HTMLElement vm.$options 支持 - vm.$parent 支持 - vm.$root 支持 - vm.$children 支持 - vm.$slots 支持 - vm.$scopedSlots 支持 - vm.$refs 支持 - vm.$isServer 支持 永远是false vm.$attrs 支持 - vm.$listeners 支持 - 实例方法# Vue 实例方法 是否支持 说明 vm.$watch() 支持 - vm.$set() 支持 - vm.$delete() 支持 - vm.$on() 支持 - vm.$once() 支持 - vm.$off() 支持 - vm.$emit() 支持 - vm.$mount() 不支持 你不需要手动安装 Vue 实例 vm.$forceUpdate() 支持 - vm.$nextTick() 支持 - vm.$destroy() 支持 - 模板指令# Vue 指令 是否支持 说明 v-text 支持 - v-html 不支持 Weex 中没有 HTML 解析器，这不是很好的实现 v-show 不支持 不支持 display: none; v-if 支持 - v-else 支持 - v-else-if 支持 - v-for 支持 - v-on 支持 不支持事件修饰符 v-bind 支持 - v-model 支持 - v-pre 支持 - v-cloak 不支持 只支持单类名选择器 v-once 支持 - 特殊属性# Vue 特殊属性 是否支持 说明 key 支持 - ref 支持 - slot 支持 - slot-scope 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 scope 支持 不推荐 is 支持 - 内置组件# Vue 内置组件 是否支持 说明 component 支持 - transition 不支持 在移动端 enter 与 leave 的概念可能有点不同， 并且 Weex 不支持display: none; transition-group 不支持 跟 transition 一样 keep-alive 不支持 移动端的原生组件不能被前端缓存 slot 支持 -","type":"guide"},{"title":"Android APIs","path":"cn/references/android-apis.html","permalink":"https://weex.apache.org/cn/references/android-apis.html","text":"Android APIs#Weex 初步接入请参考：https://github.com/weexteam/article/issues/25 WXSDKEngine#WXSDKEngine 是 Weex 对外的总入口。主要提供了一下功能： 注册自定义 module 和 component 设置相关 adapter 和获取 adapter。 注册自定义 module 和 component#\bcomponent#Weex提供多种\b注册 Component的方式，其中效率最高的为 public static boolean registerComponent(IFComponentHolder holder, boolean appendTree, String ... names) holder 为一个抽象\b\b工厂，用于创建component，可使用 SimpleComponentHolder 来快速的构建该对象。\b appendTree 为一个扩展标记位，目前暂无意义。 names 表示该 component 在前端代码中名称，可把多个前端组件\b映射成一个 component 。 module#Weex 提供如下注册 Module 的方式： public static &lt;T extends WXModule&gt; boolean registerModule(String moduleName, Class&lt;T&gt; moduleClass,boolean global) throws WXException moduleName 前端代码中module的名称 moduleClass \bmodule对应的\bClass，需要提供一个不含参数的构造函数，或\b使用默认构造函数。 global\b 是否为全局唯一，true 为全局唯一，false 表示和\b WXSDKInstance 绑定。 Adapter 介绍#\b第三方 App 可能需要实现下述的 Adapter，才能完整的使用Weex的能力。 图片适配器#Weex 图片适配器负责根据URL，加载对应的图片，图片适配器分为两种： 将 URL 对应的图片加载到 View\b 上 将 URL 对应的图片加载到 Drawable 对象上。 第一种图片适配器是必须实现，第二种图片适配器是可选实现。Weex对于这两种图片适配器均没有默认实现。 IWXImgLoaderAdapter#Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。 接口定义如下： public interface IWXImgLoaderAdapter { void setImage(String url, ImageView view, WXImageQuality quality,WXImageStrategy strategy); } WXImageQuality 表示图片的质量，WXImageQuality 取如下值 LOW, NORMAL, HIGH, ORIGINAL 图片质量依次变高。默认为 LOW。 WXImageStrategy 为扩展类，表示了图片是否可以裁剪 (isClipping) 锐化 (isSharpen) 占位符 (placeHolder) 等。 IDrawableLoader#Weex 会把需要设置图片的 对象(DrawableTarget) 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。 接入者需要实现DrawableTarget这个类，并实现 void setDrawable(String url, DrawableTarget drawableTarget, DrawableStrategy drawableStrategy); DrawableTarget 表示待加载的对象，需要是StaticTarget或AnimatedTarget中的一个。 IWXHttpAdapter 网络下载适配器#Weex 自定义了 WXRequest 和 OnHttpListener，Native 重载接口后可以从 Request 中获取URL，Header 等参数，网络请求完成后可以通过 OnHttpListener 进行回调通知。Weex 提供了默认网络请求：DefaultWXHttpAdapter， 使用的是 HttpURLConnection 进行网络请求。 接口定义如下： public interface IWXHttpAdapter { void sendRequest(WXRequest request, OnHttpListener listener); } WXRequest 定义了网络请求相关的参数，请求方法，请求主体，超时时间。Weex默认超时时间是3000. OnHttpListener 定义了网络请求结束后对应方法。定义如下： interface OnHttpListener { /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response); } IWXUserTrackAdapter 埋点适配器#接口定义： public interface IWXUserTrackAdapter { void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params); } Native 实现接口后可以通过 WXPerformance 和 params 获取对应的信息。 WXPerformane 对应字段表示含义请参考文档：https://github.com/weexteam/article/issues/124 后续随着开发 Weex 还会定义更多的 Adapter，此文档也会定时更新。 IActivityNavBarSetter Weex导航适配器#Weex 提供了 WXNavigatorModule 进行导航控制，对应的方法可以通过设置 IActivityNavBarSetter 接口进行定制。 使用方法: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){}); IWXStorageAdapter#Weex提供了WXStorageModule将一些数据存储到本地，WXStorageModule\b依赖IWXStorageAdapter来操作本地存储系统。 Weex提供了一\b个默认的实现，DefaultWXStorage。 IWXJSExceptionAdapter#Weex依赖IWXJSExceptionAdapter来实现JavaScript异常的处理，默认行为是忽略JavaScript异常。 WXSDKInstance#Weex 中 Native 和 JS 通信#自定义事件通知#多用于某个自定义控件进行事件通知，例如自定义点击事件，响应下拉事件等。 WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges){ } public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data){ fireEvent(elementRef,type,data,null); } public void fireEvent(String elementRef, String type){ fireEvent(ref,type,new HashMap&lt;String, Object&gt;()); } elementRef：事件发生的控件 ID。 type: 自定义事件，Weex 默认以 onXxxxx 开头为自定义事件。onPullDown (下拉事件)。 data: 需要透出的参数，例如当前控件的大小，坐标等其他信息。 domChanges：更新 ref 对应控件的 Attribute 和 Style。 事件回调#多用于 Module 回调，例如定位 Module 完成后需要通知 JS。使用方法如下： public class WXLocation extends WXModule { @JSMethod public void getLocation(JSCallback callback){ //获取定位代码..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(&quot;x&quot;,&quot;x&quot;); data.put(&quot;y&quot;,&quot;y&quot;); //通知一次 callback.invoke(data); //持续通知 callback.invokeAndKeepAlive(data); //invoke方法和invokeAndKeepAlive两个方法二选一 } Weex 和其他 Native 组件通讯#注册滑动事件#Weex 获取滑动事件可以通过 WXSDKInstance 注册 registerOnWXScrollListener 监听 接口定义如下： public interface OnWXScrollListener { /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view&apos;s scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState); } 其他介绍#动态适配容器#因为 Android 手机的碎片化导致屏幕适配很困难。Weex 对外提供的接口 render 需要动态传入容器的宽高，但是传入的宽高有时会发生变化，例如 ActionBar 隐藏等，这是传入的 Weex 容器也要进行对应的变化。为了适应这种变化，Weex 提供了接口 WXSDKInstance.setSize(int width, int height) 来改变容器的大小。 /** * * @param width 容器宽度 * @param height 容器高度 */ public void setSize(int width, int height){}; 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 IWXRenderListener 中的 onException 方法进行处理，如果是主动降级 errCode 是以“|”分割的字符。“|”前面的字符为1表示主动降级，Native 端可以跳转到对应的 H5 页面。或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"BroadcastChannel","path":"cn/references/broadcast-channel.html","permalink":"https://weex.apache.org/cn/references/broadcast-channel.html","text":"API 通信过程 使用范例 注意事项 BroadcastChannel 接口在 v0.9+ 及以上的版本中可用。 在 JS 执行环境中提到过，不同的 Weex 页面使用的是不同的执行环境，即使全局变量也是互相隔离的，然而使用 BroadcastChannel 是可以实现跨页面通信的。 API# BroadcastChannel 是 W3C 规范中的一部分，其中依赖的 MessageEvent 对象也是。 BroadcastChannel 的构造函数只接受一个参数，那就是“频道名称”（channel name）。 const jb = new BroadcastChannel('007') BroadcastChannel 接口的定义如下： declare interface BroadcastChannel = &#123; name: string, postMessage: (message: any) =&gt; void; onmessage: (event: MessageEvent) =&gt; void; close: () =&gt; void;&#125; name: 监听的频道名称，用来区分不同的频道（跨频道不可通信）。 postMessage: 用于在当前频道中广播消息。 onmessage: 消息事件的处理函数。在频道中接收到广播消息之后，会给所有订阅者派发消息事件。 close: 关闭当前频道。 消息对象（MessageEvent）的类型定义如下： declare interface MessageEvent = &#123; type: string, // \"message\" data: any&#125; 通信过程# 就像使用无线电一样，每个页面通过创建一个具有相同频道名称的 BroadcastChannel 对象来加入特定频道。 然后实现 onmessage 接口来监听消息事件。通过调用 BroadcastChannel 对象上的 postMessage() 方法可以在频道中广播一条消息给所有订阅者。 事实上，这是在特定频道的所有用户之间的全双工（双向）通信，每个订阅者都可以在频道中彼此收发任何消息，即使消息的发送者也能收到自己发出的消息事件。不同频道之间的通信过程是不会互相影响的。 调用 BroadcastChannel 对象的 close() 方法可以离开一个频道，这个方法只关闭自己，并不影响其他订阅者。当某个 Weex 页面被销毁时，其中的所有订阅者将在 destroyInstance 中强制关闭。如果某个频道的所有用户都关闭了，这个频道对象将会被销毁，所占内存页能被回收。 使用范例#在页面 A 中： const Steve = new BroadcastChannel('Avengers')Steve.postMessage('Assemble!') 在页面 B 中： const Hulk = new BroadcastChannel('Avengers') 在页面 C 中： const Stark = new BroadcastChannel('Avengers')Stark.onmessage = function (event) &#123; console.log(event.data) // Assemble! Stark.postMessage('I am Tony and I am leaving now.')&#125; 页面 A 、B 、C 都创建一个监听了 &#39;Avengers&#39; 频道的 BroadcastChannel 对象，它们可以用这个对象实现互相通信。 当 Steve 发布了 &#39;Assemble!&#39; 消息时，Stark 将收到一个消息事件，其 data 字段等于 &#39;Assemble!&#39;，然后也向频道中回复一条消息。但是 Hulk 并不会收到这些消息，因为他没有实现onmessage 方法，相当于没有接收频道中的消息，所以他实际上不是一个订阅者。 注意事项# 消息事件中的对象并没有深度复制。（这个特性可能会修改） 在页面 A 中： const a = new BroadcastChannel('app')const list = ['A', 'B']a.postMessage(&#123; list &#125;) 在页面 B 中： const b = new BroadcastChannel('app')b.onmessage = function (event) &#123; // the `event.data.list` is a reference of `list` in page A event.data.list.push('C')&#125; 在这个例子中，页面 B 中的 event.data.list 实际上是页面 A 中 list 对象的引用。在页面 B 中给列表添加一项 &#39;C&#39;，也将影响到页面 A 中的 list 对象。 相比于深度复制，这个行为可以减少页面中的内存消耗。开发者在使用时不应该存储或修改 event 对象。","type":"references"},{"title":"iOS APIs","path":"cn/references/ios-apis.html","permalink":"https://weex.apache.org/cn/references/ios-apis.html","text":"iOS APIs#Native 对外接口# 注册 SDK 默认的 Module、Handler 和 Component 注册自定义 module、Handler 和 Component 重置 JSFramework Handler (对应于 Android 的 Adapter) 介绍# WXImgLoaderDefaultImpl 图片下载 handler。Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。WeexSDK kernel 本身没有提供图片下载的默认实现。 接口定义如下： @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native 和 JS 通信# 自定义通知事件 用于 native 自定义部分和 js 进行实践通知，比如传递下拉事件到 js，这个是在 component 基类的方法，可以直接使用 /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName 事件名称，可以在weex文件某个标签组件监听，命名规范为 onXXX * @param params 数据 * @param domChanges 发生改变的数据 **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges 事件回调 多用于 Module 回调结果给 js，回调类型分为下面两种： WXModuleCallback 为了性能考虑，该回调只能回调通知js一次，之后会被释放，多用于一次结果 WXModuleKeepAliveCallback 该回调可以设置是否为多次回调类型，多次回调的场景如持续监听位置的变化，并返回给 js。 @implementation WXEchoModule@synthesize weexInstance; // 让该module 获得当前instanceWX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);// 此处设置true，该回调function 可以多次回调执行，可以写循环测试.&#125; 动态适配容器#WeexSDK 在 WXSDKInstance 类中提供了方法 setFrame(CGRect) 来改变容器的大小。 如：在导航栏从有到无过程，需要 weexView 的变化， 可以在此时 native 调用该方法设置 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 WXSDKInstance 中的 onFailed 回调进行处理，如果是主动降级则返回的错误 domain 为 TemplateErrorType，Native 端可以跳转到对应的 H5 页面，或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"JS Service","path":"cn/references/js-service.html","permalink":"https://weex.apache.org/cn/references/js-service.html","text":"JS Service#v0.9.5+ JS service 和 Weex 实例在 JS runtime 中并行运行。Weex 实例的生命周期可调用 JS service 生命周期。目前提供创建、刷新、销毁生命周期。 重要提醒: JS Service 非常强大但也很危险，请小心使用！ 注册 JS Service#iOS#[WXSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;];// or[WXSDKEngine registerService:@&quot;SERVICE_NAME&quot; serviceScriptUrl: @&quot;SERVICE_JS_URL&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; 编写一个 JS service#service.register(SERVICE_NAME /* same string with native */, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: fucntion() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"Weex 实例变量","path":"cn/references/weex-variable.html","permalink":"https://weex.apache.org/cn/references/weex-variable.html","text":"属性和方法 weex.config Weex 环境变量 weex.document weex.requireModule 使用原生模块 weex.supports 使用范例 weex.isRegisteredModule weex.isRegisteredComponent 每个 Weex 页面的 JS 上下文中都有一个相互独立的 weex 变量，它可以像全局变量一样使用，不过它在不同页面中是隔离而且只读的。 注意： weex 实例变量只在 Vue 框架中暴露了，目前还不支持在 Rax 框架中使用。 属性和方法#Weex 实例变量的类型定义如下： declare type Weex = &#123; config: WeexConfigAPI; document: WeexDocument; requireModule: (name: string) =&gt; Object | void; supports: (condition: string) =&gt; boolean | void;&#125; weex.config#该变量包含了当前 Weex 页面的所有环境信息。 declare type WeexConfigAPI = &#123; bundleUrl: string; bundleType?: string; env: WeexEnvironment;&#125; bundleUrl: 当前页面 js bundle 的 URL 地址。 bundleType: v0.17+ 页面 js bundle 的类型，它表示的是当前页面是用那种框架开发的，可以是 &quot;Vue&quot; 或者 &quot;Rax&quot;。 env: Weex 环境变量。 Weex 环境变量#有时候为了兼容性或者为了增强某个端上的能力，需要编写平台特异的代码。 Weex 提供了 weex.config.env 和全局的 WXEnvironment 变量（它们是等价的）来获取当前执行环境的信息。 weex.config.env === WXEnvironment Weex 环境变量中的字段: 字段名 类型 描述 platform String Current running platform, could be “Android”, “iOS” or “Web”. weexVersion String The version of Weex SDK. appName String Mobile app name or browser name. appVersion String The version of current app. osName String The OS name, could be “Android” or “iOS”. osVersion String The version of current OS. deviceModel String Mobile phone device model. (native only) deviceWidth Number Screen resolution width. deviceHeight Number Screen resolution height. 这个例子 打印出了 Weex 环境对象中的所有值。 weex.document#weex.document 是当前页面的文档模型对象，可以用来创建和操作 DOM 树中元素。它是 Weex DOM API 规范的一部分，但是它和 W3C 的 DOM 规范中的 document 对象是不同的。 而且，在使用了现代化的前端框架（如 Vue 和 Rax）的情况下，直接操作 DOM 并不是最佳实践。更何况在 Weex 平台里并不一定有真实的 DOM，在 Android 和 iOS 端上都是模拟出来的。 这个接口主要是用在 Vue 和 Rax 框架内部，用于将 virtual-dom 转换成渲染执行，并且发送给 Weex 客户端的渲染引擎。不建议在开发页面时使用。 weex.requireModule#对于那些不依赖 UI 交互的原生功能，Weex 将其封装成模块，这是一种通过 javascript 调用原生能力的方法。除了内置模块以外，将已有的原生模块移植到 Weex 平台也很方便。你可以使用 weex.requireModule 接口引用自定义的或者内置的模块。 weex.requireModule(name: string): Object | void; 参数： 大小写敏感的模块名。 返回值： 如果模块已经注册了，返回一个 Proxy 对象（如果环境不支持 Proxy 则返回一个普通对象），可以使用这个对象调用客户端注册的方法。 如果模块未注册，返回 undefined。 使用原生模块#你可以像使用不同 javascript 函数一样使用原生注册的接口。这里是一个简单的使用 modal 模块的例子： &lt;template&gt; &lt;div&gt;&lt;text&gt;Toast&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.supports# 这个接口只在 v0.15+ 或以上的版本可用。 你应该了解 Weex 的组件和模块都是可以注册和配置的，这样导致了在不同环境中组件和模块的支持情况不一样。你可以使用 weex.supports 接口在运行期检测某个功能在当前环境中是否可用。 weex.supports(condition: string): boolean | void; 参数： 特定格式的字符串：@{type}/{name}。 type 必须是 &quot;component&quot; 和 &quot;module&quot; 之一。name 可以是标签名、模块名，也可以指定模块中的某个方法名（和模块名用 . 隔开）。 返回值： 支持该特性，则返回 true。 不支持该特性，则返回 false。 参数格式错误或无法确定是否支持，则返回 null。 使用范例#检测某个组件是否可用： weex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false 检测某个模块是否可用： weex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false 检测某个模块是否包含某个方法： weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false 无效的输入： weex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null weex.isRegisteredModule#检测某个特定的模块或者接口是否可用。 weex.isRegisteredModule(moduleName: string, methodName: string): boolean 这个接口只能用于检测特定模块和方法的兼容性，不支持检测组件。 weex.isRegisteredModule('stream') // trueweex.isRegisteredModule('stream', 'fetch') // trueweex.isRegisteredModule('whatever', '- unknown -') // falseweex.isRegisteredModule('div') // false, not support components weex.isRegisteredComponent#检测某个特定的组件是否可用。 weex.isRegisteredComponent(componentName: string): boolean 这个接口只能用于检测组件的兼容性，不支持检测模块。 weex.isRegisteredComponent('div') // trueweex.isRegisteredComponent('- unknown -') // falseweex.isRegisteredComponent('navigator') // false, not support modules","type":"references"},{"title":"Weex语法支持插件","path":"cn/tools/helpers.html","permalink":"https://weex.apache.org/cn/tools/helpers.html","text":"Weex语法支持插件#Weex Language Support 插件是官方提供的一个工具，你可以使用它在IntelliJ IDEA，WebStorm等一系列IDE上对Weex DSL进行语法高亮，自动补全和错误检查等操作。 支持的IDE#你可以在任何操作系统上的下列IDE上安装和使用Weex Language Support插件：IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider 安装#在IDE的插件仓库中搜索Weex Language Support来安装该插件，安装完毕后重启IDE即可激活插件相关功能 配置#打开Preferences -&gt; Other Settings -&gt; Weex language support可配置插件的相关功能 Target Weex Version: 配置插件以哪一个版本的语法规则来对DSL进行提示及检查，默认值LATEST表示总是应用最行\b\b新版本weex的语法规则 Vue Support: 配置插件是否支持Weex 2.0版本的DSL(.vue文件)，开启后重启生效（注意：如果IDE内有其他支持Vue语法的插件，则需要关闭相应的插件后Weex插件才能生效） Custom Rules: 引入自定义的Weex DSL规则，如果你在native中定义了自己的Module或Component，可通过自定义规则引入插件中来提供相应的提示和补全支持，自定义规则的\b格式将在后文列出 Global Weex Components: 默认地，插件会解析当前工程及npm root路径下的node_modules\b目录，解析其中包含的Weex Components并对其提供补全支持。如果你的项目中引用了这两个路径以外的Components，可以在此处将其添加到搜索路径中，\b插件将会将其中的Components载入，并在编写DSL时为相应的标签提供补全支持 自定义规则格式#自定义规则包含在一个json文件中，json文件的根节点为数组类型，数组中的每一个元素对应DSL中的一个标签。我们以&lt;loading&gt;标签的规则来举例：&#123; \"tag\": \"loading\", //标签名，不可为空 \"attrs\": [ //标签属性列表，可为空 &#123; \"name\": \"display\", //属性名，不可为空 \"valuePattern\": null, //属性值的正则表达式，用于检测\b值是否合法，可为空 \"valueEnum\": [ //属性值枚举，可为空 \"show\", \"hide\" ], \"valueType\": \"var\", //属性值类型，必须是var或function，决定该从数据列表还是函数列表中查找属性值补全的候选值，不可为空 \"since\": 0, //该属性何时被添加到sdk中，例如0.11，\b默认为0 \"weexOnly\": false //该属性是否仅在1.0语法中可用，默认为false &#125; ], \"events\": [ //事件列表。可为空 &#123; \"name\": \"loading\", //事件名称，不可为空 \"since\": 0 //该事件何时被添加到sdk中 &#125; ], \"parents\": [ //该标签允许被作为哪些标签的子元素，空表示可以作为任意元素的子元素 \"list\", \"scroller\" ], \"childes\": [ //该标签允许哪些元素作为自己的子元素，空表示任意元素都可作为子元素 \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //文档地址，配置该属性之后可在编辑界面中对应的标签上直接打开文档 &#125; 使用#插件的绝大部分功能\b被集成到编辑器上下文中，会随用户输入在需要补全，提示或Lint时被触发，无需特殊干预。下列功能需要用户手动触发： 文档搜索#打开IDE右侧工具栏的Weex Documents即可对文档进行搜索，搜索结果与官网保持同步，勾选 EN 可切换搜索结果为英文内容 打开标签对应的文档#\b将光标定位到标签上，并通过Show Intention Actions操作（OSX上默认键为 option + enter，可通过Keymap查看）打开Intenion菜单，\b选择Open Document可打开标签对应的文档 参与插件建设#请将Issues及Pull Requests提交到weex-language-support项目中","type":"tools"},{"title":"使用 weex-toolkit","path":"cn/tools/toolkit.html","permalink":"https://weex.apache.org/cn/tools/toolkit.html","text":"weex-toolkit#weex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 安装#$ npm install -g weex-toolkit 如果你本地没有安装 node.js 你可以前往Nodejs 官网下载安装, 并确保你的 node 版本是&gt;=6，你可以使用 n 来进行 node 的版本管理。 中国用户如果npm遭遇网络问题，可以使用淘宝的 npm镜像或通过nrm工具切换你的npm镜像： $ npm install weex-toolkit -g --registry=https://registry.npm.taobao.org// 或者$ npm use taobao$ npm install weex-toolkit -g 如果你安装的过程中遇到了问题，你可以在weex-toolkit常见问题中找到解决方法或者在weex-toolkit issues中进行反馈。 命令#create## 从官方模板中创建项目$ weex create my-project# 从github上下载模板到本地$ weex create username/repo my-project 从官方模板或者远程源创建项目模板，你也可以创建你自己的weex项目模板，更多细节你可以查看如何创建你自己的模板. preview#weex-toolkit工具支持对你的Weex文件（.we或.vue)在监听模式下进行预览，你只需要指定一下你的项目路径。 自weex-toolkit v1.1.0+版本后修改$ weex preview src/foo.vue 浏览器会自动得打开预览页面并且你可以看到你的weex页面的布局和效果。如果你在你的设备上安装了Playground，你还可以通过扫描页面上的二维码来查看页面。 使用下面的命令，你将可以预览整个文件夹中的.vue文件 $ weex src --entry src/foo.vue 你需要指定要预览的文件夹路径以及入口文件（通过--entry传入）。 compile#使用 weex compile 命令可以编译单个weex文件或者整个文件夹中的weex文件。 $ weex compile [source] [dist] [options] 参数# Option Description -w, --watch 开启watch模式，同步文件改动并进行编译 -d,--devtool [devtool] 设置devtool选项 -e,--ext [ext] 设置文件拓展名，默认为vue -m, --min 压缩jsbundle选项 你可以这样子使用： $ weex compile src dest --devtool source-map -m platform#使用weex platform [add|remove] [ios|android]命令可以添加或移除ios/android项目模板。 $ weex platform add ios$ weex platform remove ios 使用 weex platform list来查看你的项目中支持的平台。 run#你可以使用weex-toolkit来运行android/ios/web项目. $ weex run ios$ weex run android$ weex run web debug# Weex devtools 是实现Chrome调试协议的Weex自定义开发工具,主要用于帮助你快速检查您的应用程序，并在Chrome网页中调试您的JS bundle源代码，支持Android和iOS平台。所以你可以通过weex-toolkit使用的weex-devtool功能。 用法#weex debug [we_file|bundles_dir] [options] 参数# Option Description -v, --version 显示weex-debugger版本信息 -h, --help 展示帮助信息 -H --host [host] 设置浏览器打开的host地址（适用于代理环境下，如docker环境等） -p, --port [port] 设置调试服务器的端口，默认值 8088 -m, --manual 开启该选项后将不会自动打开浏览器 -e,--ext [ext] 设置文件拓展名用于编译器编译，默认值为vue --min 开启该选项后将会压缩jsbunlde --telemetry 上传用户数据帮助提升weex-toolkit体验 --verbose 显示详细的日志数据 --loglevel [loglevel] 设置日志等级，可选silent/error/warn/info/log/debug,默认值为error --remotedebugport [remotedebugport] 设置调试服务器端口号，默认值为9222 功能介绍#连接设备#使用以下命令打开调试页面，使用测试包扫码，进入你需要调试的weex页面$ weex debug 自weex-toolkit v1.1.0+版本起默认的debug工具已从weex-devtool切换至weex-debugger，如想使用旧版本devtool，可通过以下命令使用： $ weex xbind debugx weex-devtool$ weex debugx 链接设备#请使用weex playground app扫码或使用集成了weex-devtool的app进行扫码，集成方法见集成devtool工具。有ios模拟器环境的用户也可以通过点击二维码的方式进行模拟器调试（仅限mac用户使用）。 编译 .vue 文件#$ weex debug your_weex.vue 点击可扫码的二维码按钮即可打开编译后得到的产物二维码，可直接通过weex playground app 进行扫码预览。 Inspector功能# Inspector功能可查看页面的VDOM/Native Tree结构 注：如不需要此功能尽量保持关闭状态，开启浏览器Inspector界面会增加大量页面通讯，较为影响性能。 JS Debug功能# JS Debug功能可对weex页面中的Jsbundle进行调试。 Network功能# Network功能可以收集weex应用中的网络请求信息。 LogLevel和ElementMode功能# LogLevel和ElementMode功能用于调整调试工具的输出配置。 LogLevel分别有 debug/info/warn/log/error五个log等级，切换可输出不同等级的log信息ElementMode可以切换Element标签中Domtree显示模式，下图为vdom显示界面，可从标签中看到详细的数据结构： Prophet功能（加载时序图）# Prophet功能用于查看weex的加载时序图和页面性能指标。 点击右上角Prophet即可查看时序图(iOS暂不支持，性能数据可在log的performance中查看)，如下： 集成devtool工具# Android 查看文档 Weex devtools (Android), 它会引导你一步一步配置和使用它。 iOS 查看文档 Weex devtools (iOS), 它会引导你一步一步配置和使用它。","type":"tools"},{"title":"支持的颜色名称列表","path":"cn/wiki/color-names.html","permalink":"https://weex.apache.org/cn/wiki/color-names.html","text":"基础颜色关键词: 扩展颜色关键词: 基础颜色关键词:# 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词:# 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"通用事件","path":"cn/wiki/common-events.html","permalink":"https://weex.apache.org/cn/wiki/common-events.html","text":"click 事件对象 longpress 事件对象 Appear 事件 事件对象 Disappear 事件 事件对象 Page 事件 事件对象 示例 Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click#当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 longpress#如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 Appear 事件#如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象# type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Disappear 事件#如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象# type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Page 事件#注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象# type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"通用样式","path":"cn/wiki/common-styles.html","permalink":"https://weex.apache.org/cn/wiki/common-styles.html","text":"盒模型 注意： 示例： Flexbox Flex 容器 Flex 成员项 示例 定位 示例 transform 示例 transition v0.16.0+ 参数 示例 伪类 v0.9.5+ 规则 示例 线性渐变 v0.10+ 使用 Note 示例 阴影(box-shadow) v0.11+ 注意 示例 其他基本样式 上手样式 所有 Weex 组件都支持以下通用样式规则。 盒模型# Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：#Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 &lt;image&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例：#&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400px; height: 200px; margin-left: 20px;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器#在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项#flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例#一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div v-for=\"(v, i) in list\" class=\"row\"&gt; &lt;div v-for=\"(text, k) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80px; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200px; height: 200px; background-color: #fc0000; &#125;&lt;/style&gt; 定位#Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例# &lt;template scoped&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400px; height: 400px; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150px; left: 150px; background-color: #0055dd; &#125; .box3 &#123; top: 300px; left: 300px; background-color: #00ff49; &#125;&lt;/style&gt; transform#transform 属性向元素应用 2D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 目前支持的 transform 声明格式: translate( &lt;number/percentage&gt; [, &lt;number/percentage&gt;]?) translateX( &lt;number/percentage&gt; ) translateY( &lt;number/percentage&gt; ) scale( ) scaleX( ) scaleY( ) rotate( &lt;angle/degree&gt; ) rotateX( &lt;angle/degree&gt; ) v0.14+ rotateY( &lt;angle/degree&gt; ) v0.14+ perspective( ) Android 4.1及以上版本支持 v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.16.0+#现在您可以在CSS中使用transition属性来提升您应用的交互性与视觉感受，transition中包括布局动画，即LayoutAnimation，现在布局产生变化的同时也能使用transition带来的流畅动画。transition允许CSS的属性值在一定的时间区间内平滑地过渡。 参数# transition-property:允许过渡动画的属性名，设置不同样式transition效果的键值对，默认值为空，表示不执行任何transition，下表列出了所有合法的参数属性： 参数名 描述 width transition过渡执行的时候是否组件的宽度参与动画 height transition过渡执行的时候是否组件的高度参与动画 top transition过渡执行的时候是否组件的顶部距离参与动画 bottom transition过渡执行的时候是否组件的底部距离参与动画 left transition过渡执行的时候是否组件的左侧距离参与动画 right transition过渡执行的时候是否组件的右侧距离参与动画 backgroundColor transition过渡执行的时候是否组件的背景颜色参与动画 opacity transition过渡执行的时候是否组件的不透明度参与动画 transform transition过渡执行的时候是否组件的变换类型参与动画 transition-duration:指定transition过渡的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 transition-delay:指定请求transition过渡操作到执行transition过渡之间的时间间隔 (单位是毫秒或者秒)，默认值是 0，表示没有延迟，在请求后立即执行transition过渡。 transition-timing-function:描述transition过渡执行的速度曲线，用于使transition过渡更为平滑。默认值是 ease。下表列出了所有合法的属性： 属性名 描述 ease transition过渡逐渐变慢的过渡效果 ease-in transition过渡慢速开始，然后变快的过渡效果 ease-out transition过渡快速开始，然后变慢的过渡效果 ease-in-out transition过渡慢速开始，然后变快，然后慢速结束的过渡效果 linear transition过渡以匀速变化 cubic-bezier(x1, y1, x2, y2) 使用三阶贝塞尔函数中自定义transition变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. 示例#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; 伪类 v0.9.5+#Weex 支持四种伪类：active, focus, disabled, enabled 所有组件都支持 active, 但只有 input 组件和 textarea 组件支持 focus, enabled, disabled。 规则# 同时生效的时候，优先级高覆盖优先级低 例如：input:active:enabled 和 input:active 同时生效，前者覆盖后者 互联规则如下所示 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; 试一下 线性渐变 v0.10+#Weex 支持线性渐变背景，具体介绍可参考 W3C description of the gradient。 所有组件均支持线性渐变。 使用# 你可以通过 background-image 属性创建线性渐变。 background-image: linear-gradient(to top,#a80077,#66ff00); 目前暂不支持 radial-gradient（径向渐变）。 Weex 目前只支持两种颜色的渐变，渐变方向如下： to right从左向右渐变 to left从右向左渐变 to bottom从上到下渐变 to top从下到上渐变 to bottom right从左上角到右下角 to top left从右下角到左上角 Note# background-image 优先级高于 background-color，这意味着同时设置 background-image 和 background-color，background-color 被覆盖。 不要使用 background 简写. 示例#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; 阴影(box-shadow) v0.11+#Weex 支持阴影属性：active, focus, disabled, enabled inset(可选),offset-x,offset-y, blur-radius,color 注意# box-shadow仅仅支持iOS 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; 其他基本样式# opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式#如果对于样式写法需要更多上手参考，可参考每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"wiki"},{"title":"Component","path":"cn/wiki/component-introduction.html","permalink":"https://weex.apache.org/cn/wiki/component-introduction.html","text":"什么是 component# 简单来讲，component 就类似 Weex 渲染引擎上的 Widget, 符合一定的规则的 Widget, 可以被 Weex engine 在初始化的时候正确的加载，开发者在 DSL 书写对应的标签名字(在注册的时提供的注册名字)， 比如内置的一些组件 div，image 和 text。它可以读取特定的属性，展示用户数据，承载和触发事件，如果 Weex 内置的组件不能满足你的开发需求，可以自定义你自己的 component。 component 方法# component 方法是组件支持的方法，JavaScript 可以直接对对应标签声明 ref 属性之后，直接可以调用对应方法的一个特性，例如下面例子。 &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"wiki"},{"title":"CSS 单位","path":"cn/wiki/css-units.html","permalink":"https://weex.apache.org/cn/wiki/css-units.html","text":"CSS color 单位 注意 CSS length 单位 CSS number 单位 CSS percentage 单位 (暂不支持) CSS color 单位#支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意# 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位#在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位#仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持)#表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"wiki"},{"title":"设计理念","path":"cn/wiki/design-principles.html","permalink":"https://weex.apache.org/cn/wiki/design-principles.html","text":"Weex 设计理念 性能为王 交互体验 开发效率 易于扩展 Weex 设计理念#这篇文章想从 Weex 的设计理念入手，让你对 Weex 的设计哲学、优势有一个全面的了解，希望可以帮助 Weex 的使用者更好的在适合的场景应用 Weex，也希望 Weex 的开发者可以在设计理念的指引下将 Weex 变得更好 性能为王#性能对于 Weex 来说是最为重要的核心价值，也是 Weex 区别于传统的基于 WebView 的 hybrid 框架的特点。Weex 采用了 vDOM 机制，在 JavaScript context 中维护页面布局，并通过向移动端发送规范化的渲染指令，在移动端直接通过 iOS 和 Android 的界面框架生成原生的 UI 进行渲染。相比于浏览器通过自己的渲染系统实现渲染的方式，Weex 的方式更好的利用了系统 UI 体系以达到更佳的性能和用户体验。同时 Weex 也采取了多种手段优化性能表现，包括优化 native 与 JavaScript 的通信频率和通信量，使用二进制方式提升单次通信的耗时等，未来还会通过跨平台内核将 DOM 管理移至 native 层实现来彻底解决 native 与 JavaScript 层异步通信成本的问题，从多个维度提升 Weex 引擎的性能。 交互体验#交互体验一直是 Weex 在不断追求的目标。与 React Native 等框架不同的是，Weex 希望完全做到 iOS、Android 及 Mobile Web 的跨端一致性表现，因此在内置组件的设计上充分考虑了跨端一致性，为 Weex 开发者提供了一致的交互体验。Weex 借助 GCanvas 等组件增强了框架的 2D、3D 渲染能力，为高性能渲染场景提供了可能；同时借助 Expression Binding 的交互理念提升了 Weex 的交互性能。对于前端使用习惯带来的传统 list 性能较差的问题，Weex 提供了基于模板和数据分离的 recycle list 组件，大大提升了交互性能。 开发效率#从易用和高效的角度考虑 Weex 的开发体验，是 Weex 不断致力提升的方向。从一开始，Weex 的设计就是面向前端开发技术栈，利用前端技术在开发体验、效率上的优势，为开发者提供接近前端开发体验的开发环境。你可以使用 JavaScript、CSS 和 HTML 技术进行 Weex 开发，Weex 的内置组件通过HTML标签的方式提供给开发者，事件体系的设计遵循 W3C 标准，API 也通过 JavaScript 对象的方式提供。同时 Weex 原生支持 Vue DSL，开发者可以利用 Vue 提供的强大易用的开发范式进行 Weex 应用开发。 易于扩展#扩展机制的便利性也是 Weex 从一开始就考虑在内的设计思路。基于 Weex 的实现特点，在框架层面提供了两种扩展方式，其中 Module 用于提供无 UI 的基础功能接口扩展能力，Component 提供包含 UI 的界面组件扩展能力，开发者可以根据需要选择不同的扩展方式实现需求。","type":"wiki"},{"title":"事件冒泡","path":"cn/wiki/event-bubble.html","permalink":"https://weex.apache.org/cn/wiki/event-bubble.html","text":"概念 使用 阻止冒泡 注意 实例 v0.13+ 注意: 目前仅 Weex Native（Android 和 iOS）支持，web 端 暂时不支持此项特性. 如果你是个 web 开发者，你大概对浏览器事件冒泡机制已经很熟悉了，而且可能认为 Weex 默认会支持事件冒泡。然而，Weex 在 0.13 之前是不支持这一特性的，在 0.13 版本，Weex 提供了这项支持。 对于不熟悉事件冒泡的开发者，这里简要介绍一下浏览器事件冒泡机制的概念： 概念#以点击事件为例，比如一个点击事件发生在某个 &lt;video&gt; 元素上，这个元素有一个父元素（比如是个 div 元素），浏览器会执行两个处理阶段 - 捕获（capturing）阶段和冒泡（bubbling）阶段。在 web 开发中冒泡阶段会用的比较多，而捕获处理用的比较少。 在捕获阶段，浏览器检查当前元素的最外层父节点（在 web 上，比如，&lt;html&gt; 元素），如果它上面绑定了一个 click 事件处理器，那么先执行这个处理器。然后检查下一个元素，&lt;html&gt; 的子元素里是 &lt;video&gt; 祖先元素的那个元素，做同样的检测。一步步直到遇到当前点击的这个元素本身。 接下来是冒泡阶段，方向和捕获阶段相反：浏览器先检测当前被点击的元素上是否注册了点击事件处理器，如果有则执行它。接下来检测它的父元素，一步步向上，直到最外层 &lt;html&gt; 元素。 我们一般使用默认的事件注册机制，将事件处理注册在冒泡阶段，所以处理冒泡阶段的情况比较多。当我们想要停止事件冒泡，只需要调用事件对象的 stopPropagation 方法。标准事件对象包含 stopPropagation 方法，当执行事件处理器时调用该方法，会立即停止事件冒泡，这样事件冒泡处理链上的后续处理器就不会再执行下去。 Weex 在 0.13 版本 SDK 里实现了事件冒泡机制。注意事件冒泡默认是不开启的，你需要在模板根元素上加上属性 bubble=true 才能开启冒泡。 使用#事件冒泡默认不开启，需要手动添加 bubble=true 属性到根元素上。 &lt;template&gt; &lt;!-- 开启事件冒泡机制. --&gt; &lt;div bubble=\"true\"&gt; ... &lt;/div&gt;&lt;/template&gt; 阻止冒泡#在事件处理函数里，可以通过调用 event.stopPropagation 方法阻止事件冒泡。这个方法和 DOM 标准里的方法一致。注意 event.stopPropagation 和 bubble=true 的影响范围不同，前者仅针对当前冒泡到的元素以及其祖先层级有效，而对子元素无效。而后者相当于一个全局开关，开启以后对该根元素内部所有子元素都开启了事件冒泡效果。两者可以同时存在。 &#123; handleClick (event) &#123; // 阻止继续冒泡. event.stopPropagation() &#125;&#125; 注意#需要注意的是: 为了兼容之前的版本，Weex 默认不会开启事件冒泡机制。需要在根元素的属性上，添加 bubble=&quot;true&quot; 来开启冒泡机制。否则，将不会向上传播事件，保持与之前版本的效果相同。 实例# 开启事件冒泡：使用 Weex playground App 扫描页面里的二维码，然后在打开页面中点击包含 ‘click me’ 文字的方框，会看到事件冒泡效果，即外层的组件依次显示事件成功冒泡到当前组件的提示。 阻止冒泡：使用 Weex playground App 扫描页面里的二维码，然后在打开页面中点击包含 ‘click me’ 文字的方框，可以看到事件冒泡被父组件中断了，不再冒泡到最外层组件。","type":"wiki"},{"title":"手势","path":"cn/wiki/gestures.html","permalink":"https://weex.apache.org/cn/wiki/gestures.html","text":"手势类型 属性 changedTouches 约束 注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上监听手势即可。 手势类型#目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 shouldStopPropagation 每个touch事件都会被传递过来, 可控制touch事件是否冒泡（返回true）或者停止（返回false）；用于解决事件冲突或者自定义手势。v0.18+ Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三种类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend horizontalpan v0.10+：手势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 verticalpan v0.10+：势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性#以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedTouches#changedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 force: 屏幕收到的按压力度，值的范围为 0~1 force 属性目前在支持 forceTouch iOS 设备才支持, iPhone 6s 及更新的 iOS 设备 试一试 约束#目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。","type":"wiki"},{"title":"Handler","path":"cn/wiki/handler-introduction.html","permalink":"https://weex.apache.org/cn/wiki/handler-introduction.html","text":"什么是 handler# hanlder(Android 中称为 adapter，以下称 handler) 是 WeexSDK engine 中一个 service 的概念，它可以被 component、module 和其他的 handler 实现中调用。 handler 调用细节# handler 提供了不同 App 和客户端解耦的能力，上层通过 interface(Android) 和 protocol(iOS) 约束方法，handler 的实现者，只需要实现该 handler 对应的接口声明的方法即可，调用者不关注 handler 具体的实现，只通过接口获得需要的数据或者调用对应的 handler 方法，每个 protocol(interface) 对应的 handler 在 app 生命周期期间只有一个实例。 handler 和 module 的区别# 在应用中的位置 上图假设当前APP 中已经打开了三个 Weex 的页面，三个页面中都已经调用过 fetch module 的方法，每个页面都会动态的产生一个 fetch module class 的 Object，随着页面的销毁，页面持有的 module 也会被销毁。handler class 对应的 Object 只会有一个。 开发者使用handler 更多的是针对 native 开发同学来开发和使用，在其他的 component 和 module 中被调用。module 是由 native 开发同学完成之后提供给前端同学使用，可以暴露一些操作方法来实现一定的功能。 内置 handler#WeexSDK 内部的一些 handler 场景描述 navigationHandler WeexSDK 内部提供了一个默认的 navigation 的 handler，该 handler 是在 navigation Module 中调用 push 和 pop 的一些操作时候被调用。 SDK 中提供了默认的导航操作Handler imageLoaderHandler WeexSDK 图片组件需要从一个固定的 URI 中加载资源，这个加载行为也被封装到 image 的 handler 中，所以在接入 WeexSDK 时候，一定得提供图片 load 的handler。 SDK 中未提供 load 图片 Handler AppMonitorHandler 该 handler 是 WeexSDK 在渲染过程中性能统计，module 调用统计时候会将数据同步到该 handler 中，可以实现该 handler 将对应的数据上传到监控平台做性能的监控。 SDK 未提供 监控 Handler JSEXceptionHandler JavaScript 在 runtime 可能会发生一些错误，首先由 \bJavaScript Engine 捕捉，然后抛出到 WeexSDK， WeexSDK 会通过 JSExceptionHandler 通知到外部调用。 SDK 中未提供默认接受 JSException 的 Handler URLRewriteHandler image、video、web组件都在加载 URL 的时候会进行 URL 的重写，重写的规则就是由 URLRewriteHandler 提供，在这里 Handler 里面，可以将特定的 URL，重写为本地 URL 或者其他路径。了解更多默认重写规则 path WeexSDK 默认提供重写规则","type":"wiki"},{"title":"Module","path":"cn/wiki/module-introduction.html","permalink":"https://weex.apache.org/cn/wiki/module-introduction.html","text":"什么是 module# module 是完成一个操作的方法集合，在 Weex 的页面中，允许开发者 require 引入，调用 module 中的方法，WeexSDK 在启动时候，已经注册了一些内置的 module。 module 注册过程# native 端注册module 的流程如下图: 内置 module#stream module, 开发者可以利用它给服务端发送网络请求，接受数据返回，开发者可以在 Weex 的页面中执行如下代码： var stream = weex.requireModule('stream');stream.fetch(&#123; method: 'GET', url: 'http://httpbin.org/get', type:'jsonp' &#125;, function(ret) &#123; console.log('in completion') &#125;,function(response)&#123; console.log('in progress') &#125;); 查看 stream 完整文档 module 方法# require 之后直接可以调用，相对于 component 方法 可以不依赖特定的组件实例。","type":"wiki"},{"title":"与 Web 平台的差异","path":"cn/wiki/platform-difference.html","permalink":"https://weex.apache.org/cn/wiki/platform-difference.html","text":"Weex 和 Web 平台的差异#Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOM#DOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作#既然原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型#Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 并不支持 Web 中所有的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOM#BOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端没有并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象#Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象#在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象# history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API#在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。","type":"wiki"},{"title":"文本样式","path":"cn/wiki/text-styles.html","permalink":"https://weex.apache.org/cn/wiki/text-styles.html","text":"属性 其它参考 v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性# color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}v0.9+：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考# 颜色关键字列表。","type":"wiki"},{"title":"Mobile App Architecture","path":"guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/guide/advanced/app-architecture.html","text":"Today’s Mobile App Mobile App Needs Parallel Development Mobile App Needs to be Dynamic Mobile App Needs Open Interconnection Our Thinking of Mobile App Today’s Mobile App#Let’s talk about what we think a mobile app should be. Mobile App Needs Parallel Development#Nowadays, all mobile app teams requires the ability to develop in parallel. When a mobile app keeps growing, supporting large-scale parallel development must become a very important key thing. Otherwise it’s really easy to become a bottleneck. Mobile App Needs to be Dynamic#Today the development of mobile apps is very heavy. And it’s really slow in iteration, release, distribution and online bugfix. The size of the package of an app is growing fast too. All of this is not suitable for this mobile internet age. Mobile app needs to be dynaimic which is out of the cumbersome process of version deployment and distribution. Mobile App Needs Open Interconnection#Today in your phone, things are hard to connect and share between different apps. They needs some container with common standard and specs to be shared with each other. Our Thinking of Mobile App#We think a dynamic, parallel development supported, standardized mobile app should be like this: |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| Pages: A whole mobile app should be divided into several mobile pages. Each mobile page has its own “URL”. Router: All the mobile pages above will be connected with router. And navigators or tab bars are just doing this job. Features: All kinds of APIs or services provided from the device. Every mobile page could use these features as they like. So before you build your mobile app, make sure how many mobile pages your mobile app has and what are they. How do they connect each other. Give each mobile page a URL. And sort out all the APIs and services your mobile app needs. Then create the pages and develop, debug and deploy them using Weex. Links Mobile page architecture If you have built a complete mobile app already and just want to using Weex to rebuild part of these pages, that’s absolutely no problem. Because Weex is just a SDK to build mobile pages which can coexist very well with other native views or hybrid pages. If the feature of WeexSDK is limited to your mobile app. You can extend your own components and modules. It requires some native development knowledge. But with our efforts on delivering more and more features, we believe this part of job will be getting smaller and smaller. Links Extend iOS Extend Android Extend Web Renderer Extend JS framework","type":"guide"},{"title":"Downgrade","path":"guide/advanced/downgrade.html","permalink":"https://weex.apache.org/guide/advanced/downgrade.html","text":"Due to the continuous development of Weex, some version fragmentation problems occur inevitably . For example, certain new features are not fully supported in the historical version. In this case, we need to degrade Weex to HTML and render through web. Currently, there are many conditions and rules for the degradation which triggered by Weex definition, including operating system version, app version, SDK version, etc. Weex 2.0 downgrade change to module，please refer to downgrade","type":"guide"},{"title":"Weex Page Architecture","path":"guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/guide/advanced/page-architecture.html","text":"UI Native DOM Model Components Layout System Features Lifecycle A Weex page is a independent mobile page which includes UI, interaction logic, device power, lifecycle management etc. UI#Native DOM Model#Weex page has its HTML-like DOM model to manage UI. It will be decomposed into a DOM tree which consists of some DOM nodes. Links Weex Native DOM APIs Components#Weex supports many kinds of components. Some of them are content components such as text, image and videos. Some of them are container components such as div, list, scroller. Also there are some special components like slider, input, textarea, and switch. Links All components Weex supports Layout System#Weex use some CSS properties to layout every nodes in the DOM tree together. It includes: Box model: Describe the width, height, padding, margin and border of a component node. Flexbox: Describe the relations between different nodes with CSS Flexbox Spec. Supportting absolute, relative, fixed and sticky value of CSS position property. Features#Weex supports lots of device features through modules such as storage, navigation, modals etc. Each of them exposes some JS APIs. Links All modules Weex supports Lifecycle#Every Weex page has its lifecycle which is defined and implemented in WeexSDK. All Weex pages will go through the whole process, from being created and last to being destroyed.","type":"guide"},{"title":"Asset Path","path":"guide/advanced/path.html","permalink":"https://weex.apache.org/guide/advanced/path.html","text":"Schemes Relative URI URI Adapter 0.9 This article will cover uri (url) usage in Weex. Including using image/typeface resources, deal with relative uri and how to access local and packaged asset files. Schemes# LocalWeex SDK provide local scheme to access resources packaged with application, and of cource, it’s not working in the HTML5 runtime.Currently, developers can use this scheme with image and text’s font file location. In iOS, it’s always locate file in ‘bundle resources’. For example, a image component with local:///app_icon will load image file named ‘app_icon’ in bundle resouce, and font file work in the same way. In Android, image component will load from ‘drawable’ resource folder like ‘res/drawable-xxx’. But load font file is different, android framework can not load font file from ‘res’, so SDK will load it from assets folder. HTTP/HTTPSIt’s working in the same way as in web, Weex support these at very beginning. FileUse file scheme to access local disk file. This scheme has its limitations: You would not hard coded a file url in source page. Because not matter it’s running in different platform(iOS, Android) or not, the content will be totally different in another device, which is depend to the specific device.So one possible case is getting the file url in runtime dynamically, which you can use it to display a local disk image, or maybe upload it later. Relative URI#Like we do in HTML, weex process ‘relative URI’ in the same way. The relative URI, which start with /,.,..,//, will resolve by the bundle url.Means URL start with / will resolve to the root folder as bundle js file, . and .. will resolve to current and parent folder, and // will resolve to same scheme bundle js have. URI Adapter#All the above is the default implementation, developers can extend or override these their own by providing a ‘URI Adapter’. Same as the other adapters, Custom adapter should be set before Weex SDK is initializing.","type":"guide"},{"title":"Use Vuex and vue-router","path":"guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/guide/advanced/use-vuex-and-vue-router.html","text":"Using Vuex Using vue-router Router mode Programmatic navigation Vue.js has many peripheral technology products such as Vuex and vue-router, those libraries can also work well on Weex. NOTE: Weex is using native navigator to manage instance pages, the context of them are isolated. That means, Both Vuex and vue-router can only effect the single page, they can’t share state between different pages. Using Vuex# Official Vuex documents Vuex is a state management pattern + library for Vue.js applications. It’s also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. As a kind of state management library, Vuex is platform-independent, It also can be used in Weex. It also integrates with Vue’s official devtools extension to provide advanced features on web platform, such as zero-config time-travel debugging and state snapshot export / import. (web platform only) Using vue-router# Official vue-router documents Creating a Single-page Application with Vue.js + vue-router is dead simple. With Vue.js, you are already composing our application with components. When adding vue-router to the mix, all you need to do is map your components to the routes and let vue-router know where to render them. However, there are many differences between web and Android or iOS, some features of vue-router are limited in Weex. Router mode#vue-router provides three routing modes: hash: uses the URL hash for routing. Works in all Vue-supported browsers, including those that do not support HTML5 History API. (default) history: requires HTML5 History API and server config. See HTML5 History Mode. abstract: works in all JavaScript environments, e.g. server-side with Node.js. You can pass the mode parameter when creating a router: new Router(&#123; mode: 'abstract', // ...&#125;) Obviously, hash mode and history mode are only available on the web, and have no effect in Weex. In other words, you can only use abstract mode in Android and iOS. However, vue-router will automatically be forced into abstract mode if no browser API is present. So, just don’t set the mode option, or set it to abstract. Programmatic navigation#vue-router use &lt;router-link&gt; to create a navigation link, but in which, some features are based on the DOM events and it doesn’t work well in the native environment. In Weex, you must use the Programmatic Navigation to manage the router. Here is a basic example using &lt;router-link&gt;: &lt;!-- Can only be used on the web, it takes no effects on Android or iOS! --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; For native platforms, you have to use the router.push: &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"<a>","path":"references/components/a.html","permalink":"https://weex.apache.org/references/components/a.html","text":"&lt;a&gt; is mainly used for navigation between weex pages。 Note: The behavior of &lt;a&gt; is similar to &lt;div&gt; except for the aspect mentioned in current page. Note: It’s forbidden to add text directly to &lt;a&gt;, use &lt;text&gt; to wrap your text instead. Basic Usage#Wrap the element navigating from with &lt;a&gt; &lt;a href=&quot;http://dotwe.org/raw/dist/a5e3760925ac3b9d68a3aa0cc0298857.bundle.wx&quot;&gt; &lt;text&gt;Jump&lt;/text&gt; &lt;/a&gt; Refer the demo. Attributes:# Attribute Type Value Default Value href String {URL} - - href#href defines the URL that current page will navigate. href must point to a weex page, the behavior of other case is undefined. Style#Support common styles. Events#Support common events click# Notes: The execution order of callback function of click and href is undefined. Do not use click event to do the preprocessing of href. Examples# Basic usage for &lt;a&gt; .","type":"references"},{"title":"<cell>","path":"references/components/cell.html","permalink":"https://weex.apache.org/references/components/cell.html","text":"&lt;cell&gt;#Summary#This component must be used as a subcomponent of a list recycler waterfall component, which is for the performance optimizing for long list scrolling. Child Components#This type of component supports all kinds of weex component as its child components. Attributes#Notes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. keep-scroll-position {boolean}: v0.11+ List Whether to keep the last sliding position after inserting the Cell Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Notes: cell itself is a container, its layout info is managed by list, so specifying cell’s margin info will not work. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#please refer to List recycler waterfall","type":"references"},{"title":"<div>","path":"references/components/div.html","permalink":"https://weex.apache.org/references/components/div.html","text":"&lt;div&gt;#Summary#The most fundamental component which is a container to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child Components#This type of component supports all kinds of weex component as its child components including its own kind. Attributes#There is no specific attribute for this component. Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<image>","path":"references/components/image.html","permalink":"https://weex.apache.org/references/components/image.html","text":"&lt;image&gt; is used to display a single image in your interface. Note: &lt;img&gt; element which is usually used in HTML is not supported in Weex, you should use &lt;image&gt; instead. Note: Weex doesn’t have built-in image downloader, as download, cache, decompression features are complicated and some open source tools like SDWebImage handles it well, so please add native image adapter/handler before using &lt;image&gt;. See also: Android adapter and iOS handler. Basic Usage# Note: the style attributes of width and height must be specified, otherwise it won’t work. &lt;image style=\"width:500px;height:500px\" src=\"https://vuejs.org/images/logo.png\"&gt;&lt;/image&gt; See the example. Attributes# Attribute Type Value Default Value placeholder String {URL / Base64} - resize String cover / contain / stretch stretch src String {URL / Base64 } - Note: you can specify a relative URL for src and placeholder, relative URL will be rewritten to the to the actual resource URL (local or remote). See also: Path. placeholder#A URL value for placeholder image. It will be displayed when the image view is empty and will be replaced as soon as the ‘src’ image gets loaded.(Example) resize# contain: Scales the image as large as possible without cropping or stretching it. Remaining area within bounds is transparent (Example) cover: Scales the image as large as possible without stretching it. If the proportions of the image differ from the element, it is cropped either vertically or horizontally so that no empty space remains. (Example) stretch: Default value. Scales the content to fit the size of the element itself by changing the aspect ratio of the image if necessary. (Example) See also: background-size. src#The URL of the image to display. This attribute is mandatory for the &lt;image&gt; component. Supported Image Formats#Weex doesn’t give a list of image formats that must be supported, it mainly relies on the image adapter/handler you are using. For example, if you are using SDWebImage as the image adapter on iOS, you can use image formats like JPEG, PNG, GIF, WebP, etc. Component Methods#save v0.16.0+#Save &lt;image&gt; content to the local device or photo album, this operation may require device permission. Parameters: callback: {Function} A function which is called after the image has been saved to the local device or photo album. Callback parameters: result: {Object} Callback result whose properties are: success: {Boolean} A flag indicating whether the image has been saved completed. errorDesc: {String} A string containing the description of the error if image is not written successfully. Return value: null Note: You must add NSPhotoLibraryAddUsageDescription and NSPhotoLibraryAddUsageDescription (iOS 11) to enable the access permission of the iOS photo album. See also: Cocoa Keys. Use save Method#Add ref attribute (Vue.js Child Component Refs) on &lt;image&gt;: &lt;image ref=\"poster\" src=\"path/to/image.png\"&gt;&lt;/image&gt; Get the component reference and use the save method: const $image = this.$refs.poster$image.save(result =&gt; &#123; if (result.success) &#123; // Do something to hanlde success &#125; else &#123; console.log(result.errorDesc) // Do something to hanlde failure &#125;&#125;) Complete example goes here. Events#Support common events. load#load event handler will be called when the image is loaded. Event object: success: {Boolean} It shows that whether the image is loaded successfully. size: {Object} The loaded image size whose properties are: naturalWidth: {Number} The intrinsic width of image displayed on device, it will be zero if the specified image cannot be loaded correctly. naturalHeight: {Number} the intrinsic height of image displayed on device, it will be zero if the specified image cannot be loaded correctly. Handle load Event#Bind load event on &lt;image&gt;: &lt;image @load=\"onImageLoad\" src=\"path/to/image.png\"&gt;&lt;/image&gt; Add event handler: export default &#123; methods: &#123; onImageLoad (event) &#123; if (event.success) &#123; // Do something to hanlde success &#125; &#125; &#125;&#125; Complete example goes here. Styles#Support common styles. Usage Notes# Add image adapter/handler before using &lt;image&gt; The width and height in the styles of &lt;image&gt; must be specified. &lt;image&gt; can not have any nested child component. Examples# Base64 example Multi-layer images example Lazy load image example","type":"references"},{"title":"<indicator>","path":"references/components/indicator.html","permalink":"https://weex.apache.org/references/components/indicator.html","text":"&lt;indicator&gt;#Summary#The &lt;indicator&gt; component usually used to show an indicator effect, it must be used as a subcomponent of a slider component. Child Components#This component dosen not supports any child components. Attributes#There is no specific attribute for this component. Styles#Threr are some private styles for &lt;indicator&gt; : item-color: &lt;colors&gt; This style attribute sets the normal item, default is #CCCCCC. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item, default is #444444. item-size: &lt;length&gt; The radius of the indicator elements, default is 5px common styles: see common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#indicator demo","type":"references"},{"title":"<list>","path":"references/components/list.html","permalink":"https://weex.apache.org/references/components/list.html","text":"List#v0.6.1+ The List component, which inspired by Android RecyclerView, is a core component, and it provides the most popular features for using a list of items. which support vertical and horizontal list. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. list simple demo list loadmore demo list sticky header list cell appear event Child Components#Notes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: true/false whether show the scroll bar or not, default value is true loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. pagingEnabled: default value is false. supporting pager style snapping in vertical orientation. support version: 0v0.20+. Example : pagingEnabled Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#onloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore event#loading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. load more demo","type":"references"},{"title":"<input>","path":"references/components/input.html","permalink":"https://weex.apache.org/references/components/input.html","text":"input#The weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child Components#This component does not support any child component. Attributes# type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, date, datetime, email, password, tel, time, url, number. each of which has the same meaning with \u001dW3C standard. value: the default value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. singleline: a boolean sttribute sets the properties of this field (lines, horizontally scrolling, transformation method) to be for a single-line input. lines: makes the input exactly this many lines tall. max-length: constrain edits not to make the length of the text greater than the specified length. max constrain the max date when type is date, format is yyyy-MM-dd min constrain the min date when type is date, format is yyyy-MM-dd maxlength: v0.7+ a number value to specify maxlength of input. return-key-type：v0.11the keybord returen key type support defalut, go, next, search, send, done. auto-capitalization-type：the keybord auto capitalization type support none, words, sentences, allCharacters. Styles# placeholder-color: the color of placeholder. Default value is ‘#999999’. Pseudo-classv0.9.5+: input component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles#check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events# input: the input evenr is fired when input content changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. return: the return key clicked. the object property of event: returnKeyType: return key Type of component value: component text value common events#check out common events support appear / disappear event. Methods# focus() v0.9+ The focus() method is used to give focus to an input component and tigger soft keybord(if it can be focused). blur()v0.9+ The blur() method is used to remove focus from an input component and close soft keybord(if it has focus). setSelectionRange(selectionStart,selectionEnd) v0.11+set text selection range of input or textarea selectionStart {number}:set starting location text selection range selectionEnd {number}:set end location text selection range getSelectionRange(callback[selectionStart,selectionEnd]) v0.11+get text selection range of input or textarea selectionStart {number}:get starting location text selection range selectionEnd {number}: get end location text selection range setTextFormatter(params)v0.18+: This is a very useful feature,can be used to set a set of rules for the input to formatting the input content in real-time. params {object}：formatting rules, contains the following parameters: formatRule {regexp}: Regular expression used to format the match formatReplace {string}: Contents to replace after format matching recoverRule {regexp}: Regular expressions to restore original content from formatted content recoverReplace {string}: Content to replace when restoring original content For details of setTextFormatter, please refer to sample Notes#input does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object# for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; try it","type":"references"},{"title":"<loading>","path":"references/components/loading.html","permalink":"https://weex.apache.org/references/components/loading.html","text":"&lt;loading&gt;#v0.6.1+#The &lt;loading&gt; Component provide a pullup to loading function for some special containers, its usage and attributes are similar to the &lt;refresh&gt; Component. Note： To be rendered properly, the &lt;loading&gt; Component must appear inside the special Component such as &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt;. Example: &lt;list&gt; ... ... &lt;loading&gt; ... &lt;/loading&gt;&lt;/list&gt; Complete example goes here Child Components# Any other components, like the &lt;text&gt; and &lt;image&gt; components, can be put inside the loading component. &lt;loading-indicator&gt;: This is a dedicated component which provides a default loading animation effect, can only be used inside the &lt;refresh&gt; or the &lt;loading&gt; components. Example: &lt;loading&gt; &lt;text&gt;Loading&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/loading&gt; Complete example goes here Attributes# Support all common attributes, check out common attributes Attribute Type Value Default Value display String show / hide show display# show：The loading animation will be started if a &lt;loading-indicator&gt; is included in the loading component. hide：Collapse the loading view. It also hides the &lt;loading-indicator&gt; and stops the loading animation if there’s a &lt;loading-indicator&gt; included in the loading component. Note： The visibility of &lt;loading&gt; component can be controlled by display attribute with the value show and hide. A display=&quot;show&quot; should always be paired with a display=&quot;hide&quot; statement. Example: &lt;template&gt; &lt;list&gt; ... ... &lt;loading @loading=&quot;onloading&quot; :display=&quot;loadinging ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/loading&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onloading (event) &#123; this.loadinging = true setTimeout(() =&gt; &#123; this.loadinging = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; Complete example goes here Styles# Please check out the common styles Events#loading# Triggered when the scroller or list is pulled up. Complete example goes here Example# Complete example goes here","type":"references"},{"title":"<recycle-list>","path":"references/components/recycle-list.html","permalink":"https://weex.apache.org/references/components/recycle-list.html","text":"Work in progress, please see the Chinese version.","type":"references"},{"title":"<refresh>","path":"references/components/refresh.html","permalink":"https://weex.apache.org/references/components/refresh.html","text":"&lt;refresh&gt;#v0.6.1+#The &lt;refresh&gt; Component provide a pulldown-refresh function for some special containers, its usage and attributes are similar to the &lt;loading&gt; Component. Note： To be rendered properly, the &lt;refresh&gt; Component must appear inside the special Component such as &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt;. Example: &lt;list&gt; &lt;refresh&gt; ... &lt;/refresh&gt; ...&lt;/list&gt; Complete example goes here Child Components# Any other components, like the &lt;text&gt; and &lt;image&gt; components, can be put inside the refresh component. &lt;loading-indicator&gt;: This is a dedicated component which provides a default refresh animation effect, can only be used inside the &lt;refresh&gt; or the &lt;loading&gt; components. Example: &lt;refresh&gt; &lt;text&gt;Refreshing&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/refresh&gt; Complete example goes here Attributes# Support all common attributes, check out common attributes Attribute Type Value Default Value display String show / hide show display# show：The refresh animation will be started if a &lt;loading-indicator&gt; is included in the refresh component. hide：Collapse the refresh view. It also hides the &lt;loading-indicator&gt; and stops the loading animation if there’s a &lt;loading-indicator&gt; included in the refresh component. Note： The visibility of &lt;refresh&gt; component can be controlled by display attribute with the value show and hide. A display=&quot;show&quot; should always be paired with a display=&quot;hide&quot; statement. Example: &lt;template&gt; &lt;list&gt; &lt;refresh @refresh=&quot;onrefresh&quot; :display=&quot;refreshing ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/refresh&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onrefresh (event) &#123; this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; Complete example goes here Styles# Please check out the common styles Events#refresh# Triggered when the scroller or list is pulled down. pullingdown v0.6.1+# Triggered when the scroller or list is pulled down. The attributes dy, pullingDistance, viewHeight and type are accessible from the event object : dy : The offset between two scroll actions pullingDistance : The distance of pulling viewHeight : The height of refreshView type : “pullingdown” constant string type for this event Example: &lt;scroller&gt; &lt;refresh @refresh=&quot;onrefresh&quot; @pullingdown=&quot;onpullingdown&quot;&gt; ... &lt;/refresh&gt; ...&lt;/scroller&gt;&lt;script&gt; export default &#123; methods: &#123; onrefresh (event) &#123; ... &#125;, onpullingdown (event) &#123; console.log(&quot;dy: &quot; + event.dy) console.log(&quot;pullingDistance: &quot; + event.pullingDistance) console.log(&quot;viewHeight: &quot; + event.viewHeight) console.log(&quot;type: &quot; + type) &#125; &#125; &#125;&lt;/script&gt; Complete example goes here Example# Complete example goes here","type":"references"},{"title":"<scroller>","path":"references/components/scroller.html","permalink":"https://weex.apache.org/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ Scroller is a component which can have multiple child components in one column. It supports both direcitons. If the content size of child components exceeds the frame of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. Child Components#Scroller supports all kinds of components, such as div, text, etc.There are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: &lt;boolean&gt; true | false, default value is true. This attribute indicates whether show the scroll bar or not. scroll-direction: &lt;string&gt; the scroll direction of component, horizontal or vertical. scroll-direction defines the scrollable axis of scroller and flex-direction defines the layout axis of scroller. scroll-direction and flex-direction must be set to the same direction, otherwise, undefined behavior may happen. Default value for scroll-direction is vertical, and for flex-direction is row . Use scroll-direction:horizontal and flex-direction: row when a horizontal layout and scrollable scroller is expected. Use scroll-direction:vertical and flex-direction: column when a vertical layout and scrollable scroller is expected. But those two values are default, if you don’t set them, it also works fine. loadmoreoffset : &lt;number&gt; default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom. e.g. A list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : &lt;number&gt; default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy：&lt;number&gt; default value is 0, the vertical offset distance required to trigger the scroll event. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events support loadmore event. The loadmore event should be used in concert with loadmoreoffset. If the view has less than loadmoreoffset to scroll down, the event will be triggered.See details in example. support scroll event 0.12+ .The scroll should be used in concert with offset-accuracy. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in example. support scrollstart and scrollend event 0.17+ .These events are fired when the list begins or ends scrolling.The current contentSize and contentOffset value are given in this event callback. See details in example Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested list/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<slider>","path":"references/components/slider.html","permalink":"https://weex.apache.org/references/components/slider.html","text":"&lt;slider&gt;#Summary#A slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child Components#It supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes# auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: . This value determines the index of current shown slide. The default value is 0. offset-x-accuracy {float}：set the scroll event trigger precision, precision value represents the rolling distance of a page width ratio. show-indicators {boolean}：set whether to display indicator infinite {boolean}：set whether the page in the slider can be scrolled scrollable {boolean}：set whether slider pages can be switched by sliding gestures keep-index {boolean}：set whether to maintain the index of the page after the data changes index {number}: specify current page index of slidertry in dotWe Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. scroll 0.11+：this event is fired when scrolling. The current offsetXRatio value is given in this event callback. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<switch> (deprecated)","path":"references/components/switch.html","permalink":"https://weex.apache.org/references/components/switch.html","text":"v0.6.1+ deprecated: This built-in component will be deprecated soon. There’re some reasons for this deprecation, such as the inconsistency of user experience on different ends, and the component’s appearance sometimes being not as expected. Therefore we strongly suggest developers build this component as a customized component using weex’s DSL and its rendering ability. &lt;switch&gt; is a checkbox-like UI component. Note: The appearance of switch component is a bit of different in three ends (iOS, Android, Web) in consideration of different platform styles. Android Web iOS Note: Layout style attributes listed below such as width, height, margin are not supported. Basic Usage#&lt;switch&gt;&lt;/switch&gt; See the example. Attributes# Attribute Type Value Default Value checked Boolean true / false false disabled Boolean true / false false checked#Indicates this component’s status is set to true or false. disabled#Indicates this component is not available for interaction. Component Methods#None. Events# appear / disappear event. check out common events click / longpress: check out common events change: check out common events Parameters of events’ object for onchange event:# value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event. Styles# Notes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxx padding and padding-xxx border and border-xxx Notes: If the container of &lt;switch&gt; is not set to align-items:flex-start, the switch in android will be stretched. common styles: check out common styles for components Usage Notes# The width and height in the styles of &lt;switch&gt; won’t effect the component’s apparence and layout. &lt;switch&gt; can not have any nested child component. Examples# Simple Switch Switch List","type":"references"},{"title":"<text>","path":"references/components/text.html","permalink":"https://weex.apache.org/references/components/text.html","text":"The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Note: This component supports no child components. Attributes# value(string): text value of this component. This is equal to the content of ‘text’. var textComponent = this.$el(&quot;textid&quot;); this.text = textComponent.attr.value; Styles# Support common styles for components lines: specify the text lines. Default value is 0 for unlimited. Support text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. Events#Support common events Custom Typeface#support:v0.12.0 support ttf and woff font format to custom your text, call addRule in dom module to build your own font-family, we suggest that you call addRule in beforeCreate. Examples# \bBasic usage for &lt;text&gt;.","type":"references"},{"title":"<textarea>","path":"references/components/textarea.html","permalink":"https://weex.apache.org/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ Summary#The weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child Components#This component supports no child components. attributes#The textarea component supports all the properties of the text component, in addition to the following properties: rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. Styles#Pseudo-classv0.9.5+: textarea component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events# input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object# for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"references/components/video.html","permalink":"https://weex.apache.org/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ The video component can be used to embed video content in a weex page. Child Components# text is the only valid type of child component. Attributes# src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed. example#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<waterfall>","path":"references/components/waterfall.html","permalink":"https://weex.apache.org/references/components/waterfall.html","text":"waterfall#v0.11.0+ A component providing waterfall layout over list component. Child Components#Notes: The waterfall only supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell: presents the content for a single data item in waterfall header: components that need to stretch across multiple columns. It can be sticky by using css position. Attributes# column-width : This property describes the width of columns in waterfall elements. auto: means that the column width will be determined by other properties(e.g., column-count, if it has a non-auto value). &lt;length&gt;: describes the optimal column width. The actual column width may be wider (to fill the available space), or narrower (only if the available space is smaller than the specified column width). Specified values must be greater than 0. column-count:This property describes the number of columns of a multicol element. auto: means that the number of columns will be determined by other properties (e.g., column-width, if it has a non-auto value). &lt;integer&gt;: describes the optimal number of columns into which the content of the element will be flowed. Values must be greater than 0. If both column-width and column-count have non-auto values, the integer value describes the maximum number of columns. column-gap:sets the gap between columns. if normal is specified, the gap will be 32. left-gap:sets the gap between left edge and left cell. if none is specified, the gap will be 0v0.19+. right-gap:sets the gap between right edge and right most cell. if none is specified, the gap will be 0v0.19+. To see other attributes in list, please checkout List Component Attributes Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All subcomponents in waterfall support the scrollToElement API in dom module Example#waterfall example","type":"references"},{"title":"<web>","path":"references/components/web.html","permalink":"https://weex.apache.org/references/components/web.html","text":"v0.5+ &lt;web&gt; is used to display web content that specified by src attribute in weex page. You also can use webview module to control WebView behavior such as goBack, goForward and reload, See webview module for more information. Basic Usage# Note: &lt;web&gt; does not support any nested child components, and must specific width and height in style attribute, otherwise it won’t work. &lt;web src=\"https://vuejs.org\"&gt;&lt;/web&gt; See the example. Attributes# Attribute Type Value Default Value src String {URL} - src#A URL value for web content to be loaded. You can specify a URL which is relative to bundle URL, it will be rewritten to the real resource URL (local or remote). See also: Path. Events#Only support appear and disappear event in common events. pagestart#pagestart event handler will be called when the web content is start loading. Event object: url: {String} URL of current web content. pagefinish#pagefinish event handler will be called when the web content is loaded. Event object: url: {String} URL of current web content. canGoBack: {Boolean} Can current web content go back. canGoForward: {Boolean} Can current web content go forward. title: {String} Title of current web content (iOS platform only). error#error event handler will be called when the web content loaded failed. receivedtitle#receivedtitle event handler will be called when the title of web content had changed (Android platform only). Event object: url: {String} URL of current web content. Handle &lt;web&gt; Events#Bind events on &lt;web&gt;: &lt;web @pagestart=\"onPageStart\" @pagefinish=\"onPageFinish\" @error=\"onError\" src=\"https://vuejs.org\"&gt;&lt;/web&gt; Add event handler: export default &#123; methods: &#123; onPageStart (event) &#123; // page start load &#125;, onPageFinish (event) &#123; // page finish load &#125;, onError (event) &#123; // page load error &#125;, &#125;&#125; See the example. Styles#Support common styles. Usage Notes# The width and height in the styles of &lt;web&gt; must be specified. &lt;web&gt; can not have any nested child component. You can use webview module to control &lt;web&gt; component, see the example. Examples# Browser example","type":"references"},{"title":"animation","path":"references/modules/animation.html","permalink":"https://weex.apache.org/references/modules/animation.html","text":"Animation#Overview#The animation module is used to perform animation on components. JS-Animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component with Javascript. For example, if you have a image component, you can move, rotate, grow, or shrink it by animation. Note: Now,Weex only support use animation in Javascript. CSS Animation is different from this,we will soon support CSS Animation. Basic Usage#animation.transition(el, options, callback)#animation.transition(ref1, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(250px, 100px)', &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) Attributes#el#An element that will be animated. For example , specify the el attribute for the element you want to animated as element, so you can get this element by calling this.refs.element. options# styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value width The width applied to the component after the animation finished. length none height The height applied to the component after the animation finished. length none backgroundColor The background color applied to the component after the animation finished. string none opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center transform Transform function to be applied to the element. The properties in the following table are supported object none transform also have many parameters,please see the table below. name description value type default value translate/translateX/translateY Specifies the location of which the element will be translated to. pixel or percent none rotate/rotateX v0.14+ /rotateY v0.14+ Specifies the angle of which the element will be rotated, the unit is degree. number none perspective v0.16+ The distance between the z=0 plane and the user in order to give to the 3D-positioned element some perspective. Supported for Android 4.1 and above. number positive infinity scale/scaleX/scaleY Stretch or shrink the element. number none duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. needLayout(boolean)：Whether or not the layout animation occurs when animation is executed，default value is false timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description linear Specifies a transition effect with the same speed from start to end ease Specifies a transition effect with a slower and slower speed ease-in Specifies a transition effect with a slow start ease-out Specifies a transition effect with a slow end ease-in-out Specifies a transition effect with a slow start and end cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. callback#Callback which is a function called after the completion of animation. In iOS platform, you can use function to get animation processing’s information. Note: after WeexSDK0.16.0, in iOS platform can get animation’s message about completion, there are two types of parameters with result, is Successand Fail, Android can not support until now. Example# animation demo","type":"references"},{"title":"clipboard","path":"references/modules/clipboard.html","permalink":"https://weex.apache.org/references/modules/clipboard.html","text":"clipboard#v0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution# only support text. only works on Android and iOS. NOT works for html5, for web security reason. API#getString(callback)#reads from clipboard. Arguments#callback(function): the callback function after executing this action. data is the return value. setString(text)#sets the text to clipboard, having the same effect as copying manually. Arguments#text(string): the text copied to clipboard. Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"references/modules/custom_font.html","permalink":"https://weex.apache.org/references/modules/custom_font.html","text":"Custom Font v0.12.0+#OverView#Weex provide the ability of loading custom through DOM.addRule. Developers can load iconfont and custom font by specifying the font-family. API#Developers may use the following code snippet to load their font: const domModule = weex.requireModule(&apos;dom&apos;) domModule.addRule(&apos;fontFace&apos;, { &apos;fontFamily&apos;: &quot;iconfont2&quot;, &apos;src&apos;: &quot;url(&apos;http://at.alicdn.com/t/font_1469606063_76593.ttf&apos;)&quot; }); The parameter of Add Rule is illustrated as following: fontFace You should not change this as this is the name of the font rule fontFamily You should provide the name of your font-family there, the valid name should be a string. src The src of your custom font, and url(‘’) is reserved for protocol reason, the supported parameters are listed below: http. Read from http, e.g. url(&#39;http://at.alicdn.com/t/font_1469606063_76593.ttf&#39;) https. Read from https, e.g. url(&#39;https://at.alicdn.com/t/font_1469606063_76593.ttf&#39;) local, Android ONLY. Read from assets directory e.g. url(&#39;local://foo.ttf&#39;), the foo.ttf is in your android assets directory. file. Read from a local file, e.g. url(&#39;file://storage/emulated/0/Android/data/com.alibaba.weex/cache/http:__at.alicdn.com_t_font_1469606063_76593.ttf&#39;) data. Read from a base64 data source, e.g. url(&#39;data:font/truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwR1NVQrD+....&#39;), the above data field is only a part of the actual data. Note# Note: You can name fontFamily in addRule as you wish in your page, any string is OK. But this is not the real font-family name of the font file. The real name or system name for the font is stored in binrary data of ttf file. You must ensure that the real font-family name of font file is unique. Or your font may not be successfully registered to device and your text may display as a ‘?’. Note: Specially, if you are using http://www.iconfont.cn/ to build your iconfont. Make sure that you set a unique enough font-family name for your font in project settings. Note: Calling addRule in beforeCreate is recommended. Example#Check the custom font example.","type":"references"},{"title":"custom font","path":"references/modules/dom.html","permalink":"https://weex.apache.org/references/modules/dom.html","text":"Dom#Overview#The dom module is used to manipulate the components in weex pages. You can use these APIs to get a component’s bounding rect in the page, or scroll a list to some specific component, or add a font-face rule to the page and so on. Note: The addRule method is currently used only with font-face supportability. API#scrollToElement(ref, options)#Scroll the scrollable component to the referenced component. This API should only be used in the children components of a scrollable component, such as in a &lt;scroller&gt; or &lt;list&gt; component. NOTE: You can use weex.requireModule(&#39;dom&#39;) to requrie the dom module, and use weex.requireModule(&#39;dom&#39;).scrollToElement to call this API. Arguments# ref(Node): the referenced component who is meant to scroll into the view. options(object): offset(number): An space on top of the ref component, which is also scrolling down to the visual viewport. Default is 0. animated (bool): 0.10+ Indicates whether a scroll animation should be played. If set to false, the ref component will jump into the view without any transition animation. Default is true. Example#Scroll To Floor getComponentRect(ref, callback) v0.9.4+#support: &gt;=0.9.4 You can get the bounding rect of the referenced component using this API. An example callback result should be like: &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; If you want to get the bounding rect of outside viewport of the weex container, you can specify the ref as a literal string &#39;viewport&#39;, like getComponentRect(&#39;viewport&#39;, callback). Example#get box’s rect addRule(type, contentObject) v0.12.0+#support: &gt;=0.12.0 Reference custom Font for more detail.","type":"references"},{"title":"globalEvent","path":"references/modules/globalevent.html","permalink":"https://weex.apache.org/references/modules/globalevent.html","text":"globalEvent#v0.8+ Summary#globalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removeEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global events#API development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) Example#Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\", params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#register global event. Arguments# eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#remove global event Arguments# eventName(string): You no longer need to listen for event names. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\"); Built-in global event#0.14 background or foreground event#You can specify the event name as WXApplicationDidBecomeActiveEvent or WXApplicationWillResignActiveEvent to obtain application becoming foreground or background, so that you can pause your video or music at this time.For example var globalEvent = weex.requireModule(&apos;globalEvent&apos;);globalEvent.addEventListener(&quot;WXApplicationDidBecomeActiveEvent&quot;, function (e) &#123; console.log(&quot;WXApplicationDidBecomeActiveEvent&quot;);&#125;); WXApplicationDidBecomeActiveEvent fired while application did become foreground WXApplicationWillResignActiveEvent fired while application will become background have a try at DotWe this feature only works on iOS and Android platforms, it doesn’t work on Web. Obtain your weex platform on weex page","type":"references"},{"title":"meta","path":"references/modules/meta.html","permalink":"https://weex.apache.org/references/modules/meta.html","text":"meta#The meta module can be used to update meta information for a single page, such as the viewport of the container. API#setViewport(options)#0.10.0+ The default width (viewport) of Weex container is 750px. The setViewport method can change the viewport of the page and only takes effect on the current page. Notice: The viewport must be set before the page rendering starts. In other words, the setViewport method can only be used in the entry file, and before the new Vue (...) statement. If it’s used in the component, the code is executed only when the component is being rendered, meanwhile, the page is already in the rendering process, set the viewport will not take effect again. it is only in the rendering of the components will be implemented The corresponding code, Parameters#Referance: W3C Spec CSS Device Adaptation. options: viewport configuration width: Number or &quot;device-width&quot; or &quot;device-height&quot;. height: Number or &quot;device-width&quot; or &quot;device-height&quot;. The default unit of the width and height is px, other units are not supported. Example#The entry file: // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// The width of the viewport is set to 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) After configuring the width of the viewport to 640 in the entry.js, all the components in the current page will take 640px as full screen width. Example component: &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; Try it. (The http://dotwe.org doesn’t support to configure the entry file currently.) Referance: Set up development environment.","type":"references"},{"title":"modal","path":"references/modules/modal.html","permalink":"https://weex.apache.org/references/modules/modal.html","text":"modal#Weex provides a series of message boxes: toast, alert, confirm and prompt. API#toast(options)#A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments# options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. For Android: If the duration is longer than 3, it will use a system defined variable called LONG, otherwise it will use another variable called SHORT For iOS: It will show the toast during the specified time. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.toast(&#123; message: &apos;This is a toast&apos;, duration: 0.3&#125;) alert(options, callback)#An alert box is often used if you want to make sure information comes through to the user.When an alert box pops up, the user will have to click “OK” to proceed. Arguments# options (object): alert box options. message (string): the text message that the alert shows. okTitle (string): the text of positive button, default is ‘OK’. callback (function): callback when complete.This method has a callback function whose arguments will be: result (string): the title text of the confirm button that clicked by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.alert(&#123; message: &apos;This is a alert&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;alert callback&apos;, value)&#125;) confirm(options, callback)#A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments# options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.confirm(&#123; message: &apos;Do you confirm ?&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;confirm callback&apos;, value)&#125;) prompt(options, callback)#A prompt box is often used if you want the user to input a value before entering a page.When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. Arguments# options (object): some options. message (string): the message that the prompt shows. okTitle (string): the title text of confirm button, default is ‘OK’. cancelTitle (string): the title text of cancel button, default is ‘Cancel’. callback (function): callback when complete.This method has a callback function whose arguments will be: ret (object): the argument will be a object, which has attributes result and data, like { result: &#39;OK&#39;, data: &#39;hello world&#39; } result (string): the title of the button that clicked by user. data (string): the value of the text that entered by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.prompt(&#123; message: &apos;This is a prompt&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;prompt callback&apos;, value)&#125;) Example#Modal demo","type":"references"},{"title":"navigator","path":"references/modules/navigator.html","permalink":"https://weex.apache.org/references/modules/navigator.html","text":"Navigator#v0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can specify whether to apply animation or not during the transition. API#push(options, callback)#Push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. Arguments options(object): some options. url(string): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. Example var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal')var bundleUrl = weex.config.bundleUrl;navigator.push(&#123; url: bundleUrl, animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) pop(options, callback)#pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. Arguments options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. Example var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal')navigator.pop(&#123; animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) Notice#Due to the differences in the behavior of the navigation in clients, the above interfaces need to be adapted. You can implement the above interfaces on the client side by seeing the description of the navigation protocol. In addtion，you can read [How to extend] (https://github.com/apache/incubator-weex-site/blob/master/source/guide/extend-ios.md) in iOS/Android to learn how to register the implementation the protocol on the client. try it","type":"references"},{"title":"picker","path":"references/modules/picker.html","permalink":"https://weex.apache.org/references/modules/picker.html","text":"picker#v0.9+ Summary#A series of stream api. It provides function: pick data,pick date,pick time API#pick(options, callback[options])#pick data(single column) Arguments# options {Object}:pick options index {number}:default selected row items {array}:picker’s data textColor {color}：text color in the picker item selectionColor {color}：the background color of the selected item in the picker confirmTitle {string}：confirm button text cancelTitle {string}：cancel button text confirmTitleColor {color}：confirm button text color cancelTitleColor {color}：cancel button text color title {string}：title of dialog titleColor {color}：text color of the dialog title titleBackgroundColor {color}：background color of the dialog title callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {number}:the selected index,it exists when result is success. pickDate(options, callback[options])#pick date Arguments# options {Object}:pick date options value {string}:Required，date picker selected value by default，date’s form is yyyy-MM-dd max {string}:optional，date’s max value min {string}:optional，date’s min value callback {function (ret)}：the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is yyyy-MM-dd ,it exists when result is success. pickTime(options, callback[options])#pick time Arguments# options {Object}:pick time options value {string}:required，the form of value is HH:mm callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter： result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is HH:mm,it exists when result is success. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"storage","path":"references/modules/storage.html","permalink":"https://weex.apache.org/references/modules/storage.html","text":"storage#v0.7+ Summary#storage is a series of apis, support add, modify and delete stored data. Cauction: There is NO same-origin-policy in weex storage moudle. Any one can access any key, even can change the value. So be careful of your usage. API#setItem(key, value, callback)#When passed a key and a value, it will saved into the storage,or update the value if the key already exists. Arguments# key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. getItem(key, callback)#When passed a key, will return that key’s value. Arguments# key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. removeItem(key, callback)#When passed a key, will remove that key and value from the storage. Arguments# key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Example#var storage = weex.requireModule('storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)#Returns an integer representing the number of key-value items stored in the storage. Arguments# callback(object): the callback function after executing this action. getAllKeys(callback)#Returns an array that contains all keys stored in the storage. Arguments# callback(object): the callback function after executing this action. Example#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"stream","path":"references/modules/stream.html","permalink":"https://weex.apache.org/references/modules/stream.html","text":"stream#A series of stream api. It provides a network request. API#fetch(options, callback,progressCallback)#Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): response type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Note# Default Content-Type is ‘application/x-www-form-urlencoded’. (The type specified in fetch is the response type!) You need to set the Content-Type header to ‘application/json’ manually if you want to post the json body. Example#stream demo","type":"references"},{"title":"webSocket","path":"references/modules/websocket.html","permalink":"https://weex.apache.org/references/modules/websocket.html","text":"webSocket#v0.12+ Summary#WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user’s H5/iOS/android and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply Notes:# iOS and h5 provide webSocket default handle. if you use webSocket in android environment . you should provide custom adapter implementation,source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; refer: weex playground API#WebSocket(url, protocol)#create websocket Arguments# url {string}:The URL to which to connect; protocol {string}:the websocket protocol send(data)#Transmits data to the server over the WebSocket connection Arguments# data {string}:A text string to send to the server. close(code,reason)#Closes the WebSocket connection or connection attempt, if any. If the connection is already CLOSED, this method does nothing. Arguments# code {number}: the status code explaining why the connection is being closed. reason {string}:a string explaining why the connection is closing onopen(options)#An event listener to be called when the WebSocket connection’s readyState changes to OPEN; this indicates that the connection is ready to send and receive data. Arguments# options {object}:an empty object onmessage(options)#An event listener to be called when a message is received from the server Arguments# options {object}:the server message options data {string}: The listener received message onclose(options)#An event listener to be called when the WebSocket connection’s readyState changes to CLOSED Arguments# options {object}:the CloseEvent is sent to clients using WebSockets when the connection is closed code {number}: Returns an unsigned short containing the close code send by the server reason {string}: Returns a string indicating the reason the server closed the connection wasClean {boolen}: Returns a Boolean that Indicates whether or not the connection was cleanly closed. onerror(options)#An event listener to be called when an error occurs. Arguments# options {object}:the error event data {string}: The listener received error data Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"references/modules/webview.html","permalink":"https://weex.apache.org/references/modules/webview.html","text":"webview module provides a series of web operation API like goBack, goForward, and reload. Usually used with the &lt;web&gt; component. API#goBack(webElement)#Goes to the previous page in WebView’s session history. Arguments webElement(web): the element of the &lt;web&gt; component. goForward(webElement)#Goes to the next page in WebView’s session history. Arguments webElement(web): the element of the &lt;web&gt; component. reload(webElement)#Reloads the current web page. Arguments webElement(web): the element of the &lt;web&gt; component. Examples# Simple useage: var webElement = this.$el('webview');var webview = weex.requireModule('webview');webview.goBack(webElement.ref);webview.goForward(webElement.ref);webview.reload(webElement.ref); Browser example","type":"references"},{"title":"构建完整移动应用","path":"cn/guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/app-architecture.html","text":"今天的移动应用 移动应用需要支撑并行研发 移动应用需要动态性 移动应用需要开放互联 整体结构设计 今天的移动应用#这里谈一谈 Weex 对移动应用的理解。 移动应用需要支撑并行研发#如今移动应用的开发需要并行研发的能力，当一个移动应用发展到一定规模的时候，能否支撑大规模的并行研发就成为了一件非常关键而又重要的事情。否则很容易变成工程瓶颈。 移动应用需要动态性#如今移动应用不论从研发节奏、部署的灵活性和时效性、包大小、还是从研发到发布再到反馈的迭代周期上，都和移动互联网的发展速度极不相符。移动应用需要更简单轻量的研发模型，需要摆脱版本部署和分发的笨重过程。 移动应用需要开放互联#如今移动应用的内容和信息都是相互孤立的，应用之间的交流变得非常复杂和困难，也缺乏一定的标准和规范化的容器来承载。 整体结构设计#我们认为一个具有高并行研发能力、动态化和标准化规范化的移动应用应该由以下几个方面构成： |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| 页面：首先移动应用应该可以被拆解成若干个页面，每个页面相对解耦独立，同时每个页面都有一个 URL 进行唯一标识。 路由：这些页面将会通过路由机制有机的串联起来，页面之间的关系是通过路由来进行调度的。常见的移动应用路由包括导航栏、tab 切换等。 设备能力：以各种 API 或服务的方式提供出来，供页面自由使用。 这样的话，在构建一个完整的移动应用之前，先确定你的应用有多少页面，每个页面分别是什么 URL，页面之间的关联和跳转逻辑是怎样的，然后梳理整个移动应用需要的所有 API 和服务。 然后通过 Weex 创建不同的页面，并分别进行开发、调试和发布。 相关链接 页面结构 如果你已经有一个做好的移动应用，只想用 Weex 开发其中的一部分页面甚至仅仅其中的一两个页面，这对 Weex 来说完全不是问题。Weex 只是一个 SDK，对整体的移动应用架构不会产生任何侵入性。并且完全可以和纯 native 界面或 hybrid 页面共存。 如果需要 WeexSDK 额外的组件、模块或其它功能，可以通过 Weex 的扩展机制进行扩展。这部分工作需要 native 的研发知识，但是随着 Weex 组件和模块的丰富以及业务迭代的深入，这部分成本会呈下降和收敛的趋势。 相关链接 如何扩展 iOS 如何扩展 Android 如何扩展 HTML5 如何扩展前端框架","type":"guide"},{"title":"降级方案","path":"cn/guide/advanced/downgrade.html","permalink":"https://weex.apache.org/cn/guide/advanced/downgrade.html","text":"Weex 2.0 降级方案改成模块的形式支持，具体请参考downgrade","type":"guide"},{"title":"Weex 页面结构","path":"cn/guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/page-architecture.html","text":"界面 DOM 模型 组件 布局系统 功能 生命周期 对于一个 Weex 页面来说，在移动设备上它就是一个相对独立解耦的移动应用界面，它不仅包括了界面展示，也包含了应用逻辑、设备能力、生命周期管理等部分。 界面#DOM 模型#Weex 页面通过类似 HTML DOM 的方式管理界面。首先，Weex 会在 JavaScript 执行环境中将界面模板解析为 Virtual DOM 树表示，每个 DOM 节点都代表了一个相对独立的 native 视图的单元；再将该 Virtual DOM 映射到移动设备上，生成用于表示移动设备界面的 Native DOM 树，最后再使用移动控件将之渲染为真正的界面。 关于 Virtual DOM 和 Native DOM，可以通过weex debugger中的Element Mode选项查看。 组件#Weex 支持文字、图片、视频等内容型组件，也支持 div、list、scroller 等容器型组件，还包括 slider、input、textarea、switch 等多种特殊的组件。Weex 的界面就是由这些组件以 DOM 树的方式构建出来的。 组件分为内置组件和扩展组件两类，内置组件随Weex SDK提供，提供构建界面的基础能力；如果觉得不够用或者满足不了特定使用需要，Weex也支持开发者自己创建扩展组件，并通过Weex提供的注册接口将组件集成到应用中使用。 相关链接 Weex 组件列表 布局系统#Weex 页面中的组件会按照一定的布局规范来进行排布，我们这里提供了 CSS 中的盒模型、flexbox 和 绝对/相对/固定/吸附布局这三大块布局模型。 盒模型：通过宽、高、边框、内外边距、边框等 CSS 属性描述一个组件本身的尺寸。 flexbox：通过 CSS 3 Flexbox 布局规范定义和描述组件之间的空间分布情况。 position：支持 CSS position 属性中的 absolute, relative, fixed, sticky 位置类型，其中 relative 是默认值。 功能#Weex 提供了非常丰富的系统功能 API，包括弹出存储、网络、导航、弹对话框和 toast 等，开发者可以在 Weex 页面通过获取一个 native module 的方式引入并调用这些客户端功能 API。 开发者也可以通过Weex提供的 Module 扩展能力，注册自定义的 API 使用。 相关链接 Weex 模块列表 生命周期#每个 Weex 页面都有其自身的生命周期，页面从开始被创建到最后被销毁，会经历到整个过程。这是通过对 Weex 页面的创建和销毁，在路由中通过 SDK 自行定义并实现的。 由于 Weex 内置 Vue，对于 Vue 实例的生命周期回调 Weex 提供原生支持，具体可参照 Vue 生命周期相关文档。","type":"guide"},{"title":"使用 Vuex 和 vue-router","path":"cn/guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/cn/guide/advanced/use-vuex-and-vue-router.html","text":"使用 Vuex 使用 vue-router 路由模式 编程式导航 Vue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 注意： Weex 使用原生的 navigator 来管理页面实例，多个实例之间的状态是隔离的。也就是说，Vuex 和 vue-router 只能作用于当前一个页面，无法在多个页面间共享状态。 使用 Vuex# Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具库，可以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 由于在 Vuex 本身就是平台无关的，有较强的移植能力，完全可以在 Weex 中正常地使用 Vuex。 Vuex 也集成到了其官方调试工具 devtools extension中，提供了诸如 time-travel 调试、状态快照导入导出等高级调试功能。这些工具在 Web 平台中可以一如既往地工作。 使用 vue-router#vue-router 是专为 Vue.js 开发的便于实现单页应用的工具库，能够以声明式的方法编写页面的导航和跳转信息。 由于 Weex 的运行环境不只是浏览器，通常是以移动端原生环境为主，然而在 Android 和 iOS 中都没有浏览器的 History API，也不存在 DOM，因此如果想在 Weex 环境中使用 vue-router ，有些功能受到了限制，使用时应该注意。 路由模式#vue-router 提供了三种运行模式： hash: 使用 URL hash 值来作路由。默认模式。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 配置方法是在定义路由时，传递 mode 属性： new Router(&#123; mode: 'abstract', // ...&#125;) 从三种模式的介绍中也可以看出来，Weex 环境中只支持使用 abstract 模式。不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以在使用时只要不写 mode 配置即可。默认 vue-router 会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 编程式导航#vue-router 中使用 &lt;router-link&gt; 创建导航链接，不过在其中使用了基于 DOM 事件的一些特性，在 Weex 原生环境中并不能很好的工作。在 Weex 中，你必须使用编程式导航来编写页面跳转逻辑。 编程式导航其实就是通过主动调用 router 实例上的 push 方法实现跳转。 使用 &lt;router-link&gt; 的代码示例： &lt;!-- 只能在 Web 中使用，Native 环境不支持！ --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在 Weex 中，需要写成这个样子： &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"资源路径","path":"cn/guide/advanced/path.html","permalink":"https://weex.apache.org/cn/guide/advanced/path.html","text":"Schemes 相对路径 URI Adapter v0.9+ 本文将介绍 Weex 中 uri(url) 的用法。包括使用图像、字体等资源，处理相对路径以及如何访问本地及打包的资源文件。 Schemes# 本地资源 Weex SDK 提供 local scheme 来访问打包在应用程序中的资源，此 scheme 无法在 H5 环境下使用。目前，开发者可以在 image 组件和字体文件中使用本地资源。 在 iOS 中，Weex 会在 bundle resources 中查找。例如，image 组件的 src 属性为 local:///app_icon&#39;， Weex 会加载 bundle resouce 中名为 app_icon 的图像资源，而字体文件也以相同的方式工作。 在 Android 中，image 组件将从 drawable 资源文件夹加载，如 res/drawable-xxx。但加载字体文件是不同的，Android 框架无法从 res 加载字体文件，因此 SDK 将从 asserts 文件夹加载它。 HTTP/HTTPS 它的工作方式与 web 相同，Weex 一直支持这种方式。 File 使用 file scheme 访问本地磁盘文件。这个方案有其局限性：你不应该在源页面中硬编码文件 url。因为不管它是否在不同的平台（iOS，Android）上运行，内容将在另一个设备上完全不同，这取决于具体的设备。 所以一种可行的方案是在运行时动态获取文件 url，你可以使用它来显示本地磁盘的图像，或者稍后上传它。 相对路径#与我们在 HTML 中的用法类似，Weex 以相同的方式处理相对路径。以/、.、..、// 开头的相对 URI 将相对于 bundle url 解析。 这意味着， 一个以 / 开头的路径将是相对于 JS Bundle 文件的根文件夹。. 则是当前文件夹，.. 是父文件夹。 // 则被解析为与 JS Bundle 相同的 scheme。 URI Adapter#以上所有是默认实现，开发者可以通过提供一个 URI Adapter 来扩展或覆盖默认实现。与其他 Adapter 相同，应在 Weex SDK 初始化之前设置自定义 Adapter。","type":"guide"},{"title":"<a>","path":"cn/references/components/a.html","permalink":"https://weex.apache.org/cn/references/components/a.html","text":"&lt;a&gt; 用于实现页面间的跳转。 注意： 除了本文档中注明的特性，\b&lt;a&gt;\b 的表现同 &lt;div&gt; 一致。 注意： 不能在 &lt;a&gt; 中直接添加\b匿名文本，请用\b &lt;text&gt; 包裹文本。 基本用法#用 \b&lt;a&gt; \b将待跳转的元素包裹起来即可。 &lt;a href=&quot;http://dotwe.org/raw/dist/a5e3760925ac3b9d68a3aa0cc0298857.bundle.wx&quot;&gt; &lt;text&gt;Jump&lt;/text&gt; &lt;/a&gt; 参见示例。 属性# 属性名 类型 值 默认值 href String {URL} - - href#待跳转的页面URL，待跳转页面需要是一个Weex页面。如果\b待跳转页面是一个普通HTML\b\b，\b这会是一个未定义行为。 样式#&lt;a&gt; 支持通用样式。 事件#&lt;a&gt;支持 通用事件. click# 注意： click 事件的回调函数和 href 跳转的执行顺序未被定义。不要使用 click 来进行 href 跳转前的逻辑处理。 示例# &lt;a&gt; 的基本用法。","type":"references"},{"title":"<cell>","path":"cn/references/components/cell.html","permalink":"https://weex.apache.org/cn/references/components/cell.html","text":"&lt;cell&gt;#用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; &lt;recycler&gt; &lt;waterfall&gt;组件的子组件, 这是为了优化滚动时的性能。 子组件#支持所有 Weex 的组件作为它的子组件。 属性# keep-scroll-position {boolean}: v0.11+ List 插入数据后是否保持上次滚动的位置 样式#注意： 由于 &lt;cell&gt; 本身是一个容器，其布局由 &lt;list&gt; 进行管理，你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应，指定 margin 样式也不起作用。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#cell 示例","type":"references"},{"title":"<div>","path":"cn/references/components/div.html","permalink":"https://weex.apache.org/cn/references/components/div.html","text":"&lt;div&gt;#&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70px; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件#&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式#&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件#&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束# 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 在 native 中不可滚动，即使显式设置高度也一样。 错误示例 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<image>","path":"cn/references/components/image.html","permalink":"https://weex.apache.org/cn/references/components/image.html","text":"&lt;image&gt; 用于在界面中显示单个图片。 注意：在HTML中通常使用的 &lt;img&gt; 标签在 Weex 中不支持，你应该使用&lt;image&gt; 。 注意： Weex 没有内置的图片下载器，因为相关的下载、缓存、解码机制非常复杂，一些开源的工具如 SDWebImage 已经处理得很好， 所以在使用 &lt;image&gt; 之前，请在 native 侧先接入相应的 adapter 或者 handler。 参见: Android adapter 和 iOS handler。 基本用法# 注意： 必须指定样式中的宽度和高度，否则无法工作。 &lt;image style=\"width:500px;height:500px\" src=\"https://vuejs.org/images/logo.png\"&gt;&lt;/image&gt; 参见示例。 属性# 属性名 类型 值 默认值 placeholder String {URL / Base64} - resize String cover / contain / stretch stretch src String {URL / Base64 } - 注意：您可以指定一个相对 bundle URL 的相对路径，相对路径将被重写为绝对资源路径(本地或远程)。参见: 资源路径。 placeholder#占位图的 URL，当由 src 表示的图片下载完成并展示后将被删除。 (示例) resize# contain：缩放图片以完全装入&lt;image&gt;区域，可能背景区部分空白。 (示例) cover：缩放图片以完全覆盖&lt;image&gt;区域，可能图片部分看不见。 (示例) stretch：默认值. 按照&lt;image&gt;区域的宽高比例缩放图片。(示例) 参见: background-size. src#要显示图片的 URL，该属性是 &lt;image&gt; 组件的强制属性。 支持的图片格式#Weex没有提供必须支持的图片格式列表，主要依赖于你正在使用的图片 adapter 或者 handler。例如，如果你使用 SDWebImage 作为iOS上的图片 handler，你可以使用像 JPEG、PNG、GIF、WebP 等图片格式。 Component 方法#save v0.16.0+#保存图片内容到本地文件或相册，此操作可能需要设备相关权限。 参数: callback：{Function} 在图片被写入到本地文件或相册后的回调，回调参数： result：{Object} 回调结果对象，属性列表： success：{Boolean} 标记图片是否已写入完成。 errorDesc：{String} 如果图像没有成功写入，该字符串包含了详细的错误描述。 返回值: null 注意: 你必须加入NSPhotoLibraryAddUsageDescription 和 NSPhotoLibraryAddUsageDescription (iOS 11) 以获得访问 iOS 系统相册权限. 参见: Cocoa Keys 使用 save 方法#在 &lt;image&gt;标签上增加 ref 属性 (Vue.js Child Component Refs) ： &lt;image ref=\"poster\" src=\"path/to/image.png\"&gt;&lt;/image&gt; 获取组件引用并使用 save 方法: const $image = this.$refs.poster$image.save(result =&gt; &#123; if (result.success) &#123; // Do something to hanlde success &#125; else &#123; console.log(result.errorDesc) // Do something to hanlde failure &#125;&#125;) 参见 完整例子. 事件#支持 通用事件. load#当加载完成 src 指定的图片时，load事件将被触发。 事件对象: success: {Boolean} 标记图片是否成功加载。 size: {Object} 加载的图片大小对象，属性列表： naturalWidth: {Number} 图片宽度，如果图片加载失败则为0。 naturalHeight: {Number} 图片高度，如果图片加载失败则为0。 处理 load 事件#在 &lt;image&gt; 标签上绑定 load 事件： &lt;image @load=\"onImageLoad\" src=\"path/to/image.png\"&gt;&lt;/image&gt; 增加事件处理函数： export default &#123; methods: &#123; onImageLoad (event) &#123; if (event.success) &#123; // Do something to hanlde success &#125; &#125; &#125;&#125; 参见完整示例。 样式#支持通用样式。 使用说明# 在使用 &lt;image&gt; 之前，请在 native 侧先接入相应的 adapter 或者 handler。 &lt;image&gt; 必须指定样式中的宽度和高度。 &lt;image&gt; 不支持内嵌子组件。 示例# Base64 示例 Multi-layer images 示例 Lazy load image 示例","type":"references"},{"title":"<indicator>","path":"cn/references/components/indicator.html","permalink":"https://weex.apache.org/cn/references/components/indicator.html","text":"&lt;indicator&gt;#&lt;indicator&gt; 组件通常用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件#&lt;indicator&gt; 组件没有任何子组件。 样式#&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：indicator指示点未被选中时的\b颜色，默认值为 #CCCCCC item-selected-color {color}：indicator指示点被选中时的颜色，默认值为 #444444 item-size {number}：指示点的半径，默认为 5px 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width 和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件#支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束# 不支持子组件，向 indicator 中添加的所有子元素都会被忽略。 示例#查看完整示例","type":"references"},{"title":"<input>","path":"cn/references/components/input.html","permalink":"https://weex.apache.org/cn/references/components/input.html","text":"&lt;input&gt;#Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 text， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 input 或 change 来代替 click 事件。 子组件#不支持子组件。 特性# type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，date，datetime，email， password，tel，time，url，number 。每个 type 值都符合 W3C 标准。 value {string}：组件的默认内容。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 return-key-type {string}：v0.11键盘返回键的类型,支持 defalut;go;next;search;send,done。 auto-capitalization-type {string}：键盘自动大小写类型,支持 none;words;sentences;allCharacters singleline {boolean}：控制内容是否只允许单行 max-length {number}：控制输入内容的最大长度 lines：控制输入内容的最大行数 max：控制当type属性为date时选择日期的最大时间，格式为yyyy-MM-dd min：控制当type属性为date时选择日期的最小时间，格式为yyyy-MM-dd 样式# placeholder-color {color}：placeholder 字符颜色。默认值是 #999999 伪类v0.9.5+: input 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 return: 键盘点击返回键。 事件中 event 对象属性： returnKeyType: 事件发生时的返回键类型。 value: 触发事件的组件的文本； 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 Methods# focus() v0.9+ focus() 方法用于将 input 组件聚焦。 blur() v0.9+ blur() 方法用于从 input 组件中移除焦点并关闭软键盘（如果它具有焦点）。 setSelectionRange(selectionStart,selectionEnd) v0.11+设置文本选区 selectionStart {number}：设置文本选区的起始点 selectionEnd {number}：设置文本选区的起终点 getSelectionRange(callback[selectionStart,selectionEnd]) v0.11+设置文本选区 selectionStart {number}：获取文本选区的起始点 selectionEnd {number}：获取文本选区的起终点 setTextFormatter(params)v0.18+：这是一个非常有用的特性，可以对input设置一组对输入的内容进行实时格式化的规则。 params {object}：格式化规则，包含以下参数： formatRule {regexp}：格式化匹配的正则表达式 formatReplace {string}：格式化匹配后用于替换的内容 recoverRule {regexp}：从格式化后的内容还原原始内容的正则表达式 recoverReplace {string}：还原原始内容时用于替换的内容 setTextFormatter 的详细使用方法请参照 示例 约束#目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<list>","path":"cn/references/components/list.html","permalink":"https://weex.apache.org/cn/references/components/list.html","text":"&lt;list&gt;#&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 子组件#&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 特性# show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 pagingEnabled {boolean}：可选值为 true/ false，默认值为 false。控制是否每次滚动一个cell，并最终定位在元素中心位置，类似垂直的viewpage交互。则对应 0v0.20+.[pagingEnabled示例]（http://dotwe.org/vue/1323c218072f17f10e14a5c336dac3c4） 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 简单示例 滑动加载示例 头部sticky示例 cell appear事件 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 约束# 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例#滑动加载","type":"references"},{"title":"<loading>","path":"cn/references/components/loading.html","permalink":"https://weex.apache.org/cn/references/components/loading.html","text":"&lt;loading&gt;#v0.6.1+#&lt;loading&gt; 为容器提供上拉加载功能，用法和属性与 &lt;refresh&gt; 类似。 注意：&lt;loading&gt; 是 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 的子组件，只能在被它们包含时才能被正确渲染。 简单示例： &lt;list&gt; ... ... &lt;loading&gt; ... &lt;/loading&gt;&lt;/list&gt; 查看 完整示例 子组件# 诸如 &lt;text&gt;、&lt;image&gt; 之类的任何组件，都可以放到 &lt;loading&gt; 进行渲染。 特殊子组件 &lt;loading-indicator&gt;: 只能作为 &lt;refresh&gt; 和 &lt;loading&gt; 的子组件使用，拥有默认的动画效果实现。 简单示例： &lt;loading&gt; &lt;text&gt;Loading&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/loading&gt; 查看 完整示例 属性# 属性名 类型 值 默认值 display String show / hide show display# show：如果 &lt;loading&gt; 中包含 &lt;loading-indicator&gt;，则将其显示并开始默认动画。 hide：收起 loading view，如果 &lt;loading&gt; 中包含 &lt;loading-indicator&gt;，则将其视图隐藏。 注意： display 的设置必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 简单示例： &lt;template&gt; &lt;list&gt; ... ... &lt;loading @loading=&quot;onloading&quot; :display=&quot;loadinging ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/loading&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onloading (event) &#123; this.loadinging = true setTimeout(() =&gt; &#123; this.loadinging = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; 查看 完整示例 支持所有通用属性。查看 组件通用属性 样式# 支持所有通用样式。查看 组件通用样式 事件#loading# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被上拉时触发。 查看 完整示例 示例# 完整示例","type":"references"},{"title":"<recycle-list>","path":"cn/references/components/recycle-list.html","permalink":"https://weex.apache.org/cn/references/components/recycle-list.html","text":"基本用法 &lt;recycle-list&gt; for 属性 switch 属性 &lt;cell-slot&gt; case 属性 default 属性 key 属性 属性的省略 可复用的组件 实例 使用子组件 注意事项 属性和文本的绑定 &lt;slot&gt; 不可用 v-once 不会优化渲染性能 样式功能的限制 双向绑定 子组件的限制 更多例子 &lt;recycle-list&gt; v0.18+ 是一个新的列表容器，具有回收和复用的能力，可以大幅优化内存占用和渲染性能。 设计思路请参考 Design.md，具体的实现细节请参考 Implementation.md。 基本用法#原有 &lt;list&gt; 和 &lt;cell&gt; 组件的功能不受影响，针对新功能提供了新的 &lt;recycle-list&gt; 和 &lt;cell-slot&gt; 组件。如果想利用列表回收和复用的特性，使用新组件即可。 该功能部分依赖与编译工具，请确保 weex-loader 的版本升级到最新（v0.7.2+）。 &lt;recycle-list&gt;#&lt;recycle-list&gt; 是一个新的列表容器，只能使用 &lt;cell-slot&gt; 作为其直接子节点，使用其他节点无效。 for 属性#在 &lt;recycle-list&gt; 添加 for 属性即可描述如何循环展开列表的数据，语法和 Vue 的 v-for 指令类似，但是它循环的是自己内部的子节点，并不是当前节点。 for 属性支持如下两种写法： alias in expression (alias, index) in expression switch 属性#在 &lt;recycle-list&gt; 添加 switch 属性可以用来指定数据中用于区分子模板类型的字段名，语义和编程语言里的 switch 一致，配合 &lt;cell-slot&gt; 中的 case 和 default 属性一起使用。 如果省略了 switch 属性，则只会将第一个 &lt;cell-slot&gt; 视为模板，多余的模板将会被忽略。 &lt;cell-slot&gt;#&lt;cell-slot&gt; 代表的是列表每一项的模板，它只用来描述模板的结构，并不对应实际的节点。&lt;cell-slot&gt; 的个数只表示模板的种类数，真实列表项的个数是由数据决定的。 case 属性#声明了当前模板的类型，只有和数据中的类型与当前类型匹配时才会渲染，语义和编程语言里的 case 一致。 所有模板中最多只会匹配到一项，按照模板的顺序从上到下匹配，一旦匹配成功就不在继续匹配下一个。 default 属性#表示当前模板为默认模板类型，不需要指定值。如果数据项没有匹配到任何 case 类型，则渲染带有 default 模板。如果存在多个 default，则只会使用第一个默认模板。 key 属性#可选属性，用于指定列表数据中可以作为唯一标识的键值，可以优化渲染性能。 属性的省略# 如果没写 switch，无论有没有写 case 或 default，都只使用第一个模板。 在写了 switch 的情况下，case 和 default 必须写一个，否则该模板将会被忽略。 可复用的组件#在 &lt;recycle-list&gt; 中使用的子组件也将被视为模板，在开发组件时给 &lt;template&gt; 标签添加 recyclable 属性，才可以用在 &lt;recycle-list&gt; 中。 &lt;template recyclable&gt; &lt;div&gt; &lt;text&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // ...&lt;/script&gt; 添加了 recyclable 属性并不会影响组件本身的功能，它仍然可以用其他在正常的组件里。 实例#在上层语法中的使用方式如下： &lt;recycle-list for=\"(item, i) in longList\" switch=\"type\"&gt; &lt;cell-slot case=\"A\"&gt; &lt;text&gt;- A &#123;&#123;i&#125;&#125; -&lt;/text&gt; &lt;/cell-slot&gt; &lt;cell-slot case=\"B\"&gt; &lt;text&gt;- B &#123;&#123;i&#125;&#125; -&lt;/text&gt; &lt;/cell-slot&gt;&lt;/recycle-list&gt; 如果有如下数据： const longList = [ &#123; type: 'A' &#125;, &#123; type: 'B' &#125;, &#123; type: 'B' &#125;, &#123; type: 'A' &#125;, &#123; type: 'B' &#125;] 则会生成如下等价节点： &lt;text&gt;- A 0 -&lt;/text&gt;&lt;text&gt;- B 1 -&lt;/text&gt;&lt;text&gt;- B 2 -&lt;/text&gt;&lt;text&gt;- A 3 -&lt;/text&gt;&lt;text&gt;- B 4 -&lt;/text&gt; 如果将模板合并成一个，也可以省略 switch 和 case，将例子进一步简化： &lt;recycle-list for=\"(item, i) in longList\"&gt; &lt;cell-slot&gt; &lt;text&gt;- &#123;&#123;item.type&#125;&#125; &#123;&#123;i&#125;&#125; -&lt;/text&gt; &lt;/cell-slot&gt;&lt;/recycle-list&gt; 使用子组件#在 &lt;recycle-list&gt; 中使用了组件 &lt;banner&gt;： &lt;recycle-list for=\"(item, i) in labels\"&gt; &lt;cell-slot&gt; &lt;banner&gt;&lt;/banner&gt; &lt;/cell-slot&gt;&lt;/recycle-list&gt; &lt;banner&gt; 组件的定义如下： &lt;template recyclable&gt; &lt;text class=\"title\"&gt;BANNER&lt;/text&gt;&lt;/template&gt; 更多细节可以参考：完整代码。 注意事项#属性和文本的绑定#绑定属性或者文本时，仅支持表达式，不支持函数调用，也不支持使用 filter，可以参考 Implementation.md#支持的表达式。 例如，下列写法不可用： &lt;div :prop=\"capitalize(card.title)\"&gt; &lt;text&gt;&#123;&#123; card.title | capitalize &#125;&#125;&lt;/text&gt;&lt;/div&gt; 针对这种场景，推荐使用 computed 属性来实现。 因为模板的取值是由客户端实现的，而函数的定义在前端（filter 可以认为是在模板里调用函数的语法糖），如果每次取值都走一次通信的话，会大幅降低渲染性能。 &lt;slot&gt; 不可用#&lt;cell-slot&gt; 的功能和 &lt;slot&gt; 有部分重叠，而且更为激进，在概念上有冲突，存在很多边界情况无法完全支持。不要在 &lt;cell-slot&gt; 及其子组件里使用 &lt;slot&gt;。 v-once 不会优化渲染性能#和前端框架中的理解不同，客户端里要实现复用的逻辑，会标记模板节点的状态，添加了 v-once 能保证节点只渲染一次，但是并不一定能优化渲染性能，反而可能会拖慢客户端复用节点时的比对效率。 样式功能的限制# 计划支持 目前版本里还不支持绑定样式类名（v-bind:class），原因和进展可以参考 #14。 双向绑定# 计划支持 v-model 还未调通，暂时不要使用。 子组件的限制#没有 Virtual DOM！#使用在 &lt;recycle-list&gt; 中的组件没有 Virtual DOM！与 Virtual DOM 相关的功能也不支持。在开发过程中尽量只处理数据，不要操作生成后的节点。 下列这些属性都不再有意义，请不要使用： vm.$el vm.$refs.xxx vm.$vnode vm.#slots vm.#scopedSlots vm.$refs 里的值可能是数组、子组件的实例、DOM 元素，在前端里比较常用，如果不支持对 Weex 里的 dom 模块和 animation 模块的功能也有影响。目前正在讨论技术方案，部分接口可能会重新设计，或者是在 vm 上透出专为 &lt;recycle-list&gt; 设计的接口。 组件的属性#目前子组件的属性不支持函数。（正在讨论实现方案） &lt;sub-component :prop=\"item.xxx\" /&gt; 因为子组件的属性值需要在前端和客户端之间传递，所以仅支持可序列化的值。item.xxx 的类型可以是对象、数组、字符串、数字、布尔值等，不支持函数。 生命周期的行为差异#由于列表的渲染存在回收机制，节点渲染与否也与用户的滚动行为有关，组件的生命周期行为会有一些不一致。 可回收长列表不会立即渲染所有节点，只有即将滚动到可视区域（以及可滚动的安全区域）内时才开始渲染，组件生命周期的语义没变，但是会延迟触发。 假设有 100 条数据，一条数据了对应一个组件。渲染首屏时只能展示 8 条数据的节点，那就只有前 8 个组件被创建了，也只有前 8 个组件的生命周期被触发。 组件的 beforeCreate 和 created 也只有在组件即将创建和创建完成时才会触发。 同理，组件的 beforeMount 和 mounted 也只有页面真正渲染到了该组件，在即将挂载和已经挂载时才会触发。 修改处于屏幕外的组件的数据，不一定会触发 beforeUpdate 和 updated 生命周期。（行为未定义，需要进一步排查） 组件的自定义事件# 计划支持 vm.$on, vm.$once, vm.$emit, vm.$off 等功能还未完全调通，接口可用，但是行为可能有些差异（参数丢失），暂时不要使用。 更多例子# Web 版本的 &lt;recycle-list&gt; 还正在开发，online playground 上暂时无法预览效果，使用最新版的 playground app（SDK 版本 0.18.0 及以上）才可以扫码查看原生效果。 模板语法 绑定文本 (普通 list) 绑定属性 v-bind (普通 list) 循环 v-for (普通 list) 多层循环 (普通 list) 条件渲染 v-if/v-else/v-else-if (普通 list) 绑定事件 v-on (普通 list) 一次性渲染 v-once (普通 list) 绑定样式 (普通 list) loadmore (普通 list) 复杂压测例子 (普通 list) 无限列表 (普通 list) 使用子组件 纯静态子组件 (普通 list) 无状态，有 props (普通 list) props 更新 (普通 list) 有内部状态 (普通 list) computed &amp; watch (普通 list) 移除组件 (普通 list)","type":"references"},{"title":"<refresh>","path":"cn/references/components/refresh.html","permalink":"https://weex.apache.org/cn/references/components/refresh.html","text":"&lt;refresh&gt;#v0.6.1+#&lt;refresh&gt; 为容器提供下拉刷新功能，用法和属性与 &lt;loading&gt; 类似。 注意：&lt;refresh&gt; 是 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 的子组件，只能在被它们包含时才能被正确渲染。 简单示例： &lt;list&gt; &lt;refresh&gt; ... &lt;/refresh&gt; ...&lt;/list&gt; 查看 完整示例 子组件# 诸如 &lt;text&gt;、&lt;image&gt; 之类的任何组件，都可以放到 &lt;refresh&gt; 进行渲染。 特殊子组件 &lt;loading-indicator&gt;: 只能作为 &lt;refresh&gt; 和 &lt;loading&gt; 的子组件使用，拥有默认的动画效果实现。 简单示例： &lt;refresh&gt; &lt;text&gt;Refreshing&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/refresh&gt; 查看 完整示例 属性# 属性名 类型 值 默认值 display String show / hide show display# show：如果 &lt;refresh&gt; 中包含 &lt;loading-indicator&gt;，则将其显示并开始默认动画。 hide：收起 refresh view，如果 &lt;refresh&gt; 中包含 &lt;loading-indicator&gt;，则将其视图隐藏。 注意： display 的设置必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 简单示例： &lt;template&gt; &lt;list&gt; &lt;refresh @refresh=&quot;onrefresh&quot; :display=&quot;refreshing ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/refresh&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onrefresh (event) &#123; this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; 查看 完整示例 支持所有通用属性。查看 组件通用属性 样式# 支持所有通用样式。查看 组件通用样式 事件#refresh# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被下拉时触发。 pullingdown v0.6.1+# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被下拉时触发，可以从 event 参数对象中获取 dy, pullingDistance, viewHeight, type dy: 前后两次回调滑动距离的差值 pullingDistance: 下拉的距离 viewHeight: refresh 组件高度 type: “pullingdown” 常数字符串 简单示例： &lt;scroller&gt; &lt;refresh @refresh=&quot;onrefresh&quot; @pullingdown=&quot;onpullingdown&quot;&gt; ... &lt;/refresh&gt; ...&lt;/scroller&gt;&lt;script&gt; export default &#123; methods: &#123; onrefresh (event) &#123; ... &#125;, onpullingdown (event) &#123; console.log(&quot;dy: &quot; + event.dy) console.log(&quot;pullingDistance: &quot; + event.pullingDistance) console.log(&quot;viewHeight: &quot; + event.viewHeight) console.log(&quot;type: &quot; + type) &#125; &#125; &#125;&lt;/script&gt; 查看 完整示例 示例# 完整示例","type":"references"},{"title":"<scroller>","path":"cn/references/components/scroller.html","permalink":"https://weex.apache.org/cn/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性# show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 scroll-direction定义了 scroller 的滚动方向，样式表属性 flex-direction 定义了 scroller 的布局方向，两个方向必须一致。 scroll-direction 的默认值是 vertical, flex-direction 的默认值是 row。 当需要一个水平方向的 scroller 时，使用 scroll-direction:horizontal 和 flex-direction: row。 当需要一个竖直方向的 scroller 时，使用 scroll-direction:vertical 和 flex-direction: column。由于这两个值均是默认值，当需要一个竖直方向的 scroller 时，这两个值可以不设置。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 该属性已废弃，请使用resetLoadmore()函数实现重置loadmore的操作。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 参见 scroll event demo。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 支持 scrollstart 和 scrollend 事件 0.17+ .当列表开始或者结束滚动的时候会分别触发相应的 scrollstart 和 scrollend 事件，当前的内容高度和列表偏移会在callback中返回。可以参见这个example 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 约束#不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<slider>","path":"cn/references/components/slider.html","permalink":"https://weex.apache.org/cn/references/components/slider.html","text":"&lt;slider&gt;#&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性# auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 infinite {boolean}：循环播放，可选值为 true/false，默认的是 true。 offset-x-accuracy {number}0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间Slider Page至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 show-indicators {boolean}：设置是否显示indicator index {number}：设置显示slider的第几个页面 scrollable {boolean}：设置是否可以通过滑动手势来切换slider页面 keep-index {boolean}：设置slider中的数据发生变化后是否保持变化前的页面index index {number}: 指定当前展示页面的索引体验一下 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。体验一下事件中 event 对象属性： offsetXRatio {number}：表示当前页面的偏移比例，取值范围为[-1, 1]，负值表示向左侧滚动，正值向右。例如，-0.2表示当前item有20%的区域被滚动到slider左侧边界以外，0.3表示当前item有30%的区域被滚动到slider右侧边界以外。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<switch> (已废弃)","path":"cn/references/components/switch.html","permalink":"https://weex.apache.org/cn/references/components/switch.html","text":"v0.6.1+ 废弃: 本组件已不推荐业务上使用。由于各端实现不一致且端上定制能力较弱，不适合作为内置组件实现，因此建议开发者通过 weex 上层能力自行定制该组件. &lt;switch&gt; 是个类似 checkbox 的 UI 注意: switch 组件的外观在三个平台（iOS, Android, Web）稍有不同，这和各平台的 UI 风格有关。 Android Web iOS 注意: switch 不支持一些涉及布局的样式， 如 width, height, margin 等，下面有详细的样式不支持列表. 基本用法#&lt;switch&gt;&lt;/switch&gt; 参考示例. 特性# Attribute Type Value Default Value checked Boolean true / false false disabled Boolean true / false false checked#表示组件的选中状态。 disabled#表示组件是否处于不可交互状态。 组件方法#无。 事件# change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 样式# 注意: 某些样式在 switch 组件上不能使用或使用无效，它们是： width height min-width min-height margin 和 margin-xxx padding 和 padding-xxx border 和 border-xxx 注意: 如果 &lt;switch&gt; 的容器没有设置为 align-items：flex-start，则 Android 中的开关将被拉伸。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 使用说明# 不要设置样式 width and height，因为它们用在 &lt;switch&gt; 上不会影响该组件的外观和布局. &lt;switch&gt; 不支持内嵌子组件. 示例# 简单示例 各种状态的 switch","type":"references"},{"title":"<text>","path":"cn/references/components/text.html","permalink":"https://weex.apache.org/cn/references/components/text.html","text":"&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 注意： &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 注意： &lt;text&gt;不支持子组件。 属性# value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式# 支持 通用样式。 lines {number}: 指定文本行数。默认值是 0， 代表不限制行数。 支持 文本样式。 支持 color 样式. 支持 font-size 样式，默认值为32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 事件#支持 通用事件. \b自定义字体#支持版本:v0.12.0 支持ttf和woff字体格式的自定义字体, 可以通过调用 dom module 里面的 addRule方法, 构建自定义的font-family使用, addRule 建议在 beforeCreate 或者更早时调用 示例# \b&lt;text&gt;的基本用法","type":"references"},{"title":"<textarea>","path":"cn/references/components/textarea.html","permalink":"https://weex.apache.org/cn/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件#textarea 组件不支持子组件。 属性#textarea组件支持text组件的所有属性，除此之外还支持以下属性： rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式# 伪类v0.9.5+: textarea 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"cn/references/components/video.html","permalink":"https://weex.apache.org/cn/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件# &lt;text&gt; 是唯一合法的子组件。 特性# src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<waterfall>","path":"cn/references/components/waterfall.html","permalink":"https://weex.apache.org/cn/references/components/waterfall.html","text":"waterfall#v0.11.0+ 提供瀑布流布局的组件 子组件#注意: 和list一样, waterfall 只支持特定类型的组件: cell, header, refresh, loading 和 fixed-position 组件. cell: 瀑布流中的每个元素 header: 主要用于表示横跨多列的元素，可以通过css的position属性设置为sticky 特性# show-scrollbar : 可选值为 true/ false，默认值为 true。控制是否出现滚动条。 column-width : 描述瀑布流每一列的列宽 auto: 意味着列宽是被其他属性所决定的(比如 column-count) &lt;length&gt;: 最佳列宽，实际的列宽可能会更宽(需要填充剩余的空间)， 或者更窄(如果剩余空间比列宽还要小)。 该值必须大于0 column-count: 描述瀑布流的列数 auto: 意味着列数是被其他属性所决定的(比如 column-width) &lt;integer&gt;: 最佳列数，column-width 和 column-count 都指定非0值， 则 column-count 代表最大列数。 column-gap: 列与列的间隙. 如果指定了 normal ，则对应 32. left-gap: 左边cell和列表的间隙. 如果未指定 ，则对应 0v0.19+. right-gap: 右边cell和列表的间隙. 如果未指定，则对应 0v0.19+. 其他支持的属性参见 List Component Attributes 样式#通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 API#滚动到列表某个指定项是常见需求，&lt;waterfall&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt; 或者 &lt;header&gt;。通过 dom module 访问，更多信息可参考 dom module 。 示例#waterfall example","type":"references"},{"title":"<web>","path":"cn/references/components/web.html","permalink":"https://weex.apache.org/cn/references/components/web.html","text":"v0.5+ &lt;web&gt; 用于在 weex 页面中显示由 src 属性指定的页面内容。您还可以使用 webview 模块来控制 WebView 的行为，例如回退、前进和重新加载，更多信息请参见 webview module。 基本用法# 注意： &lt;web&gt; 不支持任何嵌套的子组件，并且必须指定 width 和 height 的样式属性，否则将不起作用。 &lt;web src=\"https://vuejs.org\"&gt;&lt;/web&gt; 参见示例. 属性# 属性 类型 值 默认值 src String {URL} - src#要加载的网页内容的 URL。您可以指定一个基于 bundle URL 的相对 URL，它将被重写为真实资源 URL（本地或远程）。另请参阅：Path。 事件#只支持公共事件中的 appear 和 disappear 事件。 pagestart#pagestart 事件，会在 Web 页面开始加载时调用。 事件对象： url: {String} 当前 Web 页面的 URL。 pagefinish#pagefinish 事件，会在 Web 页面完成加载时调用。 事件对象： url: {String} 当前 Web 页面的 URL。 canGoBack: {Boolean} 当前 Web 页面是否可以回退。 canGoForward: {Boolean} 当前 Web 页面是否可以前进。 title: {String} 当前 Web 页面的标题（仅限 iOS 平台）。 error#error 事件，会在 Web 页面加载失败时调用。 receivedtitle#error 事件，会在 Web 页面的标题发生改变时调用（仅限 Android 平台）。 事件对象： url: {String} 当前 Web 页面的 URL。 处理 &lt;web&gt; 事件#在 &lt;web&gt; 上绑定事件： &lt;web @pagestart=\"onPageStart\" @pagefinish=\"onPageFinish\" @error=\"onError\" src=\"https://vuejs.org\"&gt;&lt;/web&gt; 添加事件 handler： export default &#123; methods: &#123; onPageStart (event) &#123; // page start load &#125;, onPageFinish (event) &#123; // page finish load &#125;, onError (event) &#123; // page load error &#125;, &#125;&#125; 参见示例。 样式#支持公共样式。 使用注意事项# 必须指定 &lt;web&gt; 的 width 和 height 样式。 &lt;web&gt; 不能包含任何嵌套的子组件。 您可以使用 webview module 来控制 &lt;web&gt; 组件，参见示例。 示例# 浏览器示例","type":"references"},{"title":"animation","path":"cn/references/modules/animation.html","permalink":"https://weex.apache.org/cn/references/modules/animation.html","text":"动画#简介#animation 模块可以用来在组件上执行动画。 JS-Animation可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。 举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 注意： 现在Weex只支持在JavaScript中使用动画, CSS 动画是和JavaScript 动画是不一样的。我们即将支持在CSS中使用动画。 基本用法#animation.transition(el, options, callback)#animation.transition(ref1, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(250px, 100px)', &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) 属性#el：#将要执行动画的元素。 例如指定动画的元素 el 属性为 test , 可以通过调用 this.refs.test 来获取元素的引用。 options：# styles(object):设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 width 动画执行后应用到组件上的宽度值 length 无 height 动画执行后应用到组件上的高度值 length 无 backgroundColor 动画执行后应用到组件上的背景颜色 string none opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 transform同时也有很多对应的属性，可以参见下表： (注:如果想同时执行多个动画只需要用空格隔开，比如)transform: &apos;translate(250px, 100px) scale(1.5)&apos; 名称 描述 值类型 默认值 translate/translateX/translateY 指定元素要移动到的位置 像素值或百分比 无 rotate 指定元素将被旋转的角度，单位是度 number 无 scale/scaleX/scaleY 按比例放大或缩小元素 number 无 rotate/rotateX v0.14+ /rotateY v0.14+ 指定元素将被旋转的角度，单位是度 number 无 perspective v0.16+ 观察者距离z=0平面的距离，在Android 4.1及以上有效 number 正无穷 duration(number)：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 delay (number)：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 needLayout (boolean)：节点动画执行时是否产生布局动画即LayoutAnimation，默认值是false。 timingFunction (string)：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 linear 动画从头到尾的速度是相同的 ease 动画速度逐渐变慢 ease-in 动画速度由慢到快 ease-out 动画速度由快到慢 ease-in-out 动画先加速到达中间点后减速到达终点 cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. callback#callback是动画执行完毕之后的回调函数。在iOS平台上，你可以获取动画执行是否成功的信息。 注意: 在0.16.0+版本后，iOS上可以获取animation是否执行成功的信息，callback中的result参数会有两种，分别是是Success与Fail，Android目前暂不支持。 示例#animation demo","type":"references"},{"title":"clipboard","path":"cn/references/modules/clipboard.html","permalink":"https://weex.apache.org/cn/references/modules/clipboard.html","text":"clipboard 剪切板#v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。目前很多手机自带一键复制短信中的验证码到剪贴板功能，再配合使用 clipboard.getString() 接口，就可以直接获取到验证码信息，并且进行下一步操作，例如帮助用户自动填到对应输入框中。 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 API#getString(callback)#从系统粘贴板读取内容。 参数# callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 setString(text)#将一段文本复制到剪切板，相当于手动复制文本。 参数# text {string}：要复制到剪切板的字符串。 Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"custom font","path":"cn/references/modules/custom_font.html","permalink":"https://weex.apache.org/cn/references/modules/custom_font.html","text":"Custom Font v0.12.0+#简介#Weex 提供 DOM.addRule 以加载自定义字体。开发者可以通过指定 font-family加载 iconfont 和 custom font。 API#开发者可以使用下面的代码加载自定义字体： const domModule = weex.requireModule(&apos;dom&apos;) domModule.addRule(&apos;fontFace&apos;, { &apos;fontFamily&apos;: &quot;iconfont2&quot;, &apos;src&apos;: &quot;url(&apos;http://at.alicdn.com/t/font_1469606063_76593.ttf&apos;)&quot; }); 参数含义如下: fontFace 协议名称，不可修改。 fontFamily font-family的名称。 src 字体地址，url(‘’) 是保留字段，其参数如下: http. 从HTTP请求加载, e.g. url(&#39;http://at.alicdn.com/t/font_1469606063_76593.ttf&#39;) https. 从HTTPS请求加载, e.g. url(&#39;https://at.alicdn.com/t/font_1469606063_76593.ttf&#39;) local, Android ONLY. 从assets目录读取, e.g. url(&#39;local://foo.ttf&#39;), foo.ttf 是文件名在你的assets目录中. file. 从本地文件读取, e.g. url(&#39;file://storage/emulated/0/Android/data/com.alibaba.weex/cache/http:__at.alicdn.com_t_font_1469606063_76593.ttf&#39;) data. 从base64读取, e.g. url(&#39;data:font/truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwR1NVQrD+....&#39;), 上述data字段不全。 Note# Note: addRule 方法里的 fontFamily 可以随意取。这个名字不是字体真正的名字。字体真正的名字（font-family），也就是注册到系统中的名字是保存在字体二进制文件中的。你需要确保你使用的字体的真正名字（font-family）足够特殊，否则在向系统注册时可能发生冲突，导致注册失败，你的字符被显示为‘?’。 Note: 如果你使用 http://www.iconfont.cn/ 来构建你的 iconfont。确保在项目设置中，设置一个特殊的 font-family 名字。默认是 “iconfont”，但极大可能发生冲突。 Note: 调用addRule 在 beforeCreate 中是被推荐的。 Example#示例。","type":"references"},{"title":"dom","path":"cn/references/modules/dom.html","permalink":"https://weex.apache.org/cn/references/modules/dom.html","text":"dom#dom 模块用于对 weex 页面里的组件节点进行一部分特定操作。 你可以使用该模块来获取某个组件的 bounding rect 布局信息，或者将 list 的某个子节点滚动到当前视口，或者添加一个 font-face rule，等等。 Note: API addRule 目前仅支持添加 ‘font-face’. API#scrollToElement(ref, options)#让页面滚动到 ref 对应的组件，这个 API 只能用于可滚动组件的子节点，例如 &lt;scroller&gt;，&lt;list&gt; 等可滚动组件中。 要在你的 .vue 文件中使用这个 API，可以使用 weex.requireModule(&#39;dom&#39;).scrollToElement。 参数# ref {Node}：你要滚动到的那个节点 options {Object}: offset {number}: 一个到其可见位置的偏移距离，默认是 0 animated {boolean} 0.10+：是否需要附带滚动动画，默认是true 示例#滚动到某层 getComponentRect(ref, callback) v0.9.4+#支持版本: &gt;=0.9.4 通过标签的 ref 获得其布局信息，返回的信息在 callBack 中，格式参考如下： &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; 如果想要获取到 Weex 视口容器的布局信息，可以指定 ref 为字符串 &#39;viewport&#39;，即 getComponentRect(&#39;viewport&#39;, callback). 示例#获取 box 的布局信息 addRule(type, contentObject) v0.12.0+#支持版本: &gt;=0.12.0 参考自定义字体。","type":"references"},{"title":"globalEvent","path":"cn/references/modules/globalevent.html","permalink":"https://weex.apache.org/cn/references/modules/globalevent.html","text":"全局事件#0.8 globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件#API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#注册全局事件。 参数# eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#取消事件监听。 参数# eventName {string}：需要取消的事件名称。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\"); 已有的全局事件#0.14 应用前后事件#WeexSDK 对获取应用前后台事件做了支持，开发者可以在页面内监听对应的事件，获得应用被前后后这后台，以方便暂停音乐，视频等，只需要指定需要监听的事件名称和回调函数就可以，例如： var globalEvent = weex.requireModule(&apos;globalEvent&apos;);globalEvent.addEventListener(&quot;WXApplicationDidBecomeActiveEvent&quot;, function (e) &#123; console.log(&quot;WXApplicationDidBecomeActiveEvent&quot;);&#125;); 支持的事件名称 WXApplicationDidBecomeActiveEvent 应用被前台的时候触发 WXApplicationWillResignActiveEvent 应用即将被后台时候触发 在 dotWe 上试一试 目前只有 platform 为 iOS 和 Android 才能支持。获取当前 platform","type":"references"},{"title":"meta","path":"cn/references/modules/meta.html","permalink":"https://weex.apache.org/cn/references/modules/meta.html","text":"meta#meta 模块可用于声明单个页面的元信息，通常是一些页面级别的配置，如容器的显示宽度 (viewport) 等。默认情况下，应用无需修改此配置。 API#setViewport(options)#0.10.0+ Weex 容器默认的宽度 (viewport) 是 750px，通过 setViewport 方法可以改变页面的显示宽度，仅对当前页面生效。 需要注意的是：只有在页面渲染开始之前设置 viewport 才会生效。 也就是说，setViewport 方法只能在入口文件中使用，而且要在 new Vue(...) 之前调用；如果是在组件中使用，就只有在渲染到该组件的时候才会执行相应的代码，此时页面已经处于渲染过程中，设置 viewport 将不会再生效。 参数#参数配置借鉴了 W3C 标准中的 CSS Device Adaptation，目前支持如下属性： options: viewport 的配置项 width: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 height: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 宽度和高度的单位默认是 px，暂不支持其他单位。 例子#入口文件： // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// 配置 viewport 的宽度为 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) 在入口文件中配置了 viewport 的宽度为 640 之后，当前页面中的所有组件都会以 640px 作为满屏宽度。 组件文件： &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; 试试看。（由于 http://dotwe.org 目前还不支持配置入口文件，例子中的效果暂时无法在线查看。） 本地开发环境的搭建可以参考：《搭建开发环境》。","type":"references"},{"title":"modal","path":"cn/references/modules/modal.html","permalink":"https://weex.apache.org/cn/references/modules/modal.html","text":"modal 模态#modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 API#toast(options)#toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数# options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） Android: 如果时间长度大于3s，将使用一个被称为LONG的系统变量, 否则使用SHORT这个系统变量 iOS: 持续的时间同Duration相同 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.toast(&#123; message: &apos;This is a toast&apos;, duration: 0.3&#125;) alert(options, callback)#警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数# options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.alert(&#123; message: &apos;This is a alert&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;alert callback&apos;, value)&#125;) confirm(options, callback)#确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数# options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.confirm(&#123; message: &apos;Do you confirm ?&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;confirm callback&apos;, value)&#125;) prompt(options, callback)#提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数# options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下： result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.prompt(&#123; message: &apos;This is a prompt&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;prompt callback&apos;, value)&#125;) 示例#Modal demo","type":"references"},{"title":"navigator","path":"cn/references/modules/navigator.html","permalink":"https://weex.apache.org/cn/references/modules/navigator.html","text":"navigator 导航控制#v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 API#push(options, callback)#把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数# options {Object}：选项参数 url {string}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 pop(options, callback)#把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数# options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"picker","path":"cn/references/modules/picker.html","permalink":"https://weex.apache.org/cn/references/modules/picker.html","text":"picker#v0.9+ 概述#以下为 picker 相关的 API，用于数据选择，日期选择，时间选择。（ H5模块如需使用，请手动引入weex-picker组件） API#pick(options, callback[options])#调用单选 picker 参数# options {Object}：调用单选 picker 选项 index {number}：默认选中的选项 items {array}：picker 数据源 textColor {color}：picker中文字的颜色 selectionColor {color}：picker中选中item的背景色 confirmTitle {string}：确认按钮的文案 cancelTitle {string}：取消按钮的文案 confirmTitleColor {color}：确认按钮的文字颜色 cancelTitleColor {color}：取消按钮的文字颜色 title {string}：对话框的标题 titleColor {color}：对话框标题的文字颜色 titleBackgroundColor {color}：对话框标题的背景色 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {number}：选择的选项,仅成功确认时候存在。 pickDate(options, callback[options])#调用 date picker 参数# options {Object}：调用 date picker 选项 value {string}：必选，date picker 选中的值，date 的字符串格式为yyyy-MM-dd max {string}：可选，date 的最大值 min {string}：可选，date 的最小值 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：选择的值 date 的字符，格式为 yyyy-MM-dd, 仅成功确认的时候存在。 pickTime(options, callback[options])#调用 time picker 参数# options {Object}：调用 time picker 选项 value {string}：必选，time 格式为 HH:mm callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：time 格式为 HH:mm, 仅成功确认的时候存在。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"storage","path":"cn/references/modules/storage.html","permalink":"https://weex.apache.org/cn/references/modules/storage.html","text":"storage 本地存储#v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 API#storage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)#该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数# key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)#传入键名返回对应的键值 参数# key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined removeItem(key, callback)#传入一个键名将会删除本地存储中对应的键值 参数# key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 length(callback)#返回本地存储的数据中所有存储项数量的整数 参数# callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 getAllKeys(callback)#返回一个包含全部已存储项键名的数组 参数# callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it 其它参考# W3school: html5 localStorage","type":"references"},{"title":"stream","path":"cn/references/modules/stream.html","permalink":"https://weex.apache.org/cn/references/modules/stream.html","text":"stream#概述#以下为 stream 相关的 API，用于实现网络请求。 API#fetch(options, callback[,progressCallback])#发起网络请求 参数# options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：响应类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 注意# 默认 Content-Type 是 ‘application/x-www-form-urlencoded’。 如果你需要通过 POST json ， 需要将 Content-Type 设为 ‘application/json’。 Example#stream demo","type":"references"},{"title":"webSocket","path":"cn/references/modules/websocket.html","permalink":"https://weex.apache.org/cn/references/modules/websocket.html","text":"webSocket#v0.12+ Summary#WebSockets 是一种先进的技术, 这使得在用户的 H5/iOS/Android 和一个服务器之间打开一个的交互式通信会话成为可能, 有了这个 API，你可以向服务器发送消息, 并接收事件驱动的响应, 无需轮询服务器的响应 注意：# iOS和h5提供 WebSockets 的 protocol 默认实现，安卓使用需要提供自定义 adapter 实现，source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; 集成例子参考weex playground API#WebSocket(url, protocol)#创建 WebSockets，并连接服务器 Arguments# url {string}: 表示要连接的 URL; protocol {string}: WebSockets 协议 send(data)#通过WebSocket连接向服务器发送数据 Arguments# data{string}:要发送到服务器的数据 close(code,reason)#关闭 WebSockets 的链接 Arguments# code {number}: 关闭连接的状态号. reason {string}: 关闭的原因 onopen(options)#链接打开的监听 Arguments# options {object}: 一个空的对象 onmessage(options)#消息事件的监听器 Arguments# options {object}: 服务器返回的消息对象 data {string}: 监听器接收的到的消息 onclose(options)#关闭事件的监听器 Arguments# options {object}: 监听器接收到的对象 code {number}: 服务器返回关闭的状态码 reason {string}: 服务器返回的关闭原因 wasClean {boolen}: 是否完全关闭. onerror(options)#错误事件的监听器 Arguments# options {object}: 错误信息的事件 data {string}: 监听器接收到的信息 Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"cn/references/modules/webview.html","permalink":"https://weex.apache.org/cn/references/modules/webview.html","text":"webview 模块提供了一系列的 &lt;web&gt; 组件操作接口，例如 goBack、goForward、和 reload。一般与 &lt;web&gt; 组件一起使用。 API#goBack(webElement)#前往 WebView 历史记录的上一页。 参数 webElement(web): &lt;web&gt; 组件元素。 goForward(webElement)#前往 WebView 历史记录的下一页。 参数 webElement(web): &lt;web&gt; 组件元素。 reload(webElement)#刷新当前 Web 页面。 参数 webElement(web): &lt;web&gt; 组件元素。 postMessage(webElement, data)#向当前 Web 页面发送数据。(android weex_sdk:0.18.0-beta-3 开始支持) 参数 webElement(web): &lt;web&gt; 组件元素。 data {Object}: 要发送的数据 示例# 简单用法： var webElement = this.$el('webview');var webview = weex.requireModule('webview');webview.goBack(webElement.ref);webview.goForward(webElement.ref);webview.reload(webElement.ref);webview.postMessage(webElement, &#123;message: 'message to Web page'&#125;);// Web 页面中接收数据window.addEventListener('message', event =&gt; &#123; console.log(event.data) // message to Web page&#125;) 浏览器示例","type":"references"}],"posts":[{"title":"Weex ❤️ iOS 11 系列之二：ARKit初探","path":"en/arkit/","link":"","permalink":"https://weex.apache.org/en/arkit/","text":"ARKit#苹果在wwdc 2017公布了第一款具有AR功能的操作系统iOS11，并提供了AR的SDK，ARKit，同时宣称苹果是世界上最大的AR平台，Weex也积极拥抱AR，让Weex用户也可以方便开发AR功能 AR体验就是创建和追踪用户所在的现实世界和可建立模型的空间的对应关系的能力，让用户感觉产生虚拟内容在现实世界的错觉，这就是所谓的增强现实。ARKit通过识别图像场景中的显著特征，追踪这些特征的差异位置，最后与传感器数据比较，得到设备位置和运动状态的高精度模型 原理#ARkit 在ARSCNView，ARSession,ARFrame的基础上实现 ARSCNView和ARSession#ARKit提供了两种增强现实的视图，他们分别是ARSCNView(3D)和ARSKView(2D),这两种视图都采用ARCamera作为视图背景的，而ARSCNView等视图和相机没有直接关系，他们是通过ARSession这个桥梁和camera交互的，运行一个session，需要指定会话追踪配置的对象：ARSessionConfiguration，ARSessionConfiguration负责追踪相机在3D世界中的位置和平面探测 ARWorldTrackingSessionConfiguration与ARFrame#ARWorldTrackingSessionConfiguration通过一系列的复杂计算和调用传感器来跟踪设备的方向和位置，当ARWorldTrackingSessionConfiguration计算出位置，会交给ARSession管理,ARSession就会维护一个相机的位置ARFame，用户可以通过这个frame将4x4矩阵世界坐标转换为3D系统相机坐标 weex-ar#ARKit在wwdc上带来的震撼效果，我通过weex插件的方式将ARKit能力透传到Weex，让用户在weex上也第一时间体验到Native的AR效果所有的demo以及源码我已经开源，同步到github，用户在自己工程依赖即可使用 在现实世界渲染一个3D的虚拟物体#this.$refs[&apos;scene&apos;].addNode(&#123; name:&apos;color&apos;, width:0.1, height:0.1, length:0.1, chamferRadius:0, vector:&#123; x:0.1, y:0.1, z:-0.5 &#125;, contents:&#123; type:&apos;color&apos;, name:&apos;red&apos; &#125; &#125;); Weex在compnonent中增加addNode方法，用户可以设置好节点的参数，然后就会构建一个虚拟物体 效果 交互支持#当native触发了点击事件，会向jsfm发送点击位置信息 -(void)tapped:(UITapGestureRecognizer *)recognizer&#123; SCNView *sceneView = (SCNView *)recognizer.view ; CGPoint touchLocation = [recognizer locationInView:sceneView]; [self fireEvent:@&quot;tap&quot; params:@&#123;@&quot;touchLocation&quot;:@&#123;@&quot;x&quot;:@(touchLocation.x),@&quot;y&quot;:@(touchLocation.y)&#125;&#125;];&#125; 当VUE接收到相关信息，会处理位置信息，然后更新节点tap:function (event) &#123; this.index = this.index+1; if(this.index&gt;3)&#123; this.index = 0; &#125; var color = &apos;red&apos;; if(this.index == 1)&#123; color = &apos;blue&apos;; &#125; if(this.index == 2)&#123; color = &apos;green&apos;; &#125; if(this.index == 3)&#123; color = &apos;yellow&apos;; &#125; this.$refs[&apos;scene&apos;].updateNode(&#123; name:&apos;color&apos;, x:event.touchLocation.x, y:event.touchLocation.y, color:color &#125;) &#125; 效果 碰撞游戏#设置节点的mask，通过arkit的代理就可以检测碰撞了node.physicsBody.categoryBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;categoryBitMask&quot;]]]; node.physicsBody.contactTestBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;contactTestBitMask&quot;]]]; 当碰撞发生时候，会通过physicsWorld:(SCNPhysicsWorld )world didBeginContact:(SCNPhysicsContact )contact代理获取到节点的信息，weex将相关信息发送到jsfmvue获取先关节点可以删除节点，增减节点，从而完成碰撞的处理contact:function (event) &#123; if(event.nodes.nodeA.mask == 0 || event.nodes.nodeB.mask == 0 )&#123; this.isAdd = false; this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeA.name); this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeB.name); &#125; &#125; 效果","type":"blog"},{"title":"Weex ❤️ iOS 11 系列之一：Core ML 初探","path":"en/coreml/","link":"","permalink":"https://weex.apache.org/en/coreml/","text":"背景#WWDC 2017 有一个非常明确的信号：端上机器学习将会是未来苹果的一个重要发力点，同时开发者的使用门槛在不断降低。 Core ML 是今年 WWDC 上苹果发布的机器学习框架。它允许开发者在自己开发的 app 上使用机器学习，同时不需要收集用户数据。 有了 Core ML，你可以将自己训练得到的模型，借助苹果提供的转换工具，转化成 Core ML 类型的模型文件，你可以非常轻松地直接实现模型和 app 数据的互通。 WWDC 上展示了一张简单的架构图： 最底层的 Accelerate 和 MPS，其实是苹果去年推出的接口，前者可以直接调用 CPU，后者则直接调用 GPU。 Core ML 会自行决定到底使用 CPU 还是 GPU 来进行运算，可以最大程度地利用硬件资源来处理模型数据。 而 Core ML 往上一层则是应用层。Vision 主要负责图像相关的人工智能处理，如人脸识别、面部追踪、文字识别等等；NLP 则提供语义分析相关 API。这部分内容在以前版本的 SDK 中也存在，这次被集成到了新框架当中。好处在于，开发者拥有了更大的自由度。在以前，开发者的 app 调用这些高级接口，对底层的实现细节的掌控力度非常小。现在，你可以通过自定义底层所使用的机器学习模型，从而实现更个性化的需求。 Weex-ML#Weex 交互视觉能力小结中提到，Weex 最大的特别之处在于其 native 的能力， 我们要最大化利用 native 的特性， 而不是去模仿它。 作为本次 iOS 11 的一个重要 native 能力，我也第一时间尝试将 Core ML 透传到了 Weex 上。所有代码和 Demo 都已开源到 Github，后续也会将机器学习相关的Weex 模块统一放到 Weex Market 上。 得益于 Core ML API 的简洁，在 Weex 上使用 Core ML 相关能力变得非常简单: let imageRecognition = weex.requireModule('imageRecognition')imageRecognition.predictWithImage(this.$refs.image.ref, (results)=&gt;&#123; this.results = results.slice(0,5);&#125;) 通过调用透传的 module imageRecognition , 并传入 image 组件的 ref 作为参数，就可以实现图片识别的功能，最后提取出识别结果中 confidence 最高的 5 个结果。 Demo#imageRecognition# 使用 Inceptionv3 作为模型，能够高效识别， 该模型已经在 keras 中被训练好并通过苹果提供的工具转换成 mlmodel 文件， 只需拖拽的方式就可以集成到 iOS 开发环境中， 上述 demo 输出了对一张图片分类最大可能的5个预测结果， 对于 Weex 来说，几行代码就能搞定。 digitDetect# 上述 demo 首先使用 weex-gcanvas 插件做了一个简单的绘制板，然后使用 MNIST model 完成了对手写数字的识别。 faceDetect# 这个 demo 没有加载任何 model，使用了 iOS 11 内置的 Vision Framework，顾名思义，Vision 可以让开发者运行计算机视觉相关的任务，它相当于 Core ML 的 High-Level Solution， 它可以做很多事情: 脸部识别，会返回一个矩形数组来表示每一个脸部 脸部更精细识别，比如眼睛和鼻子的具体位置、头部的形状等，上述 demo 就是拿到这些信息以后使用 gcanvas 绘制出了面部精细轮廓 图片中的矩形探测 图片中的文字探测 二维码/条形码探测 视频中跟踪移动的物体 总结#这次 Core ML 的推出，同时得益于苹果对软硬件的全面掌控，使得从系统级到第三方开发者，都具备了在端上就可以进行机器学习模型处理的能力。所有代码和 Demo 都已上传到 Github，欢迎贡献和交流。 当然在实际研究过程中，也发现了 Core ML \u0005的一些限制： 无法在端上进行模型的训练，所有模型必须提前训练好再转换成 Core ML 的格式 无法动态下载和更新模型，对于需要经常重新训练的模型不太友好 目前看只支持监督学习的模型，不支持非监督学习。 Weex 未来在提供更多功能透传的同时，也会继续探索更深层次的结合。 最后，本文是 Weex 和 iOS 11 结合系列的第一篇文章，后续将会有更多有意思的iOS 11 feature (如 ARKit、 drag &amp; drop 等) 和大家一起探讨。","type":"blog"}]}